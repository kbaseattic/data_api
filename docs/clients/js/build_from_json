#!/usr/bin/env python
"""
Generate a ReStructured Text documentation file from the Thrift-generated
JSON. The resulting file can be fed to 'sphinx' to create
documentation webpages.

See the Makefile in the docs/ directory for usage.
"""
__author__ = 'Dan Gunter <dkgunter@lbl.gov>'

import argparse
from operator import itemgetter
import json
import os
import re
import sys

def write_rst(input_json, output_stream, title, classname):
    services = input_json['services']
    module = input_json['name'].capitalize()

    output_stream.write(get_title_text(title, classname))
    method, varname = choose_example_method(services)
    output_stream.write(get_preamble_text(title, classname, method, varname))

    doc = RstDocRootClass(classname)
    output_stream.write(str(doc))
    output_stream.write('\n\n')

    main_service = services[0]
    functions = main_service['functions']
    for fn_count, fn_dict in enumerate(functions):
        doc = RstDocFunction(module=module, **fn_dict)
        if fn_count:
            output_stream.write('\n\n')
        output_stream.write(str(doc))

    typedefs = input_json['typedefs']
    for td_count, td_dict in enumerate(typedefs):
        td_dict['module'] = module
        td_dict['type_'] = td_dict['type']
        del td_dict['type']
        doc = RstDocTypedef(**td_dict)
        output_stream.write('\n\n')
        output_stream.write(str(doc))
        
    structs = input_json['structs']
    for struct_count, struct_dict in enumerate(structs):
        struct_dict['module'] = module
        doc = RstDocStruct(**struct_dict)
        output_stream.write('\n\n')
        output_stream.write(str(doc))

def choose_example_method(service_json):
    method_name, result_var_name = 'foo', 'bar'
    functions = service_json[0]['functions']
    for fn in functions:
        if (fn['name'].startswith('get_') and len(fn['arguments']) == 2 and 
            not '<' in fn['returnType']):
            method_name = fn['name']
            result_var_name = method_name[4:]
            break
    return method_name, result_var_name
    
def get_title_text(title, classname):
    title = 'JavaScript ' + title + ' Data API'
    underline = '=' * len(title)
    link = '.. _js_' + title.lower().replace(' ','_') + ':'
    return '.. include:: ../wsref.txt\n\n{}\n\n{}\n{}\n'.format(link, title, underline)

def get_preamble_text(title, classname, example_method, example_varname):
    init = ('{i}// access reference data (no token required)\n'
              '{i}var api_obj = {c}({{\n'
              '{i}{i}ref: \'{r}\',\n'
              '{i}{i}url: \'{u}\',\n'
              '{i}{i}token: \'\',\n'
              '{i}{i}timeout: 6000\n'
              '{i}}});').format(c=classname,
                              u='http://narrative.kbases.us',
                              r='1013/92/2',
                              i='    ')
                              
    usage = ('{i}// call function using Promise interface\n'
              '{i}api_obj.{method}().then(\n'
              '{i}{i}function({var}) {{\n'
              '{i}{i}{i}do_something_with({var});\n'
              '{i}}});').format(method=example_method,
                                var=example_varname, i='    ')

    fmt_args = {
        'title': title,
        'class': classname,
        'a_n': 'n' if title.lower()[0] in 'aeiou' else '',
        'example_init': '.. code-block:: javascript\n\n{}'.format(init),
        'example_usage': '.. code-block:: javascript\n\n{}'.format(usage)
    }
    fmt_args.update({
        'underdash1': '-' * (len(fmt_args['class']) + 17 + len(fmt_args['a_n'])),
        'underdash2': '-' * (len(fmt_args['title']) + 10),
    })
    s =\
'''The {title} API can be used as a client of the Python server.

.. contents::

Creating and using a{a_n} {class} object
{underdash1}
To create a new object, instantiate :js:class:`{class}`
using a configuration object as the input argument.

{example_init}

To use the object, call the Promise-wrapped functions
and process the results accordingly.

{example_usage}

{title} interface
{underdash2}
'''
    return s.format(**fmt_args)

def add_type_links(value):
    """Replace type names with a link to the definition.

    Type names are recognized by the convention of starting with an
    uppercase letter.
    """
    vs = value.strip()
    backquoted = vs.startswith('``') and vs.endswith('``')
    quote = '``' if backquoted else ''
    result = re.sub('([A-Z]\w+)', '{q} :js:class:`\\1` {q}'.format(q=quote), vs)
    result = result.replace('````', '')  # remove empty backquoted sections
    return result

class RstDocRootClass(object):
    def __init__(self, class_name):
        self.name = class_name

    def __str__(self):
        indent = '    '
        cfg = ['* ref - The object reference for the object to be accessed in the format expected by the workspace: |wsref|.',
               '* url - The url for the GenomeAnnotation Service endpoint.',
               '* token - The KBase authorization token to be used to access the '
               'service.']
        lines = ['.. js:class:: {}(config)'.format(self.name), '',
                 indent + ':param object config: Configuration object.'
                          ' This object has the following fields:',
                 '\n'.join(['    ' + line for line in cfg]),
                 indent + ':throws ArgumentError:']
        return '\n'.join(lines)

class RstDocStruct(object):
    def __init__(self, module=None, fields=None, name=None,
                 isException=None):
        assert module is not None
        assert fields is not None
        assert name is not None
        self._exc = isException is not None
        self.info = { 'module': module, 'name': name}
        self.fields = fields

    def __str__(self):
        indent = ' ' * 4
        lines = ['----', '', '.. js:class:: {name}()\n'.format(**self.info)]
        object_name = self.info['name']
        lengths = {'tlen': max([len(f['type']) for f in self.fields]),
                   'nlen': max([len(f['name']) for f in self.fields]),
                   'ftlen': 10}
        header = '{{:{tlen}s}} {{:{nlen}s}} optional'.format(**lengths)\
            .format('type', 'attr')
        border = '{} {} {}'.format('=' * lengths['tlen'],
                                   '=' * lengths['nlen'],
                                   '=' * lengths['ftlen'])
        lines.extend([border,
                     #'Members',
                     #'-' * (sum(lengths.values()) + len(lengths) - 1),
                     header,
                     border])

        for f in self.fields:
            f['ftype'] = 'Required' if f['required'] == 'true' else 'Optional'
            s = '{{type:{tlen}s}} {{name:{nlen}s}} {{ftype}}'.format(
                    **lengths).format(**f)
            lines.append(s)
        lines.append(border)
        lines.append('')
        return '\n'.join(lines).format(**self.info)

class RstDocTypedef(object):
    def __init__(self, module=None, name=None, type_=None):
        assert module is not None
        assert type_ is not None
        assert name is not None
        self.info = { 
            'module': module, 
            'name': name,
            'type': add_type_links('``' + type_ + '``')
        }

    def __str__(self):
        indent = ' ' * 4
        lines = ['----', '', '.. js:data:: {name}\n'.format(**self.info)]
        lines.append('')
        lines.append(indent + self.info['type'])
        return '\n'.join(lines)
    
class RstDocFunction(object):
    """Create a JavaScript documented function from the JSON output
    of the command 'thrift -gen json'.
    """
    def __init__(self, name=None, doc="", arguments=None, returnType=None,
                 exceptions=None, module=None, root_class=None):
        assert name is not None
        assert arguments is not None
        assert returnType is not None
        assert exceptions is not None
        assert module is not None
        arguments = arguments[2:]  # strip token, ref from beginning

        self._desc, self._returns, self._params = '', '', {}
        self._process_doc(doc)

        return_desc = add_type_links('``' + returnType + '``')
        if self._returns:
            return_desc += ' ' + self._returns

        # add 'desc' to each argument
        for arg in arguments:
            arg_name = arg['name']
            if arg_name in self._params:
                arg['desc'] = self._params[arg_name]
            else:
                arg['desc'] = ''

        self.info = {
            'description': self._desc,
            'args': arguments,
            'return': return_desc,
            'throws': [e['type']  for e in exceptions],
            'name': name,
            'module': module,
            'see_also': []
        }

    def _process_doc(self, doc):
        """Process documentation string, stripping out and setting
        return value and parameter descriptions.
        These are set into:
             - self._desc: Function description
             - self._returns: Return value description
             - self._params: Dict with key param name, value
                             param description
        """
        lines = doc.split('\n')
        desc = []
        for line in lines:
            line = line.strip()
            if line.startswith('@return '):
                self._returns = line[8:].strip()
            elif line.startswith('@param '):
                items = line[7:].split()
                if len(items) == 1:
                    param_name, param_value = line[7:].strip(), ''
                else:
                    param_name, param_value = items[0], ' '.join(items[1:])
                self._params[param_name] = param_value
            else:
                desc.append(line)
        self._desc = ' '.join(desc)


    def __str__(self):
        self.info['arglist'] = ', '.join(
            map(itemgetter('name'), self.info['args']))
        lines = ['.. js:function:: {name}({arglist})', '']
        indent = '    '
        # add docstring
        for docline in self.info['description'].split('\n'):
            if docline.strip():
                lines.append(indent + docline)
        lines.append('')
        # add args
        for a in self.info['args']:
            param = indent + ':param {type} {name}: {desc}'.format(**a)
            lines.append(param)
        # add exceptions
        for exc in self.info['throws']:
            throws = indent + ':throws {}:'.format(exc)
            lines.append(throws)
        lines.append(indent + ':returns: {return}')
        return '\n'.join(lines).format(**self.info)


def cmdline():
    p = argparse.ArgumentParser()
    p.add_argument('json_file')
    p.add_argument('output_file')
    p.add_argument('-t', '--title', dest='title', help='API page title',
                   default=None)
    p.add_argument('-c', '--class', dest='classname', help='API class name',
                   default=None)
    args = p.parse_args()
    if args.title is None:
        ofname = os.path.basename(args.output_file)
        ofname = os.path.splitext(ofname)[0]
        args.title = ofname.replace('_', ' ')\
            .capitalize()\
            .replace('api', 'API')
        args.classname = ''.join([tok.capitalize()
                                  for tok in ofname.split('_')])
    return dict(jsfile=args.json_file, outfile=args.output_file,
                title=args.title, classname=args.classname)
    
def main():
    args = cmdline()
    with open(args['jsfile']) as infile:
        json_data = json.load(infile)
    with open(args['outfile'], 'w') as outfile:
        write_rst(json_data, outfile, args['title'], args['classname'])
    return 0
    
if __name__ == '__main__':
    sys.exit(main())