#
# Autogenerated by Thrift Compiler (0.9.2)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:twisted
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
from ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None

from zope.interface import Interface, implements
from twisted.internet import defer
from thrift.transport import TTwisted

class Iface(Interface):
  def get_taxon(token, ref):
    """
    Retrieve the Taxon associated with this GenomeAnnotation.

    @return Reference to TaxonAPI object

    Parameters:
     - token
     - ref
    """
    pass

  def get_assembly(token, ref):
    """
    Retrieve the Assembly associated with this GenomeAnnotation.

    @return Reference to AssemblyAPI object

    Parameters:
     - token
     - ref
    """
    pass

  def get_feature_types(token, ref):
    """
    Retrieve the list of Feature types.

    @return List of feature type identifiers (strings)

    Parameters:
     - token
     - ref
    """
    pass

  def get_feature_type_descriptions(token, ref, feature_type_list):
    """
    Retrieve the descriptions for each Feature type in
    this GenomeAnnotation.

    @param feature_type_list List of Feature types. If this list
     is empty or None,
     the whole mapping will be returned.
    @return Name and description for each requested Feature Type

    Parameters:
     - token
     - ref
     - feature_type_list
    """
    pass

  def get_feature_type_counts(token, ref, feature_type_list):
    """
    Retrieve the count of each Feature type.

    @param feature_type_list  List of Feature Types. If empty,
      this will retrieve  counts for all Feature Types.

    Parameters:
     - token
     - ref
     - feature_type_list
    """
    pass

  def get_feature_ids(token, ref, filters, group_type):
    """
    Retrieve Feature IDs, optionally filtered by type, region, function, alias.

    @param filters Dictionary of filters that can be applied to contents.
      If this is empty or missing, all Feature IDs will be returned.
    @param group_type How to group results, which is a single string matching one
      of the values for the ``filters`` parameter.
    @return Grouped mapping of features.

    Parameters:
     - token
     - ref
     - filters
     - group_type
    """
    pass

  def get_features(token, ref, feature_id_list):
    """
    Retrieve Feature data.

    @param feature_id_list List of Features to retrieve.
      If None, returns all Feature data.
    @return Mapping from Feature IDs to dicts of available data.

    Parameters:
     - token
     - ref
     - feature_id_list
    """
    pass

  def get_proteins(token, ref, cds_id_list):
    """
    Retrieve Protein data.

    @return Mapping from protein ID to data about the protein.

    Parameters:
     - token
     - ref
     - cds_id_list
    """
    pass

  def get_feature_locations(token, ref, feature_id_list):
    """
    Retrieve Feature locations.

    @param feature_id_list List of Feature IDs for which to retrieve locations.
        If empty, returns data for all features.
    @return Mapping from Feature IDs to location information for each.

    Parameters:
     - token
     - ref
     - feature_id_list
    """
    pass

  def get_feature_publications(token, ref, feature_id_list):
    """
    Retrieve Feature publications.

    @param feature_id_list List of Feature IDs for which to retrieve publications.
        If empty, returns data for all features.
    @return Mapping from Feature IDs to publication info for each.

    Parameters:
     - token
     - ref
     - feature_id_list
    """
    pass

  def get_feature_dna(token, ref, feature_id_list):
    """
    Retrieve Feature DNA sequences.

    @param feature_id_list List of Feature IDs for which to retrieve sequences.
        If empty, returns data for all features.
    @return Mapping of Feature IDs to their DNA sequence.

    Parameters:
     - token
     - ref
     - feature_id_list
    """
    pass

  def get_feature_functions(token, ref, feature_id_list):
    """
    Retrieve Feature functions.

    @param feature_id_list List of Feature IDs for which to retrieve functions.
        If empty, returns data for all features.
    @return Mapping of Feature IDs to their functions.

    Parameters:
     - token
     - ref
     - feature_id_list
    """
    pass

  def get_feature_aliases(token, ref, feature_id_list):
    """
    Retrieve Feature aliases.

    @param feature_id_list List of Feature IDS for which to retrieve aliases.
        If empty, returns data for all features.
    @return Mapping of Feature IDs to a list of aliases.

    Parameters:
     - token
     - ref
     - feature_id_list
    """
    pass

  def get_cds_by_gene(token, ref, gene_id_list):
    """
    Retrieves coding sequence Features (cds) for given gene Feature IDs.

    @param feature_id_list List of gene Feature IDS for which to retrieve CDS.
        If empty, returns data for all features.
    @return Mapping of gene Feature IDs to a list of CDS Feature IDs.

    Parameters:
     - token
     - ref
     - gene_id_list
    """
    pass

  def get_cds_by_mrna(token, ref, mrna_id_list):
    """
    Retrieves coding sequence (cds) Feature IDs for given mRNA Feature IDs.

    @param feature_id_list List of mRNA Feature IDS for which to retrieve CDS.
        If empty, returns data for all features.
    @return Mapping of mRNA Feature IDs to a list of CDS Feature IDs.

    Parameters:
     - token
     - ref
     - mrna_id_list
    """
    pass

  def get_gene_by_cds(token, ref, cds_id_list):
    """
    Retrieves gene Feature IDs for given coding sequence (cds) Feature IDs.

    @param feature_id_list List of cds Feature IDS for which to retrieve gene IDs.
        If empty, returns all cds/gene mappings.
    @return Mapping of cds Feature IDs to gene Feature IDs.

    Parameters:
     - token
     - ref
     - cds_id_list
    """
    pass

  def get_gene_by_mrna(token, ref, mrna_id_list):
    """
    Retrieves gene Feature IDs for given mRNA Feature IDs.

    @param feature_id_list List of mRNA Feature IDS for which to retrieve gene IDs.
        If empty, returns all mRNA/gene mappings.
    @return Mapping of mRNA Feature IDs to gene Feature IDs.

    Parameters:
     - token
     - ref
     - mrna_id_list
    """
    pass

  def get_mrna_by_cds(token, ref, cds_id_list):
    """
    Retrieves mRNA Features for given coding sequences (cds) Feature IDs.

    @param feature_id_list List of cds Feature IDS for which to retrieve mRNA IDs.
        If empty, returns all cds/mRNA mappings.
    @return Mapping of cds Feature IDs to mRNA Feature IDs.

    Parameters:
     - token
     - ref
     - cds_id_list
    """
    pass

  def get_mrna_by_gene(token, ref, gene_id_list):
    """
    Retrieve the mRNA IDs for given gene IDs.

    @param feature_id_list List of gene Feature IDS for which to retrieve mRNA IDs.
        If empty, returns all gene/mRNA mappings.
    @return Mapping of gene Feature IDs to a list of mRNA Feature IDs.

    Parameters:
     - token
     - ref
     - gene_id_list
    """
    pass

  def get_mrna_exons(token, ref, mrna_id_list):
    """
    Retrieve Exon information for each mRNA ID.

    @param feature_id_list List of mRNA Feature IDS for which to retrieve exons.
        If empty, returns data for all exons.
    @return Mapping of mRNA Feature IDs to a list of exons (:js:data:`Exon_data`).

    Parameters:
     - token
     - ref
     - mrna_id_list
    """
    pass

  def get_mrna_utrs(token, ref, mrna_id_list):
    """
    Retrieve UTR information for each mRNA Feature ID.

     UTRs are calculated between mRNA features and corresponding CDS features.
     The return value for each mRNA can contain either:
        - no UTRs found (empty dict)
        -  5' UTR only
        -  3' UTR only
        -  5' and 3' UTRs

     Note: The Genome data type does not contain interfeature
     relationship information. Calling this method for Genome objects
     will raise a :js:throws:`exc.TypeException`.

    @param feature_id_list List of mRNA Feature IDS for which to retrieve UTRs.
    If empty, returns data for all UTRs.
    @return Mapping of mRNA Feature IDs to a mapping that contains
    both 5' and 3' UTRs::
        { "5'UTR": :js:data:`UTR_data`, "3'UTR": :js:data:`UTR_data` }

    Parameters:
     - token
     - ref
     - mrna_id_list
    """
    pass

  def get_gff(token, ref, gene_id_list):
    """
    Retrieve a GFF representation of this GenomeAnnotation.

    @param gene_id_list List of gene Feature IDs for which to retrieve GFF.
    If empty, returns GFF data for all genes in this GenomeAnnotation.
    @return GFF data

    Parameters:
     - token
     - ref
     - gene_id_list
    """
    pass


class Client:
  implements(Iface)

  def __init__(self, transport, oprot_factory):
    self._transport = transport
    self._oprot_factory = oprot_factory
    self._seqid = 0
    self._reqs = {}

  def get_taxon(self, token, ref):
    """
    Retrieve the Taxon associated with this GenomeAnnotation.

    @return Reference to TaxonAPI object

    Parameters:
     - token
     - ref
    """
    seqid = self._seqid = self._seqid + 1
    self._reqs[seqid] = defer.Deferred()

    d = defer.maybeDeferred(self.send_get_taxon, token, ref)
    d.addCallbacks(
      callback=self.cb_send_get_taxon,
      callbackArgs=(seqid,),
      errback=self.eb_send_get_taxon,
      errbackArgs=(seqid,))
    return d

  def cb_send_get_taxon(self, _, seqid):
    return self._reqs[seqid]

  def eb_send_get_taxon(self, f, seqid):
    d = self._reqs.pop(seqid)
    d.errback(f)
    return d

  def send_get_taxon(self, token, ref):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('get_taxon', TMessageType.CALL, self._seqid)
    args = get_taxon_args()
    args.token = token
    args.ref = ref
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_get_taxon(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = get_taxon_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    if result.generic_exception is not None:
      return d.errback(result.generic_exception)
    if result.authorization_exception is not None:
      return d.errback(result.authorization_exception)
    if result.authentication_exception is not None:
      return d.errback(result.authentication_exception)
    if result.reference_exception is not None:
      return d.errback(result.reference_exception)
    if result.attribute_exception is not None:
      return d.errback(result.attribute_exception)
    if result.type_exception is not None:
      return d.errback(result.type_exception)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "get_taxon failed: unknown result"))

  def get_assembly(self, token, ref):
    """
    Retrieve the Assembly associated with this GenomeAnnotation.

    @return Reference to AssemblyAPI object

    Parameters:
     - token
     - ref
    """
    seqid = self._seqid = self._seqid + 1
    self._reqs[seqid] = defer.Deferred()

    d = defer.maybeDeferred(self.send_get_assembly, token, ref)
    d.addCallbacks(
      callback=self.cb_send_get_assembly,
      callbackArgs=(seqid,),
      errback=self.eb_send_get_assembly,
      errbackArgs=(seqid,))
    return d

  def cb_send_get_assembly(self, _, seqid):
    return self._reqs[seqid]

  def eb_send_get_assembly(self, f, seqid):
    d = self._reqs.pop(seqid)
    d.errback(f)
    return d

  def send_get_assembly(self, token, ref):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('get_assembly', TMessageType.CALL, self._seqid)
    args = get_assembly_args()
    args.token = token
    args.ref = ref
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_get_assembly(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = get_assembly_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    if result.generic_exception is not None:
      return d.errback(result.generic_exception)
    if result.authorization_exception is not None:
      return d.errback(result.authorization_exception)
    if result.authentication_exception is not None:
      return d.errback(result.authentication_exception)
    if result.reference_exception is not None:
      return d.errback(result.reference_exception)
    if result.attribute_exception is not None:
      return d.errback(result.attribute_exception)
    if result.type_exception is not None:
      return d.errback(result.type_exception)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "get_assembly failed: unknown result"))

  def get_feature_types(self, token, ref):
    """
    Retrieve the list of Feature types.

    @return List of feature type identifiers (strings)

    Parameters:
     - token
     - ref
    """
    seqid = self._seqid = self._seqid + 1
    self._reqs[seqid] = defer.Deferred()

    d = defer.maybeDeferred(self.send_get_feature_types, token, ref)
    d.addCallbacks(
      callback=self.cb_send_get_feature_types,
      callbackArgs=(seqid,),
      errback=self.eb_send_get_feature_types,
      errbackArgs=(seqid,))
    return d

  def cb_send_get_feature_types(self, _, seqid):
    return self._reqs[seqid]

  def eb_send_get_feature_types(self, f, seqid):
    d = self._reqs.pop(seqid)
    d.errback(f)
    return d

  def send_get_feature_types(self, token, ref):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('get_feature_types', TMessageType.CALL, self._seqid)
    args = get_feature_types_args()
    args.token = token
    args.ref = ref
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_get_feature_types(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = get_feature_types_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    if result.generic_exception is not None:
      return d.errback(result.generic_exception)
    if result.authorization_exception is not None:
      return d.errback(result.authorization_exception)
    if result.authentication_exception is not None:
      return d.errback(result.authentication_exception)
    if result.reference_exception is not None:
      return d.errback(result.reference_exception)
    if result.attribute_exception is not None:
      return d.errback(result.attribute_exception)
    if result.type_exception is not None:
      return d.errback(result.type_exception)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "get_feature_types failed: unknown result"))

  def get_feature_type_descriptions(self, token, ref, feature_type_list):
    """
    Retrieve the descriptions for each Feature type in
    this GenomeAnnotation.

    @param feature_type_list List of Feature types. If this list
     is empty or None,
     the whole mapping will be returned.
    @return Name and description for each requested Feature Type

    Parameters:
     - token
     - ref
     - feature_type_list
    """
    seqid = self._seqid = self._seqid + 1
    self._reqs[seqid] = defer.Deferred()

    d = defer.maybeDeferred(self.send_get_feature_type_descriptions, token, ref, feature_type_list)
    d.addCallbacks(
      callback=self.cb_send_get_feature_type_descriptions,
      callbackArgs=(seqid,),
      errback=self.eb_send_get_feature_type_descriptions,
      errbackArgs=(seqid,))
    return d

  def cb_send_get_feature_type_descriptions(self, _, seqid):
    return self._reqs[seqid]

  def eb_send_get_feature_type_descriptions(self, f, seqid):
    d = self._reqs.pop(seqid)
    d.errback(f)
    return d

  def send_get_feature_type_descriptions(self, token, ref, feature_type_list):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('get_feature_type_descriptions', TMessageType.CALL, self._seqid)
    args = get_feature_type_descriptions_args()
    args.token = token
    args.ref = ref
    args.feature_type_list = feature_type_list
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_get_feature_type_descriptions(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = get_feature_type_descriptions_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    if result.generic_exception is not None:
      return d.errback(result.generic_exception)
    if result.authorization_exception is not None:
      return d.errback(result.authorization_exception)
    if result.authentication_exception is not None:
      return d.errback(result.authentication_exception)
    if result.reference_exception is not None:
      return d.errback(result.reference_exception)
    if result.attribute_exception is not None:
      return d.errback(result.attribute_exception)
    if result.type_exception is not None:
      return d.errback(result.type_exception)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "get_feature_type_descriptions failed: unknown result"))

  def get_feature_type_counts(self, token, ref, feature_type_list):
    """
    Retrieve the count of each Feature type.

    @param feature_type_list  List of Feature Types. If empty,
      this will retrieve  counts for all Feature Types.

    Parameters:
     - token
     - ref
     - feature_type_list
    """
    seqid = self._seqid = self._seqid + 1
    self._reqs[seqid] = defer.Deferred()

    d = defer.maybeDeferred(self.send_get_feature_type_counts, token, ref, feature_type_list)
    d.addCallbacks(
      callback=self.cb_send_get_feature_type_counts,
      callbackArgs=(seqid,),
      errback=self.eb_send_get_feature_type_counts,
      errbackArgs=(seqid,))
    return d

  def cb_send_get_feature_type_counts(self, _, seqid):
    return self._reqs[seqid]

  def eb_send_get_feature_type_counts(self, f, seqid):
    d = self._reqs.pop(seqid)
    d.errback(f)
    return d

  def send_get_feature_type_counts(self, token, ref, feature_type_list):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('get_feature_type_counts', TMessageType.CALL, self._seqid)
    args = get_feature_type_counts_args()
    args.token = token
    args.ref = ref
    args.feature_type_list = feature_type_list
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_get_feature_type_counts(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = get_feature_type_counts_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    if result.generic_exception is not None:
      return d.errback(result.generic_exception)
    if result.authorization_exception is not None:
      return d.errback(result.authorization_exception)
    if result.authentication_exception is not None:
      return d.errback(result.authentication_exception)
    if result.reference_exception is not None:
      return d.errback(result.reference_exception)
    if result.attribute_exception is not None:
      return d.errback(result.attribute_exception)
    if result.type_exception is not None:
      return d.errback(result.type_exception)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "get_feature_type_counts failed: unknown result"))

  def get_feature_ids(self, token, ref, filters, group_type):
    """
    Retrieve Feature IDs, optionally filtered by type, region, function, alias.

    @param filters Dictionary of filters that can be applied to contents.
      If this is empty or missing, all Feature IDs will be returned.
    @param group_type How to group results, which is a single string matching one
      of the values for the ``filters`` parameter.
    @return Grouped mapping of features.

    Parameters:
     - token
     - ref
     - filters
     - group_type
    """
    seqid = self._seqid = self._seqid + 1
    self._reqs[seqid] = defer.Deferred()

    d = defer.maybeDeferred(self.send_get_feature_ids, token, ref, filters, group_type)
    d.addCallbacks(
      callback=self.cb_send_get_feature_ids,
      callbackArgs=(seqid,),
      errback=self.eb_send_get_feature_ids,
      errbackArgs=(seqid,))
    return d

  def cb_send_get_feature_ids(self, _, seqid):
    return self._reqs[seqid]

  def eb_send_get_feature_ids(self, f, seqid):
    d = self._reqs.pop(seqid)
    d.errback(f)
    return d

  def send_get_feature_ids(self, token, ref, filters, group_type):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('get_feature_ids', TMessageType.CALL, self._seqid)
    args = get_feature_ids_args()
    args.token = token
    args.ref = ref
    args.filters = filters
    args.group_type = group_type
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_get_feature_ids(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = get_feature_ids_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    if result.generic_exception is not None:
      return d.errback(result.generic_exception)
    if result.authorization_exception is not None:
      return d.errback(result.authorization_exception)
    if result.authentication_exception is not None:
      return d.errback(result.authentication_exception)
    if result.reference_exception is not None:
      return d.errback(result.reference_exception)
    if result.attribute_exception is not None:
      return d.errback(result.attribute_exception)
    if result.type_exception is not None:
      return d.errback(result.type_exception)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "get_feature_ids failed: unknown result"))

  def get_features(self, token, ref, feature_id_list):
    """
    Retrieve Feature data.

    @param feature_id_list List of Features to retrieve.
      If None, returns all Feature data.
    @return Mapping from Feature IDs to dicts of available data.

    Parameters:
     - token
     - ref
     - feature_id_list
    """
    seqid = self._seqid = self._seqid + 1
    self._reqs[seqid] = defer.Deferred()

    d = defer.maybeDeferred(self.send_get_features, token, ref, feature_id_list)
    d.addCallbacks(
      callback=self.cb_send_get_features,
      callbackArgs=(seqid,),
      errback=self.eb_send_get_features,
      errbackArgs=(seqid,))
    return d

  def cb_send_get_features(self, _, seqid):
    return self._reqs[seqid]

  def eb_send_get_features(self, f, seqid):
    d = self._reqs.pop(seqid)
    d.errback(f)
    return d

  def send_get_features(self, token, ref, feature_id_list):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('get_features', TMessageType.CALL, self._seqid)
    args = get_features_args()
    args.token = token
    args.ref = ref
    args.feature_id_list = feature_id_list
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_get_features(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = get_features_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    if result.generic_exception is not None:
      return d.errback(result.generic_exception)
    if result.authorization_exception is not None:
      return d.errback(result.authorization_exception)
    if result.authentication_exception is not None:
      return d.errback(result.authentication_exception)
    if result.reference_exception is not None:
      return d.errback(result.reference_exception)
    if result.attribute_exception is not None:
      return d.errback(result.attribute_exception)
    if result.type_exception is not None:
      return d.errback(result.type_exception)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "get_features failed: unknown result"))

  def get_proteins(self, token, ref, cds_id_list):
    """
    Retrieve Protein data.

    @return Mapping from protein ID to data about the protein.

    Parameters:
     - token
     - ref
     - cds_id_list
    """
    seqid = self._seqid = self._seqid + 1
    self._reqs[seqid] = defer.Deferred()

    d = defer.maybeDeferred(self.send_get_proteins, token, ref, cds_id_list)
    d.addCallbacks(
      callback=self.cb_send_get_proteins,
      callbackArgs=(seqid,),
      errback=self.eb_send_get_proteins,
      errbackArgs=(seqid,))
    return d

  def cb_send_get_proteins(self, _, seqid):
    return self._reqs[seqid]

  def eb_send_get_proteins(self, f, seqid):
    d = self._reqs.pop(seqid)
    d.errback(f)
    return d

  def send_get_proteins(self, token, ref, cds_id_list):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('get_proteins', TMessageType.CALL, self._seqid)
    args = get_proteins_args()
    args.token = token
    args.ref = ref
    args.cds_id_list = cds_id_list
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_get_proteins(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = get_proteins_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    if result.generic_exception is not None:
      return d.errback(result.generic_exception)
    if result.authorization_exception is not None:
      return d.errback(result.authorization_exception)
    if result.authentication_exception is not None:
      return d.errback(result.authentication_exception)
    if result.reference_exception is not None:
      return d.errback(result.reference_exception)
    if result.attribute_exception is not None:
      return d.errback(result.attribute_exception)
    if result.type_exception is not None:
      return d.errback(result.type_exception)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "get_proteins failed: unknown result"))

  def get_feature_locations(self, token, ref, feature_id_list):
    """
    Retrieve Feature locations.

    @param feature_id_list List of Feature IDs for which to retrieve locations.
        If empty, returns data for all features.
    @return Mapping from Feature IDs to location information for each.

    Parameters:
     - token
     - ref
     - feature_id_list
    """
    seqid = self._seqid = self._seqid + 1
    self._reqs[seqid] = defer.Deferred()

    d = defer.maybeDeferred(self.send_get_feature_locations, token, ref, feature_id_list)
    d.addCallbacks(
      callback=self.cb_send_get_feature_locations,
      callbackArgs=(seqid,),
      errback=self.eb_send_get_feature_locations,
      errbackArgs=(seqid,))
    return d

  def cb_send_get_feature_locations(self, _, seqid):
    return self._reqs[seqid]

  def eb_send_get_feature_locations(self, f, seqid):
    d = self._reqs.pop(seqid)
    d.errback(f)
    return d

  def send_get_feature_locations(self, token, ref, feature_id_list):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('get_feature_locations', TMessageType.CALL, self._seqid)
    args = get_feature_locations_args()
    args.token = token
    args.ref = ref
    args.feature_id_list = feature_id_list
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_get_feature_locations(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = get_feature_locations_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    if result.generic_exception is not None:
      return d.errback(result.generic_exception)
    if result.authorization_exception is not None:
      return d.errback(result.authorization_exception)
    if result.authentication_exception is not None:
      return d.errback(result.authentication_exception)
    if result.reference_exception is not None:
      return d.errback(result.reference_exception)
    if result.attribute_exception is not None:
      return d.errback(result.attribute_exception)
    if result.type_exception is not None:
      return d.errback(result.type_exception)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "get_feature_locations failed: unknown result"))

  def get_feature_publications(self, token, ref, feature_id_list):
    """
    Retrieve Feature publications.

    @param feature_id_list List of Feature IDs for which to retrieve publications.
        If empty, returns data for all features.
    @return Mapping from Feature IDs to publication info for each.

    Parameters:
     - token
     - ref
     - feature_id_list
    """
    seqid = self._seqid = self._seqid + 1
    self._reqs[seqid] = defer.Deferred()

    d = defer.maybeDeferred(self.send_get_feature_publications, token, ref, feature_id_list)
    d.addCallbacks(
      callback=self.cb_send_get_feature_publications,
      callbackArgs=(seqid,),
      errback=self.eb_send_get_feature_publications,
      errbackArgs=(seqid,))
    return d

  def cb_send_get_feature_publications(self, _, seqid):
    return self._reqs[seqid]

  def eb_send_get_feature_publications(self, f, seqid):
    d = self._reqs.pop(seqid)
    d.errback(f)
    return d

  def send_get_feature_publications(self, token, ref, feature_id_list):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('get_feature_publications', TMessageType.CALL, self._seqid)
    args = get_feature_publications_args()
    args.token = token
    args.ref = ref
    args.feature_id_list = feature_id_list
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_get_feature_publications(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = get_feature_publications_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    if result.generic_exception is not None:
      return d.errback(result.generic_exception)
    if result.authorization_exception is not None:
      return d.errback(result.authorization_exception)
    if result.authentication_exception is not None:
      return d.errback(result.authentication_exception)
    if result.reference_exception is not None:
      return d.errback(result.reference_exception)
    if result.attribute_exception is not None:
      return d.errback(result.attribute_exception)
    if result.type_exception is not None:
      return d.errback(result.type_exception)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "get_feature_publications failed: unknown result"))

  def get_feature_dna(self, token, ref, feature_id_list):
    """
    Retrieve Feature DNA sequences.

    @param feature_id_list List of Feature IDs for which to retrieve sequences.
        If empty, returns data for all features.
    @return Mapping of Feature IDs to their DNA sequence.

    Parameters:
     - token
     - ref
     - feature_id_list
    """
    seqid = self._seqid = self._seqid + 1
    self._reqs[seqid] = defer.Deferred()

    d = defer.maybeDeferred(self.send_get_feature_dna, token, ref, feature_id_list)
    d.addCallbacks(
      callback=self.cb_send_get_feature_dna,
      callbackArgs=(seqid,),
      errback=self.eb_send_get_feature_dna,
      errbackArgs=(seqid,))
    return d

  def cb_send_get_feature_dna(self, _, seqid):
    return self._reqs[seqid]

  def eb_send_get_feature_dna(self, f, seqid):
    d = self._reqs.pop(seqid)
    d.errback(f)
    return d

  def send_get_feature_dna(self, token, ref, feature_id_list):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('get_feature_dna', TMessageType.CALL, self._seqid)
    args = get_feature_dna_args()
    args.token = token
    args.ref = ref
    args.feature_id_list = feature_id_list
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_get_feature_dna(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = get_feature_dna_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    if result.generic_exception is not None:
      return d.errback(result.generic_exception)
    if result.authorization_exception is not None:
      return d.errback(result.authorization_exception)
    if result.authentication_exception is not None:
      return d.errback(result.authentication_exception)
    if result.reference_exception is not None:
      return d.errback(result.reference_exception)
    if result.attribute_exception is not None:
      return d.errback(result.attribute_exception)
    if result.type_exception is not None:
      return d.errback(result.type_exception)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "get_feature_dna failed: unknown result"))

  def get_feature_functions(self, token, ref, feature_id_list):
    """
    Retrieve Feature functions.

    @param feature_id_list List of Feature IDs for which to retrieve functions.
        If empty, returns data for all features.
    @return Mapping of Feature IDs to their functions.

    Parameters:
     - token
     - ref
     - feature_id_list
    """
    seqid = self._seqid = self._seqid + 1
    self._reqs[seqid] = defer.Deferred()

    d = defer.maybeDeferred(self.send_get_feature_functions, token, ref, feature_id_list)
    d.addCallbacks(
      callback=self.cb_send_get_feature_functions,
      callbackArgs=(seqid,),
      errback=self.eb_send_get_feature_functions,
      errbackArgs=(seqid,))
    return d

  def cb_send_get_feature_functions(self, _, seqid):
    return self._reqs[seqid]

  def eb_send_get_feature_functions(self, f, seqid):
    d = self._reqs.pop(seqid)
    d.errback(f)
    return d

  def send_get_feature_functions(self, token, ref, feature_id_list):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('get_feature_functions', TMessageType.CALL, self._seqid)
    args = get_feature_functions_args()
    args.token = token
    args.ref = ref
    args.feature_id_list = feature_id_list
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_get_feature_functions(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = get_feature_functions_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    if result.generic_exception is not None:
      return d.errback(result.generic_exception)
    if result.authorization_exception is not None:
      return d.errback(result.authorization_exception)
    if result.authentication_exception is not None:
      return d.errback(result.authentication_exception)
    if result.reference_exception is not None:
      return d.errback(result.reference_exception)
    if result.attribute_exception is not None:
      return d.errback(result.attribute_exception)
    if result.type_exception is not None:
      return d.errback(result.type_exception)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "get_feature_functions failed: unknown result"))

  def get_feature_aliases(self, token, ref, feature_id_list):
    """
    Retrieve Feature aliases.

    @param feature_id_list List of Feature IDS for which to retrieve aliases.
        If empty, returns data for all features.
    @return Mapping of Feature IDs to a list of aliases.

    Parameters:
     - token
     - ref
     - feature_id_list
    """
    seqid = self._seqid = self._seqid + 1
    self._reqs[seqid] = defer.Deferred()

    d = defer.maybeDeferred(self.send_get_feature_aliases, token, ref, feature_id_list)
    d.addCallbacks(
      callback=self.cb_send_get_feature_aliases,
      callbackArgs=(seqid,),
      errback=self.eb_send_get_feature_aliases,
      errbackArgs=(seqid,))
    return d

  def cb_send_get_feature_aliases(self, _, seqid):
    return self._reqs[seqid]

  def eb_send_get_feature_aliases(self, f, seqid):
    d = self._reqs.pop(seqid)
    d.errback(f)
    return d

  def send_get_feature_aliases(self, token, ref, feature_id_list):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('get_feature_aliases', TMessageType.CALL, self._seqid)
    args = get_feature_aliases_args()
    args.token = token
    args.ref = ref
    args.feature_id_list = feature_id_list
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_get_feature_aliases(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = get_feature_aliases_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    if result.generic_exception is not None:
      return d.errback(result.generic_exception)
    if result.authorization_exception is not None:
      return d.errback(result.authorization_exception)
    if result.authentication_exception is not None:
      return d.errback(result.authentication_exception)
    if result.reference_exception is not None:
      return d.errback(result.reference_exception)
    if result.attribute_exception is not None:
      return d.errback(result.attribute_exception)
    if result.type_exception is not None:
      return d.errback(result.type_exception)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "get_feature_aliases failed: unknown result"))

  def get_cds_by_gene(self, token, ref, gene_id_list):
    """
    Retrieves coding sequence Features (cds) for given gene Feature IDs.

    @param feature_id_list List of gene Feature IDS for which to retrieve CDS.
        If empty, returns data for all features.
    @return Mapping of gene Feature IDs to a list of CDS Feature IDs.

    Parameters:
     - token
     - ref
     - gene_id_list
    """
    seqid = self._seqid = self._seqid + 1
    self._reqs[seqid] = defer.Deferred()

    d = defer.maybeDeferred(self.send_get_cds_by_gene, token, ref, gene_id_list)
    d.addCallbacks(
      callback=self.cb_send_get_cds_by_gene,
      callbackArgs=(seqid,),
      errback=self.eb_send_get_cds_by_gene,
      errbackArgs=(seqid,))
    return d

  def cb_send_get_cds_by_gene(self, _, seqid):
    return self._reqs[seqid]

  def eb_send_get_cds_by_gene(self, f, seqid):
    d = self._reqs.pop(seqid)
    d.errback(f)
    return d

  def send_get_cds_by_gene(self, token, ref, gene_id_list):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('get_cds_by_gene', TMessageType.CALL, self._seqid)
    args = get_cds_by_gene_args()
    args.token = token
    args.ref = ref
    args.gene_id_list = gene_id_list
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_get_cds_by_gene(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = get_cds_by_gene_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    if result.generic_exception is not None:
      return d.errback(result.generic_exception)
    if result.authorization_exception is not None:
      return d.errback(result.authorization_exception)
    if result.authentication_exception is not None:
      return d.errback(result.authentication_exception)
    if result.reference_exception is not None:
      return d.errback(result.reference_exception)
    if result.attribute_exception is not None:
      return d.errback(result.attribute_exception)
    if result.type_exception is not None:
      return d.errback(result.type_exception)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "get_cds_by_gene failed: unknown result"))

  def get_cds_by_mrna(self, token, ref, mrna_id_list):
    """
    Retrieves coding sequence (cds) Feature IDs for given mRNA Feature IDs.

    @param feature_id_list List of mRNA Feature IDS for which to retrieve CDS.
        If empty, returns data for all features.
    @return Mapping of mRNA Feature IDs to a list of CDS Feature IDs.

    Parameters:
     - token
     - ref
     - mrna_id_list
    """
    seqid = self._seqid = self._seqid + 1
    self._reqs[seqid] = defer.Deferred()

    d = defer.maybeDeferred(self.send_get_cds_by_mrna, token, ref, mrna_id_list)
    d.addCallbacks(
      callback=self.cb_send_get_cds_by_mrna,
      callbackArgs=(seqid,),
      errback=self.eb_send_get_cds_by_mrna,
      errbackArgs=(seqid,))
    return d

  def cb_send_get_cds_by_mrna(self, _, seqid):
    return self._reqs[seqid]

  def eb_send_get_cds_by_mrna(self, f, seqid):
    d = self._reqs.pop(seqid)
    d.errback(f)
    return d

  def send_get_cds_by_mrna(self, token, ref, mrna_id_list):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('get_cds_by_mrna', TMessageType.CALL, self._seqid)
    args = get_cds_by_mrna_args()
    args.token = token
    args.ref = ref
    args.mrna_id_list = mrna_id_list
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_get_cds_by_mrna(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = get_cds_by_mrna_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    if result.generic_exception is not None:
      return d.errback(result.generic_exception)
    if result.authorization_exception is not None:
      return d.errback(result.authorization_exception)
    if result.authentication_exception is not None:
      return d.errback(result.authentication_exception)
    if result.reference_exception is not None:
      return d.errback(result.reference_exception)
    if result.attribute_exception is not None:
      return d.errback(result.attribute_exception)
    if result.type_exception is not None:
      return d.errback(result.type_exception)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "get_cds_by_mrna failed: unknown result"))

  def get_gene_by_cds(self, token, ref, cds_id_list):
    """
    Retrieves gene Feature IDs for given coding sequence (cds) Feature IDs.

    @param feature_id_list List of cds Feature IDS for which to retrieve gene IDs.
        If empty, returns all cds/gene mappings.
    @return Mapping of cds Feature IDs to gene Feature IDs.

    Parameters:
     - token
     - ref
     - cds_id_list
    """
    seqid = self._seqid = self._seqid + 1
    self._reqs[seqid] = defer.Deferred()

    d = defer.maybeDeferred(self.send_get_gene_by_cds, token, ref, cds_id_list)
    d.addCallbacks(
      callback=self.cb_send_get_gene_by_cds,
      callbackArgs=(seqid,),
      errback=self.eb_send_get_gene_by_cds,
      errbackArgs=(seqid,))
    return d

  def cb_send_get_gene_by_cds(self, _, seqid):
    return self._reqs[seqid]

  def eb_send_get_gene_by_cds(self, f, seqid):
    d = self._reqs.pop(seqid)
    d.errback(f)
    return d

  def send_get_gene_by_cds(self, token, ref, cds_id_list):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('get_gene_by_cds', TMessageType.CALL, self._seqid)
    args = get_gene_by_cds_args()
    args.token = token
    args.ref = ref
    args.cds_id_list = cds_id_list
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_get_gene_by_cds(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = get_gene_by_cds_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    if result.generic_exception is not None:
      return d.errback(result.generic_exception)
    if result.authorization_exception is not None:
      return d.errback(result.authorization_exception)
    if result.authentication_exception is not None:
      return d.errback(result.authentication_exception)
    if result.reference_exception is not None:
      return d.errback(result.reference_exception)
    if result.attribute_exception is not None:
      return d.errback(result.attribute_exception)
    if result.type_exception is not None:
      return d.errback(result.type_exception)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "get_gene_by_cds failed: unknown result"))

  def get_gene_by_mrna(self, token, ref, mrna_id_list):
    """
    Retrieves gene Feature IDs for given mRNA Feature IDs.

    @param feature_id_list List of mRNA Feature IDS for which to retrieve gene IDs.
        If empty, returns all mRNA/gene mappings.
    @return Mapping of mRNA Feature IDs to gene Feature IDs.

    Parameters:
     - token
     - ref
     - mrna_id_list
    """
    seqid = self._seqid = self._seqid + 1
    self._reqs[seqid] = defer.Deferred()

    d = defer.maybeDeferred(self.send_get_gene_by_mrna, token, ref, mrna_id_list)
    d.addCallbacks(
      callback=self.cb_send_get_gene_by_mrna,
      callbackArgs=(seqid,),
      errback=self.eb_send_get_gene_by_mrna,
      errbackArgs=(seqid,))
    return d

  def cb_send_get_gene_by_mrna(self, _, seqid):
    return self._reqs[seqid]

  def eb_send_get_gene_by_mrna(self, f, seqid):
    d = self._reqs.pop(seqid)
    d.errback(f)
    return d

  def send_get_gene_by_mrna(self, token, ref, mrna_id_list):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('get_gene_by_mrna', TMessageType.CALL, self._seqid)
    args = get_gene_by_mrna_args()
    args.token = token
    args.ref = ref
    args.mrna_id_list = mrna_id_list
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_get_gene_by_mrna(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = get_gene_by_mrna_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    if result.generic_exception is not None:
      return d.errback(result.generic_exception)
    if result.authorization_exception is not None:
      return d.errback(result.authorization_exception)
    if result.authentication_exception is not None:
      return d.errback(result.authentication_exception)
    if result.reference_exception is not None:
      return d.errback(result.reference_exception)
    if result.attribute_exception is not None:
      return d.errback(result.attribute_exception)
    if result.type_exception is not None:
      return d.errback(result.type_exception)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "get_gene_by_mrna failed: unknown result"))

  def get_mrna_by_cds(self, token, ref, cds_id_list):
    """
    Retrieves mRNA Features for given coding sequences (cds) Feature IDs.

    @param feature_id_list List of cds Feature IDS for which to retrieve mRNA IDs.
        If empty, returns all cds/mRNA mappings.
    @return Mapping of cds Feature IDs to mRNA Feature IDs.

    Parameters:
     - token
     - ref
     - cds_id_list
    """
    seqid = self._seqid = self._seqid + 1
    self._reqs[seqid] = defer.Deferred()

    d = defer.maybeDeferred(self.send_get_mrna_by_cds, token, ref, cds_id_list)
    d.addCallbacks(
      callback=self.cb_send_get_mrna_by_cds,
      callbackArgs=(seqid,),
      errback=self.eb_send_get_mrna_by_cds,
      errbackArgs=(seqid,))
    return d

  def cb_send_get_mrna_by_cds(self, _, seqid):
    return self._reqs[seqid]

  def eb_send_get_mrna_by_cds(self, f, seqid):
    d = self._reqs.pop(seqid)
    d.errback(f)
    return d

  def send_get_mrna_by_cds(self, token, ref, cds_id_list):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('get_mrna_by_cds', TMessageType.CALL, self._seqid)
    args = get_mrna_by_cds_args()
    args.token = token
    args.ref = ref
    args.cds_id_list = cds_id_list
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_get_mrna_by_cds(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = get_mrna_by_cds_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    if result.generic_exception is not None:
      return d.errback(result.generic_exception)
    if result.authorization_exception is not None:
      return d.errback(result.authorization_exception)
    if result.authentication_exception is not None:
      return d.errback(result.authentication_exception)
    if result.reference_exception is not None:
      return d.errback(result.reference_exception)
    if result.attribute_exception is not None:
      return d.errback(result.attribute_exception)
    if result.type_exception is not None:
      return d.errback(result.type_exception)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "get_mrna_by_cds failed: unknown result"))

  def get_mrna_by_gene(self, token, ref, gene_id_list):
    """
    Retrieve the mRNA IDs for given gene IDs.

    @param feature_id_list List of gene Feature IDS for which to retrieve mRNA IDs.
        If empty, returns all gene/mRNA mappings.
    @return Mapping of gene Feature IDs to a list of mRNA Feature IDs.

    Parameters:
     - token
     - ref
     - gene_id_list
    """
    seqid = self._seqid = self._seqid + 1
    self._reqs[seqid] = defer.Deferred()

    d = defer.maybeDeferred(self.send_get_mrna_by_gene, token, ref, gene_id_list)
    d.addCallbacks(
      callback=self.cb_send_get_mrna_by_gene,
      callbackArgs=(seqid,),
      errback=self.eb_send_get_mrna_by_gene,
      errbackArgs=(seqid,))
    return d

  def cb_send_get_mrna_by_gene(self, _, seqid):
    return self._reqs[seqid]

  def eb_send_get_mrna_by_gene(self, f, seqid):
    d = self._reqs.pop(seqid)
    d.errback(f)
    return d

  def send_get_mrna_by_gene(self, token, ref, gene_id_list):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('get_mrna_by_gene', TMessageType.CALL, self._seqid)
    args = get_mrna_by_gene_args()
    args.token = token
    args.ref = ref
    args.gene_id_list = gene_id_list
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_get_mrna_by_gene(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = get_mrna_by_gene_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    if result.generic_exception is not None:
      return d.errback(result.generic_exception)
    if result.authorization_exception is not None:
      return d.errback(result.authorization_exception)
    if result.authentication_exception is not None:
      return d.errback(result.authentication_exception)
    if result.reference_exception is not None:
      return d.errback(result.reference_exception)
    if result.attribute_exception is not None:
      return d.errback(result.attribute_exception)
    if result.type_exception is not None:
      return d.errback(result.type_exception)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "get_mrna_by_gene failed: unknown result"))

  def get_mrna_exons(self, token, ref, mrna_id_list):
    """
    Retrieve Exon information for each mRNA ID.

    @param feature_id_list List of mRNA Feature IDS for which to retrieve exons.
        If empty, returns data for all exons.
    @return Mapping of mRNA Feature IDs to a list of exons (:js:data:`Exon_data`).

    Parameters:
     - token
     - ref
     - mrna_id_list
    """
    seqid = self._seqid = self._seqid + 1
    self._reqs[seqid] = defer.Deferred()

    d = defer.maybeDeferred(self.send_get_mrna_exons, token, ref, mrna_id_list)
    d.addCallbacks(
      callback=self.cb_send_get_mrna_exons,
      callbackArgs=(seqid,),
      errback=self.eb_send_get_mrna_exons,
      errbackArgs=(seqid,))
    return d

  def cb_send_get_mrna_exons(self, _, seqid):
    return self._reqs[seqid]

  def eb_send_get_mrna_exons(self, f, seqid):
    d = self._reqs.pop(seqid)
    d.errback(f)
    return d

  def send_get_mrna_exons(self, token, ref, mrna_id_list):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('get_mrna_exons', TMessageType.CALL, self._seqid)
    args = get_mrna_exons_args()
    args.token = token
    args.ref = ref
    args.mrna_id_list = mrna_id_list
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_get_mrna_exons(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = get_mrna_exons_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    if result.generic_exception is not None:
      return d.errback(result.generic_exception)
    if result.authorization_exception is not None:
      return d.errback(result.authorization_exception)
    if result.authentication_exception is not None:
      return d.errback(result.authentication_exception)
    if result.reference_exception is not None:
      return d.errback(result.reference_exception)
    if result.attribute_exception is not None:
      return d.errback(result.attribute_exception)
    if result.type_exception is not None:
      return d.errback(result.type_exception)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "get_mrna_exons failed: unknown result"))

  def get_mrna_utrs(self, token, ref, mrna_id_list):
    """
    Retrieve UTR information for each mRNA Feature ID.

     UTRs are calculated between mRNA features and corresponding CDS features.
     The return value for each mRNA can contain either:
        - no UTRs found (empty dict)
        -  5' UTR only
        -  3' UTR only
        -  5' and 3' UTRs

     Note: The Genome data type does not contain interfeature
     relationship information. Calling this method for Genome objects
     will raise a :js:throws:`exc.TypeException`.

    @param feature_id_list List of mRNA Feature IDS for which to retrieve UTRs.
    If empty, returns data for all UTRs.
    @return Mapping of mRNA Feature IDs to a mapping that contains
    both 5' and 3' UTRs::
        { "5'UTR": :js:data:`UTR_data`, "3'UTR": :js:data:`UTR_data` }

    Parameters:
     - token
     - ref
     - mrna_id_list
    """
    seqid = self._seqid = self._seqid + 1
    self._reqs[seqid] = defer.Deferred()

    d = defer.maybeDeferred(self.send_get_mrna_utrs, token, ref, mrna_id_list)
    d.addCallbacks(
      callback=self.cb_send_get_mrna_utrs,
      callbackArgs=(seqid,),
      errback=self.eb_send_get_mrna_utrs,
      errbackArgs=(seqid,))
    return d

  def cb_send_get_mrna_utrs(self, _, seqid):
    return self._reqs[seqid]

  def eb_send_get_mrna_utrs(self, f, seqid):
    d = self._reqs.pop(seqid)
    d.errback(f)
    return d

  def send_get_mrna_utrs(self, token, ref, mrna_id_list):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('get_mrna_utrs', TMessageType.CALL, self._seqid)
    args = get_mrna_utrs_args()
    args.token = token
    args.ref = ref
    args.mrna_id_list = mrna_id_list
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_get_mrna_utrs(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = get_mrna_utrs_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    if result.generic_exception is not None:
      return d.errback(result.generic_exception)
    if result.authorization_exception is not None:
      return d.errback(result.authorization_exception)
    if result.authentication_exception is not None:
      return d.errback(result.authentication_exception)
    if result.reference_exception is not None:
      return d.errback(result.reference_exception)
    if result.attribute_exception is not None:
      return d.errback(result.attribute_exception)
    if result.type_exception is not None:
      return d.errback(result.type_exception)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "get_mrna_utrs failed: unknown result"))

  def get_gff(self, token, ref, gene_id_list):
    """
    Retrieve a GFF representation of this GenomeAnnotation.

    @param gene_id_list List of gene Feature IDs for which to retrieve GFF.
    If empty, returns GFF data for all genes in this GenomeAnnotation.
    @return GFF data

    Parameters:
     - token
     - ref
     - gene_id_list
    """
    seqid = self._seqid = self._seqid + 1
    self._reqs[seqid] = defer.Deferred()

    d = defer.maybeDeferred(self.send_get_gff, token, ref, gene_id_list)
    d.addCallbacks(
      callback=self.cb_send_get_gff,
      callbackArgs=(seqid,),
      errback=self.eb_send_get_gff,
      errbackArgs=(seqid,))
    return d

  def cb_send_get_gff(self, _, seqid):
    return self._reqs[seqid]

  def eb_send_get_gff(self, f, seqid):
    d = self._reqs.pop(seqid)
    d.errback(f)
    return d

  def send_get_gff(self, token, ref, gene_id_list):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('get_gff', TMessageType.CALL, self._seqid)
    args = get_gff_args()
    args.token = token
    args.ref = ref
    args.gene_id_list = gene_id_list
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_get_gff(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = get_gff_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    if result.generic_exception is not None:
      return d.errback(result.generic_exception)
    if result.authorization_exception is not None:
      return d.errback(result.authorization_exception)
    if result.authentication_exception is not None:
      return d.errback(result.authentication_exception)
    if result.reference_exception is not None:
      return d.errback(result.reference_exception)
    if result.attribute_exception is not None:
      return d.errback(result.attribute_exception)
    if result.type_exception is not None:
      return d.errback(result.type_exception)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "get_gff failed: unknown result"))


class Processor(TProcessor):
  implements(Iface)

  def __init__(self, handler):
    self._handler = Iface(handler)
    self._processMap = {}
    self._processMap["get_taxon"] = Processor.process_get_taxon
    self._processMap["get_assembly"] = Processor.process_get_assembly
    self._processMap["get_feature_types"] = Processor.process_get_feature_types
    self._processMap["get_feature_type_descriptions"] = Processor.process_get_feature_type_descriptions
    self._processMap["get_feature_type_counts"] = Processor.process_get_feature_type_counts
    self._processMap["get_feature_ids"] = Processor.process_get_feature_ids
    self._processMap["get_features"] = Processor.process_get_features
    self._processMap["get_proteins"] = Processor.process_get_proteins
    self._processMap["get_feature_locations"] = Processor.process_get_feature_locations
    self._processMap["get_feature_publications"] = Processor.process_get_feature_publications
    self._processMap["get_feature_dna"] = Processor.process_get_feature_dna
    self._processMap["get_feature_functions"] = Processor.process_get_feature_functions
    self._processMap["get_feature_aliases"] = Processor.process_get_feature_aliases
    self._processMap["get_cds_by_gene"] = Processor.process_get_cds_by_gene
    self._processMap["get_cds_by_mrna"] = Processor.process_get_cds_by_mrna
    self._processMap["get_gene_by_cds"] = Processor.process_get_gene_by_cds
    self._processMap["get_gene_by_mrna"] = Processor.process_get_gene_by_mrna
    self._processMap["get_mrna_by_cds"] = Processor.process_get_mrna_by_cds
    self._processMap["get_mrna_by_gene"] = Processor.process_get_mrna_by_gene
    self._processMap["get_mrna_exons"] = Processor.process_get_mrna_exons
    self._processMap["get_mrna_utrs"] = Processor.process_get_mrna_utrs
    self._processMap["get_gff"] = Processor.process_get_gff

  def process(self, iprot, oprot):
    (name, type, seqid) = iprot.readMessageBegin()
    if name not in self._processMap:
      iprot.skip(TType.STRUCT)
      iprot.readMessageEnd()
      x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
      oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
      x.write(oprot)
      oprot.writeMessageEnd()
      oprot.trans.flush()
      return defer.succeed(None)
    else:
      return self._processMap[name](self, seqid, iprot, oprot)

  def process_get_taxon(self, seqid, iprot, oprot):
    args = get_taxon_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_taxon_result()
    d = defer.maybeDeferred(self._handler.get_taxon, args.token, args.ref)
    d.addCallback(self.write_results_success_get_taxon, result, seqid, oprot)
    d.addErrback(self.write_results_exception_get_taxon, result, seqid, oprot)
    return d

  def write_results_success_get_taxon(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("get_taxon", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def write_results_exception_get_taxon(self, error, result, seqid, oprot):
    try:
      error.raiseException()
    except ServiceException, generic_exception:
      result.generic_exception = generic_exception
    except AuthorizationException, authorization_exception:
      result.authorization_exception = authorization_exception
    except AuthenticationException, authentication_exception:
      result.authentication_exception = authentication_exception
    except ObjectReferenceException, reference_exception:
      result.reference_exception = reference_exception
    except AttributeException, attribute_exception:
      result.attribute_exception = attribute_exception
    except TypeException, type_exception:
      result.type_exception = type_exception
    oprot.writeMessageBegin("get_taxon", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_assembly(self, seqid, iprot, oprot):
    args = get_assembly_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_assembly_result()
    d = defer.maybeDeferred(self._handler.get_assembly, args.token, args.ref)
    d.addCallback(self.write_results_success_get_assembly, result, seqid, oprot)
    d.addErrback(self.write_results_exception_get_assembly, result, seqid, oprot)
    return d

  def write_results_success_get_assembly(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("get_assembly", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def write_results_exception_get_assembly(self, error, result, seqid, oprot):
    try:
      error.raiseException()
    except ServiceException, generic_exception:
      result.generic_exception = generic_exception
    except AuthorizationException, authorization_exception:
      result.authorization_exception = authorization_exception
    except AuthenticationException, authentication_exception:
      result.authentication_exception = authentication_exception
    except ObjectReferenceException, reference_exception:
      result.reference_exception = reference_exception
    except AttributeException, attribute_exception:
      result.attribute_exception = attribute_exception
    except TypeException, type_exception:
      result.type_exception = type_exception
    oprot.writeMessageBegin("get_assembly", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_feature_types(self, seqid, iprot, oprot):
    args = get_feature_types_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_feature_types_result()
    d = defer.maybeDeferred(self._handler.get_feature_types, args.token, args.ref)
    d.addCallback(self.write_results_success_get_feature_types, result, seqid, oprot)
    d.addErrback(self.write_results_exception_get_feature_types, result, seqid, oprot)
    return d

  def write_results_success_get_feature_types(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("get_feature_types", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def write_results_exception_get_feature_types(self, error, result, seqid, oprot):
    try:
      error.raiseException()
    except ServiceException, generic_exception:
      result.generic_exception = generic_exception
    except AuthorizationException, authorization_exception:
      result.authorization_exception = authorization_exception
    except AuthenticationException, authentication_exception:
      result.authentication_exception = authentication_exception
    except ObjectReferenceException, reference_exception:
      result.reference_exception = reference_exception
    except AttributeException, attribute_exception:
      result.attribute_exception = attribute_exception
    except TypeException, type_exception:
      result.type_exception = type_exception
    oprot.writeMessageBegin("get_feature_types", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_feature_type_descriptions(self, seqid, iprot, oprot):
    args = get_feature_type_descriptions_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_feature_type_descriptions_result()
    d = defer.maybeDeferred(self._handler.get_feature_type_descriptions, args.token, args.ref, args.feature_type_list)
    d.addCallback(self.write_results_success_get_feature_type_descriptions, result, seqid, oprot)
    d.addErrback(self.write_results_exception_get_feature_type_descriptions, result, seqid, oprot)
    return d

  def write_results_success_get_feature_type_descriptions(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("get_feature_type_descriptions", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def write_results_exception_get_feature_type_descriptions(self, error, result, seqid, oprot):
    try:
      error.raiseException()
    except ServiceException, generic_exception:
      result.generic_exception = generic_exception
    except AuthorizationException, authorization_exception:
      result.authorization_exception = authorization_exception
    except AuthenticationException, authentication_exception:
      result.authentication_exception = authentication_exception
    except ObjectReferenceException, reference_exception:
      result.reference_exception = reference_exception
    except AttributeException, attribute_exception:
      result.attribute_exception = attribute_exception
    except TypeException, type_exception:
      result.type_exception = type_exception
    oprot.writeMessageBegin("get_feature_type_descriptions", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_feature_type_counts(self, seqid, iprot, oprot):
    args = get_feature_type_counts_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_feature_type_counts_result()
    d = defer.maybeDeferred(self._handler.get_feature_type_counts, args.token, args.ref, args.feature_type_list)
    d.addCallback(self.write_results_success_get_feature_type_counts, result, seqid, oprot)
    d.addErrback(self.write_results_exception_get_feature_type_counts, result, seqid, oprot)
    return d

  def write_results_success_get_feature_type_counts(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("get_feature_type_counts", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def write_results_exception_get_feature_type_counts(self, error, result, seqid, oprot):
    try:
      error.raiseException()
    except ServiceException, generic_exception:
      result.generic_exception = generic_exception
    except AuthorizationException, authorization_exception:
      result.authorization_exception = authorization_exception
    except AuthenticationException, authentication_exception:
      result.authentication_exception = authentication_exception
    except ObjectReferenceException, reference_exception:
      result.reference_exception = reference_exception
    except AttributeException, attribute_exception:
      result.attribute_exception = attribute_exception
    except TypeException, type_exception:
      result.type_exception = type_exception
    oprot.writeMessageBegin("get_feature_type_counts", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_feature_ids(self, seqid, iprot, oprot):
    args = get_feature_ids_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_feature_ids_result()
    d = defer.maybeDeferred(self._handler.get_feature_ids, args.token, args.ref, args.filters, args.group_type)
    d.addCallback(self.write_results_success_get_feature_ids, result, seqid, oprot)
    d.addErrback(self.write_results_exception_get_feature_ids, result, seqid, oprot)
    return d

  def write_results_success_get_feature_ids(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("get_feature_ids", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def write_results_exception_get_feature_ids(self, error, result, seqid, oprot):
    try:
      error.raiseException()
    except ServiceException, generic_exception:
      result.generic_exception = generic_exception
    except AuthorizationException, authorization_exception:
      result.authorization_exception = authorization_exception
    except AuthenticationException, authentication_exception:
      result.authentication_exception = authentication_exception
    except ObjectReferenceException, reference_exception:
      result.reference_exception = reference_exception
    except AttributeException, attribute_exception:
      result.attribute_exception = attribute_exception
    except TypeException, type_exception:
      result.type_exception = type_exception
    oprot.writeMessageBegin("get_feature_ids", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_features(self, seqid, iprot, oprot):
    args = get_features_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_features_result()
    d = defer.maybeDeferred(self._handler.get_features, args.token, args.ref, args.feature_id_list)
    d.addCallback(self.write_results_success_get_features, result, seqid, oprot)
    d.addErrback(self.write_results_exception_get_features, result, seqid, oprot)
    return d

  def write_results_success_get_features(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("get_features", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def write_results_exception_get_features(self, error, result, seqid, oprot):
    try:
      error.raiseException()
    except ServiceException, generic_exception:
      result.generic_exception = generic_exception
    except AuthorizationException, authorization_exception:
      result.authorization_exception = authorization_exception
    except AuthenticationException, authentication_exception:
      result.authentication_exception = authentication_exception
    except ObjectReferenceException, reference_exception:
      result.reference_exception = reference_exception
    except AttributeException, attribute_exception:
      result.attribute_exception = attribute_exception
    except TypeException, type_exception:
      result.type_exception = type_exception
    oprot.writeMessageBegin("get_features", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_proteins(self, seqid, iprot, oprot):
    args = get_proteins_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_proteins_result()
    d = defer.maybeDeferred(self._handler.get_proteins, args.token, args.ref, args.cds_id_list)
    d.addCallback(self.write_results_success_get_proteins, result, seqid, oprot)
    d.addErrback(self.write_results_exception_get_proteins, result, seqid, oprot)
    return d

  def write_results_success_get_proteins(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("get_proteins", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def write_results_exception_get_proteins(self, error, result, seqid, oprot):
    try:
      error.raiseException()
    except ServiceException, generic_exception:
      result.generic_exception = generic_exception
    except AuthorizationException, authorization_exception:
      result.authorization_exception = authorization_exception
    except AuthenticationException, authentication_exception:
      result.authentication_exception = authentication_exception
    except ObjectReferenceException, reference_exception:
      result.reference_exception = reference_exception
    except AttributeException, attribute_exception:
      result.attribute_exception = attribute_exception
    except TypeException, type_exception:
      result.type_exception = type_exception
    oprot.writeMessageBegin("get_proteins", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_feature_locations(self, seqid, iprot, oprot):
    args = get_feature_locations_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_feature_locations_result()
    d = defer.maybeDeferred(self._handler.get_feature_locations, args.token, args.ref, args.feature_id_list)
    d.addCallback(self.write_results_success_get_feature_locations, result, seqid, oprot)
    d.addErrback(self.write_results_exception_get_feature_locations, result, seqid, oprot)
    return d

  def write_results_success_get_feature_locations(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("get_feature_locations", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def write_results_exception_get_feature_locations(self, error, result, seqid, oprot):
    try:
      error.raiseException()
    except ServiceException, generic_exception:
      result.generic_exception = generic_exception
    except AuthorizationException, authorization_exception:
      result.authorization_exception = authorization_exception
    except AuthenticationException, authentication_exception:
      result.authentication_exception = authentication_exception
    except ObjectReferenceException, reference_exception:
      result.reference_exception = reference_exception
    except AttributeException, attribute_exception:
      result.attribute_exception = attribute_exception
    except TypeException, type_exception:
      result.type_exception = type_exception
    oprot.writeMessageBegin("get_feature_locations", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_feature_publications(self, seqid, iprot, oprot):
    args = get_feature_publications_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_feature_publications_result()
    d = defer.maybeDeferred(self._handler.get_feature_publications, args.token, args.ref, args.feature_id_list)
    d.addCallback(self.write_results_success_get_feature_publications, result, seqid, oprot)
    d.addErrback(self.write_results_exception_get_feature_publications, result, seqid, oprot)
    return d

  def write_results_success_get_feature_publications(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("get_feature_publications", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def write_results_exception_get_feature_publications(self, error, result, seqid, oprot):
    try:
      error.raiseException()
    except ServiceException, generic_exception:
      result.generic_exception = generic_exception
    except AuthorizationException, authorization_exception:
      result.authorization_exception = authorization_exception
    except AuthenticationException, authentication_exception:
      result.authentication_exception = authentication_exception
    except ObjectReferenceException, reference_exception:
      result.reference_exception = reference_exception
    except AttributeException, attribute_exception:
      result.attribute_exception = attribute_exception
    except TypeException, type_exception:
      result.type_exception = type_exception
    oprot.writeMessageBegin("get_feature_publications", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_feature_dna(self, seqid, iprot, oprot):
    args = get_feature_dna_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_feature_dna_result()
    d = defer.maybeDeferred(self._handler.get_feature_dna, args.token, args.ref, args.feature_id_list)
    d.addCallback(self.write_results_success_get_feature_dna, result, seqid, oprot)
    d.addErrback(self.write_results_exception_get_feature_dna, result, seqid, oprot)
    return d

  def write_results_success_get_feature_dna(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("get_feature_dna", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def write_results_exception_get_feature_dna(self, error, result, seqid, oprot):
    try:
      error.raiseException()
    except ServiceException, generic_exception:
      result.generic_exception = generic_exception
    except AuthorizationException, authorization_exception:
      result.authorization_exception = authorization_exception
    except AuthenticationException, authentication_exception:
      result.authentication_exception = authentication_exception
    except ObjectReferenceException, reference_exception:
      result.reference_exception = reference_exception
    except AttributeException, attribute_exception:
      result.attribute_exception = attribute_exception
    except TypeException, type_exception:
      result.type_exception = type_exception
    oprot.writeMessageBegin("get_feature_dna", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_feature_functions(self, seqid, iprot, oprot):
    args = get_feature_functions_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_feature_functions_result()
    d = defer.maybeDeferred(self._handler.get_feature_functions, args.token, args.ref, args.feature_id_list)
    d.addCallback(self.write_results_success_get_feature_functions, result, seqid, oprot)
    d.addErrback(self.write_results_exception_get_feature_functions, result, seqid, oprot)
    return d

  def write_results_success_get_feature_functions(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("get_feature_functions", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def write_results_exception_get_feature_functions(self, error, result, seqid, oprot):
    try:
      error.raiseException()
    except ServiceException, generic_exception:
      result.generic_exception = generic_exception
    except AuthorizationException, authorization_exception:
      result.authorization_exception = authorization_exception
    except AuthenticationException, authentication_exception:
      result.authentication_exception = authentication_exception
    except ObjectReferenceException, reference_exception:
      result.reference_exception = reference_exception
    except AttributeException, attribute_exception:
      result.attribute_exception = attribute_exception
    except TypeException, type_exception:
      result.type_exception = type_exception
    oprot.writeMessageBegin("get_feature_functions", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_feature_aliases(self, seqid, iprot, oprot):
    args = get_feature_aliases_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_feature_aliases_result()
    d = defer.maybeDeferred(self._handler.get_feature_aliases, args.token, args.ref, args.feature_id_list)
    d.addCallback(self.write_results_success_get_feature_aliases, result, seqid, oprot)
    d.addErrback(self.write_results_exception_get_feature_aliases, result, seqid, oprot)
    return d

  def write_results_success_get_feature_aliases(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("get_feature_aliases", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def write_results_exception_get_feature_aliases(self, error, result, seqid, oprot):
    try:
      error.raiseException()
    except ServiceException, generic_exception:
      result.generic_exception = generic_exception
    except AuthorizationException, authorization_exception:
      result.authorization_exception = authorization_exception
    except AuthenticationException, authentication_exception:
      result.authentication_exception = authentication_exception
    except ObjectReferenceException, reference_exception:
      result.reference_exception = reference_exception
    except AttributeException, attribute_exception:
      result.attribute_exception = attribute_exception
    except TypeException, type_exception:
      result.type_exception = type_exception
    oprot.writeMessageBegin("get_feature_aliases", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_cds_by_gene(self, seqid, iprot, oprot):
    args = get_cds_by_gene_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_cds_by_gene_result()
    d = defer.maybeDeferred(self._handler.get_cds_by_gene, args.token, args.ref, args.gene_id_list)
    d.addCallback(self.write_results_success_get_cds_by_gene, result, seqid, oprot)
    d.addErrback(self.write_results_exception_get_cds_by_gene, result, seqid, oprot)
    return d

  def write_results_success_get_cds_by_gene(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("get_cds_by_gene", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def write_results_exception_get_cds_by_gene(self, error, result, seqid, oprot):
    try:
      error.raiseException()
    except ServiceException, generic_exception:
      result.generic_exception = generic_exception
    except AuthorizationException, authorization_exception:
      result.authorization_exception = authorization_exception
    except AuthenticationException, authentication_exception:
      result.authentication_exception = authentication_exception
    except ObjectReferenceException, reference_exception:
      result.reference_exception = reference_exception
    except AttributeException, attribute_exception:
      result.attribute_exception = attribute_exception
    except TypeException, type_exception:
      result.type_exception = type_exception
    oprot.writeMessageBegin("get_cds_by_gene", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_cds_by_mrna(self, seqid, iprot, oprot):
    args = get_cds_by_mrna_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_cds_by_mrna_result()
    d = defer.maybeDeferred(self._handler.get_cds_by_mrna, args.token, args.ref, args.mrna_id_list)
    d.addCallback(self.write_results_success_get_cds_by_mrna, result, seqid, oprot)
    d.addErrback(self.write_results_exception_get_cds_by_mrna, result, seqid, oprot)
    return d

  def write_results_success_get_cds_by_mrna(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("get_cds_by_mrna", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def write_results_exception_get_cds_by_mrna(self, error, result, seqid, oprot):
    try:
      error.raiseException()
    except ServiceException, generic_exception:
      result.generic_exception = generic_exception
    except AuthorizationException, authorization_exception:
      result.authorization_exception = authorization_exception
    except AuthenticationException, authentication_exception:
      result.authentication_exception = authentication_exception
    except ObjectReferenceException, reference_exception:
      result.reference_exception = reference_exception
    except AttributeException, attribute_exception:
      result.attribute_exception = attribute_exception
    except TypeException, type_exception:
      result.type_exception = type_exception
    oprot.writeMessageBegin("get_cds_by_mrna", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_gene_by_cds(self, seqid, iprot, oprot):
    args = get_gene_by_cds_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_gene_by_cds_result()
    d = defer.maybeDeferred(self._handler.get_gene_by_cds, args.token, args.ref, args.cds_id_list)
    d.addCallback(self.write_results_success_get_gene_by_cds, result, seqid, oprot)
    d.addErrback(self.write_results_exception_get_gene_by_cds, result, seqid, oprot)
    return d

  def write_results_success_get_gene_by_cds(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("get_gene_by_cds", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def write_results_exception_get_gene_by_cds(self, error, result, seqid, oprot):
    try:
      error.raiseException()
    except ServiceException, generic_exception:
      result.generic_exception = generic_exception
    except AuthorizationException, authorization_exception:
      result.authorization_exception = authorization_exception
    except AuthenticationException, authentication_exception:
      result.authentication_exception = authentication_exception
    except ObjectReferenceException, reference_exception:
      result.reference_exception = reference_exception
    except AttributeException, attribute_exception:
      result.attribute_exception = attribute_exception
    except TypeException, type_exception:
      result.type_exception = type_exception
    oprot.writeMessageBegin("get_gene_by_cds", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_gene_by_mrna(self, seqid, iprot, oprot):
    args = get_gene_by_mrna_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_gene_by_mrna_result()
    d = defer.maybeDeferred(self._handler.get_gene_by_mrna, args.token, args.ref, args.mrna_id_list)
    d.addCallback(self.write_results_success_get_gene_by_mrna, result, seqid, oprot)
    d.addErrback(self.write_results_exception_get_gene_by_mrna, result, seqid, oprot)
    return d

  def write_results_success_get_gene_by_mrna(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("get_gene_by_mrna", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def write_results_exception_get_gene_by_mrna(self, error, result, seqid, oprot):
    try:
      error.raiseException()
    except ServiceException, generic_exception:
      result.generic_exception = generic_exception
    except AuthorizationException, authorization_exception:
      result.authorization_exception = authorization_exception
    except AuthenticationException, authentication_exception:
      result.authentication_exception = authentication_exception
    except ObjectReferenceException, reference_exception:
      result.reference_exception = reference_exception
    except AttributeException, attribute_exception:
      result.attribute_exception = attribute_exception
    except TypeException, type_exception:
      result.type_exception = type_exception
    oprot.writeMessageBegin("get_gene_by_mrna", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_mrna_by_cds(self, seqid, iprot, oprot):
    args = get_mrna_by_cds_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_mrna_by_cds_result()
    d = defer.maybeDeferred(self._handler.get_mrna_by_cds, args.token, args.ref, args.cds_id_list)
    d.addCallback(self.write_results_success_get_mrna_by_cds, result, seqid, oprot)
    d.addErrback(self.write_results_exception_get_mrna_by_cds, result, seqid, oprot)
    return d

  def write_results_success_get_mrna_by_cds(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("get_mrna_by_cds", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def write_results_exception_get_mrna_by_cds(self, error, result, seqid, oprot):
    try:
      error.raiseException()
    except ServiceException, generic_exception:
      result.generic_exception = generic_exception
    except AuthorizationException, authorization_exception:
      result.authorization_exception = authorization_exception
    except AuthenticationException, authentication_exception:
      result.authentication_exception = authentication_exception
    except ObjectReferenceException, reference_exception:
      result.reference_exception = reference_exception
    except AttributeException, attribute_exception:
      result.attribute_exception = attribute_exception
    except TypeException, type_exception:
      result.type_exception = type_exception
    oprot.writeMessageBegin("get_mrna_by_cds", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_mrna_by_gene(self, seqid, iprot, oprot):
    args = get_mrna_by_gene_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_mrna_by_gene_result()
    d = defer.maybeDeferred(self._handler.get_mrna_by_gene, args.token, args.ref, args.gene_id_list)
    d.addCallback(self.write_results_success_get_mrna_by_gene, result, seqid, oprot)
    d.addErrback(self.write_results_exception_get_mrna_by_gene, result, seqid, oprot)
    return d

  def write_results_success_get_mrna_by_gene(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("get_mrna_by_gene", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def write_results_exception_get_mrna_by_gene(self, error, result, seqid, oprot):
    try:
      error.raiseException()
    except ServiceException, generic_exception:
      result.generic_exception = generic_exception
    except AuthorizationException, authorization_exception:
      result.authorization_exception = authorization_exception
    except AuthenticationException, authentication_exception:
      result.authentication_exception = authentication_exception
    except ObjectReferenceException, reference_exception:
      result.reference_exception = reference_exception
    except AttributeException, attribute_exception:
      result.attribute_exception = attribute_exception
    except TypeException, type_exception:
      result.type_exception = type_exception
    oprot.writeMessageBegin("get_mrna_by_gene", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_mrna_exons(self, seqid, iprot, oprot):
    args = get_mrna_exons_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_mrna_exons_result()
    d = defer.maybeDeferred(self._handler.get_mrna_exons, args.token, args.ref, args.mrna_id_list)
    d.addCallback(self.write_results_success_get_mrna_exons, result, seqid, oprot)
    d.addErrback(self.write_results_exception_get_mrna_exons, result, seqid, oprot)
    return d

  def write_results_success_get_mrna_exons(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("get_mrna_exons", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def write_results_exception_get_mrna_exons(self, error, result, seqid, oprot):
    try:
      error.raiseException()
    except ServiceException, generic_exception:
      result.generic_exception = generic_exception
    except AuthorizationException, authorization_exception:
      result.authorization_exception = authorization_exception
    except AuthenticationException, authentication_exception:
      result.authentication_exception = authentication_exception
    except ObjectReferenceException, reference_exception:
      result.reference_exception = reference_exception
    except AttributeException, attribute_exception:
      result.attribute_exception = attribute_exception
    except TypeException, type_exception:
      result.type_exception = type_exception
    oprot.writeMessageBegin("get_mrna_exons", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_mrna_utrs(self, seqid, iprot, oprot):
    args = get_mrna_utrs_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_mrna_utrs_result()
    d = defer.maybeDeferred(self._handler.get_mrna_utrs, args.token, args.ref, args.mrna_id_list)
    d.addCallback(self.write_results_success_get_mrna_utrs, result, seqid, oprot)
    d.addErrback(self.write_results_exception_get_mrna_utrs, result, seqid, oprot)
    return d

  def write_results_success_get_mrna_utrs(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("get_mrna_utrs", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def write_results_exception_get_mrna_utrs(self, error, result, seqid, oprot):
    try:
      error.raiseException()
    except ServiceException, generic_exception:
      result.generic_exception = generic_exception
    except AuthorizationException, authorization_exception:
      result.authorization_exception = authorization_exception
    except AuthenticationException, authentication_exception:
      result.authentication_exception = authentication_exception
    except ObjectReferenceException, reference_exception:
      result.reference_exception = reference_exception
    except AttributeException, attribute_exception:
      result.attribute_exception = attribute_exception
    except TypeException, type_exception:
      result.type_exception = type_exception
    oprot.writeMessageBegin("get_mrna_utrs", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_gff(self, seqid, iprot, oprot):
    args = get_gff_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_gff_result()
    d = defer.maybeDeferred(self._handler.get_gff, args.token, args.ref, args.gene_id_list)
    d.addCallback(self.write_results_success_get_gff, result, seqid, oprot)
    d.addErrback(self.write_results_exception_get_gff, result, seqid, oprot)
    return d

  def write_results_success_get_gff(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("get_gff", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def write_results_exception_get_gff(self, error, result, seqid, oprot):
    try:
      error.raiseException()
    except ServiceException, generic_exception:
      result.generic_exception = generic_exception
    except AuthorizationException, authorization_exception:
      result.authorization_exception = authorization_exception
    except AuthenticationException, authentication_exception:
      result.authentication_exception = authentication_exception
    except ObjectReferenceException, reference_exception:
      result.reference_exception = reference_exception
    except AttributeException, attribute_exception:
      result.attribute_exception = attribute_exception
    except TypeException, type_exception:
      result.type_exception = type_exception
    oprot.writeMessageBegin("get_gff", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()


# HELPER FUNCTIONS AND STRUCTURES

class get_taxon_args:
  """
  Attributes:
   - token
   - ref
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token', None, None, ), # 1
    (2, TType.STRING, 'ref', None, None, ), # 2
  )

  def __init__(self, token=None, ref=None,):
    self.token = token
    self.ref = ref

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ref = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_taxon_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 1)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    if self.ref is not None:
      oprot.writeFieldBegin('ref', TType.STRING, 2)
      oprot.writeString(self.ref)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.token is None:
      raise TProtocol.TProtocolException(message='Required field token is unset!')
    if self.ref is None:
      raise TProtocol.TProtocolException(message='Required field ref is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.token)
    value = (value * 31) ^ hash(self.ref)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_taxon_result:
  """
  Attributes:
   - success
   - generic_exception
   - authorization_exception
   - authentication_exception
   - reference_exception
   - attribute_exception
   - type_exception
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'generic_exception', (ServiceException, ServiceException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'authorization_exception', (AuthorizationException, AuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'authentication_exception', (AuthenticationException, AuthenticationException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'reference_exception', (ObjectReferenceException, ObjectReferenceException.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'attribute_exception', (AttributeException, AttributeException.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'type_exception', (TypeException, TypeException.thrift_spec), None, ), # 6
  )

  def __init__(self, success=None, generic_exception=None, authorization_exception=None, authentication_exception=None, reference_exception=None, attribute_exception=None, type_exception=None,):
    self.success = success
    self.generic_exception = generic_exception
    self.authorization_exception = authorization_exception
    self.authentication_exception = authentication_exception
    self.reference_exception = reference_exception
    self.attribute_exception = attribute_exception
    self.type_exception = type_exception

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_exception = ServiceException()
          self.generic_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.authorization_exception = AuthorizationException()
          self.authorization_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.authentication_exception = AuthenticationException()
          self.authentication_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.reference_exception = ObjectReferenceException()
          self.reference_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.attribute_exception = AttributeException()
          self.attribute_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.type_exception = TypeException()
          self.type_exception.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_taxon_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.generic_exception is not None:
      oprot.writeFieldBegin('generic_exception', TType.STRUCT, 1)
      self.generic_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authorization_exception is not None:
      oprot.writeFieldBegin('authorization_exception', TType.STRUCT, 2)
      self.authorization_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authentication_exception is not None:
      oprot.writeFieldBegin('authentication_exception', TType.STRUCT, 3)
      self.authentication_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.reference_exception is not None:
      oprot.writeFieldBegin('reference_exception', TType.STRUCT, 4)
      self.reference_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.attribute_exception is not None:
      oprot.writeFieldBegin('attribute_exception', TType.STRUCT, 5)
      self.attribute_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.type_exception is not None:
      oprot.writeFieldBegin('type_exception', TType.STRUCT, 6)
      self.type_exception.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.generic_exception)
    value = (value * 31) ^ hash(self.authorization_exception)
    value = (value * 31) ^ hash(self.authentication_exception)
    value = (value * 31) ^ hash(self.reference_exception)
    value = (value * 31) ^ hash(self.attribute_exception)
    value = (value * 31) ^ hash(self.type_exception)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_assembly_args:
  """
  Attributes:
   - token
   - ref
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token', None, None, ), # 1
    (2, TType.STRING, 'ref', None, None, ), # 2
  )

  def __init__(self, token=None, ref=None,):
    self.token = token
    self.ref = ref

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ref = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_assembly_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 1)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    if self.ref is not None:
      oprot.writeFieldBegin('ref', TType.STRING, 2)
      oprot.writeString(self.ref)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.token is None:
      raise TProtocol.TProtocolException(message='Required field token is unset!')
    if self.ref is None:
      raise TProtocol.TProtocolException(message='Required field ref is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.token)
    value = (value * 31) ^ hash(self.ref)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_assembly_result:
  """
  Attributes:
   - success
   - generic_exception
   - authorization_exception
   - authentication_exception
   - reference_exception
   - attribute_exception
   - type_exception
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'generic_exception', (ServiceException, ServiceException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'authorization_exception', (AuthorizationException, AuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'authentication_exception', (AuthenticationException, AuthenticationException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'reference_exception', (ObjectReferenceException, ObjectReferenceException.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'attribute_exception', (AttributeException, AttributeException.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'type_exception', (TypeException, TypeException.thrift_spec), None, ), # 6
  )

  def __init__(self, success=None, generic_exception=None, authorization_exception=None, authentication_exception=None, reference_exception=None, attribute_exception=None, type_exception=None,):
    self.success = success
    self.generic_exception = generic_exception
    self.authorization_exception = authorization_exception
    self.authentication_exception = authentication_exception
    self.reference_exception = reference_exception
    self.attribute_exception = attribute_exception
    self.type_exception = type_exception

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_exception = ServiceException()
          self.generic_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.authorization_exception = AuthorizationException()
          self.authorization_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.authentication_exception = AuthenticationException()
          self.authentication_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.reference_exception = ObjectReferenceException()
          self.reference_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.attribute_exception = AttributeException()
          self.attribute_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.type_exception = TypeException()
          self.type_exception.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_assembly_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.generic_exception is not None:
      oprot.writeFieldBegin('generic_exception', TType.STRUCT, 1)
      self.generic_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authorization_exception is not None:
      oprot.writeFieldBegin('authorization_exception', TType.STRUCT, 2)
      self.authorization_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authentication_exception is not None:
      oprot.writeFieldBegin('authentication_exception', TType.STRUCT, 3)
      self.authentication_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.reference_exception is not None:
      oprot.writeFieldBegin('reference_exception', TType.STRUCT, 4)
      self.reference_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.attribute_exception is not None:
      oprot.writeFieldBegin('attribute_exception', TType.STRUCT, 5)
      self.attribute_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.type_exception is not None:
      oprot.writeFieldBegin('type_exception', TType.STRUCT, 6)
      self.type_exception.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.generic_exception)
    value = (value * 31) ^ hash(self.authorization_exception)
    value = (value * 31) ^ hash(self.authentication_exception)
    value = (value * 31) ^ hash(self.reference_exception)
    value = (value * 31) ^ hash(self.attribute_exception)
    value = (value * 31) ^ hash(self.type_exception)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_feature_types_args:
  """
  Attributes:
   - token
   - ref
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token', None, None, ), # 1
    (2, TType.STRING, 'ref', None, None, ), # 2
  )

  def __init__(self, token=None, ref=None,):
    self.token = token
    self.ref = ref

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ref = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_feature_types_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 1)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    if self.ref is not None:
      oprot.writeFieldBegin('ref', TType.STRING, 2)
      oprot.writeString(self.ref)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.token is None:
      raise TProtocol.TProtocolException(message='Required field token is unset!')
    if self.ref is None:
      raise TProtocol.TProtocolException(message='Required field ref is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.token)
    value = (value * 31) ^ hash(self.ref)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_feature_types_result:
  """
  Attributes:
   - success
   - generic_exception
   - authorization_exception
   - authentication_exception
   - reference_exception
   - attribute_exception
   - type_exception
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'generic_exception', (ServiceException, ServiceException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'authorization_exception', (AuthorizationException, AuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'authentication_exception', (AuthenticationException, AuthenticationException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'reference_exception', (ObjectReferenceException, ObjectReferenceException.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'attribute_exception', (AttributeException, AttributeException.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'type_exception', (TypeException, TypeException.thrift_spec), None, ), # 6
  )

  def __init__(self, success=None, generic_exception=None, authorization_exception=None, authentication_exception=None, reference_exception=None, attribute_exception=None, type_exception=None,):
    self.success = success
    self.generic_exception = generic_exception
    self.authorization_exception = authorization_exception
    self.authentication_exception = authentication_exception
    self.reference_exception = reference_exception
    self.attribute_exception = attribute_exception
    self.type_exception = type_exception

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype194, _size191) = iprot.readListBegin()
          for _i195 in xrange(_size191):
            _elem196 = iprot.readString();
            self.success.append(_elem196)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_exception = ServiceException()
          self.generic_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.authorization_exception = AuthorizationException()
          self.authorization_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.authentication_exception = AuthenticationException()
          self.authentication_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.reference_exception = ObjectReferenceException()
          self.reference_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.attribute_exception = AttributeException()
          self.attribute_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.type_exception = TypeException()
          self.type_exception.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_feature_types_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter197 in self.success:
        oprot.writeString(iter197)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.generic_exception is not None:
      oprot.writeFieldBegin('generic_exception', TType.STRUCT, 1)
      self.generic_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authorization_exception is not None:
      oprot.writeFieldBegin('authorization_exception', TType.STRUCT, 2)
      self.authorization_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authentication_exception is not None:
      oprot.writeFieldBegin('authentication_exception', TType.STRUCT, 3)
      self.authentication_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.reference_exception is not None:
      oprot.writeFieldBegin('reference_exception', TType.STRUCT, 4)
      self.reference_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.attribute_exception is not None:
      oprot.writeFieldBegin('attribute_exception', TType.STRUCT, 5)
      self.attribute_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.type_exception is not None:
      oprot.writeFieldBegin('type_exception', TType.STRUCT, 6)
      self.type_exception.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.generic_exception)
    value = (value * 31) ^ hash(self.authorization_exception)
    value = (value * 31) ^ hash(self.authentication_exception)
    value = (value * 31) ^ hash(self.reference_exception)
    value = (value * 31) ^ hash(self.attribute_exception)
    value = (value * 31) ^ hash(self.type_exception)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_feature_type_descriptions_args:
  """
  Attributes:
   - token
   - ref
   - feature_type_list
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token', None, None, ), # 1
    (2, TType.STRING, 'ref', None, None, ), # 2
    (3, TType.LIST, 'feature_type_list', (TType.STRING,None), None, ), # 3
  )

  def __init__(self, token=None, ref=None, feature_type_list=None,):
    self.token = token
    self.ref = ref
    self.feature_type_list = feature_type_list

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ref = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.feature_type_list = []
          (_etype201, _size198) = iprot.readListBegin()
          for _i202 in xrange(_size198):
            _elem203 = iprot.readString();
            self.feature_type_list.append(_elem203)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_feature_type_descriptions_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 1)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    if self.ref is not None:
      oprot.writeFieldBegin('ref', TType.STRING, 2)
      oprot.writeString(self.ref)
      oprot.writeFieldEnd()
    if self.feature_type_list is not None:
      oprot.writeFieldBegin('feature_type_list', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.feature_type_list))
      for iter204 in self.feature_type_list:
        oprot.writeString(iter204)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.token is None:
      raise TProtocol.TProtocolException(message='Required field token is unset!')
    if self.ref is None:
      raise TProtocol.TProtocolException(message='Required field ref is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.token)
    value = (value * 31) ^ hash(self.ref)
    value = (value * 31) ^ hash(self.feature_type_list)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_feature_type_descriptions_result:
  """
  Attributes:
   - success
   - generic_exception
   - authorization_exception
   - authentication_exception
   - reference_exception
   - attribute_exception
   - type_exception
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'generic_exception', (ServiceException, ServiceException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'authorization_exception', (AuthorizationException, AuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'authentication_exception', (AuthenticationException, AuthenticationException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'reference_exception', (ObjectReferenceException, ObjectReferenceException.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'attribute_exception', (AttributeException, AttributeException.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'type_exception', (TypeException, TypeException.thrift_spec), None, ), # 6
  )

  def __init__(self, success=None, generic_exception=None, authorization_exception=None, authentication_exception=None, reference_exception=None, attribute_exception=None, type_exception=None,):
    self.success = success
    self.generic_exception = generic_exception
    self.authorization_exception = authorization_exception
    self.authentication_exception = authentication_exception
    self.reference_exception = reference_exception
    self.attribute_exception = attribute_exception
    self.type_exception = type_exception

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype206, _vtype207, _size205 ) = iprot.readMapBegin()
          for _i209 in xrange(_size205):
            _key210 = iprot.readString();
            _val211 = iprot.readString();
            self.success[_key210] = _val211
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_exception = ServiceException()
          self.generic_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.authorization_exception = AuthorizationException()
          self.authorization_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.authentication_exception = AuthenticationException()
          self.authentication_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.reference_exception = ObjectReferenceException()
          self.reference_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.attribute_exception = AttributeException()
          self.attribute_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.type_exception = TypeException()
          self.type_exception.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_feature_type_descriptions_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
      for kiter212,viter213 in self.success.items():
        oprot.writeString(kiter212)
        oprot.writeString(viter213)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.generic_exception is not None:
      oprot.writeFieldBegin('generic_exception', TType.STRUCT, 1)
      self.generic_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authorization_exception is not None:
      oprot.writeFieldBegin('authorization_exception', TType.STRUCT, 2)
      self.authorization_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authentication_exception is not None:
      oprot.writeFieldBegin('authentication_exception', TType.STRUCT, 3)
      self.authentication_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.reference_exception is not None:
      oprot.writeFieldBegin('reference_exception', TType.STRUCT, 4)
      self.reference_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.attribute_exception is not None:
      oprot.writeFieldBegin('attribute_exception', TType.STRUCT, 5)
      self.attribute_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.type_exception is not None:
      oprot.writeFieldBegin('type_exception', TType.STRUCT, 6)
      self.type_exception.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.generic_exception)
    value = (value * 31) ^ hash(self.authorization_exception)
    value = (value * 31) ^ hash(self.authentication_exception)
    value = (value * 31) ^ hash(self.reference_exception)
    value = (value * 31) ^ hash(self.attribute_exception)
    value = (value * 31) ^ hash(self.type_exception)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_feature_type_counts_args:
  """
  Attributes:
   - token
   - ref
   - feature_type_list
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token', None, None, ), # 1
    (2, TType.STRING, 'ref', None, None, ), # 2
    (3, TType.LIST, 'feature_type_list', (TType.STRING,None), None, ), # 3
  )

  def __init__(self, token=None, ref=None, feature_type_list=None,):
    self.token = token
    self.ref = ref
    self.feature_type_list = feature_type_list

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ref = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.feature_type_list = []
          (_etype217, _size214) = iprot.readListBegin()
          for _i218 in xrange(_size214):
            _elem219 = iprot.readString();
            self.feature_type_list.append(_elem219)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_feature_type_counts_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 1)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    if self.ref is not None:
      oprot.writeFieldBegin('ref', TType.STRING, 2)
      oprot.writeString(self.ref)
      oprot.writeFieldEnd()
    if self.feature_type_list is not None:
      oprot.writeFieldBegin('feature_type_list', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.feature_type_list))
      for iter220 in self.feature_type_list:
        oprot.writeString(iter220)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.token is None:
      raise TProtocol.TProtocolException(message='Required field token is unset!')
    if self.ref is None:
      raise TProtocol.TProtocolException(message='Required field ref is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.token)
    value = (value * 31) ^ hash(self.ref)
    value = (value * 31) ^ hash(self.feature_type_list)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_feature_type_counts_result:
  """
  Attributes:
   - success
   - generic_exception
   - authorization_exception
   - authentication_exception
   - reference_exception
   - attribute_exception
   - type_exception
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.I64,None), None, ), # 0
    (1, TType.STRUCT, 'generic_exception', (ServiceException, ServiceException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'authorization_exception', (AuthorizationException, AuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'authentication_exception', (AuthenticationException, AuthenticationException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'reference_exception', (ObjectReferenceException, ObjectReferenceException.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'attribute_exception', (AttributeException, AttributeException.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'type_exception', (TypeException, TypeException.thrift_spec), None, ), # 6
  )

  def __init__(self, success=None, generic_exception=None, authorization_exception=None, authentication_exception=None, reference_exception=None, attribute_exception=None, type_exception=None,):
    self.success = success
    self.generic_exception = generic_exception
    self.authorization_exception = authorization_exception
    self.authentication_exception = authentication_exception
    self.reference_exception = reference_exception
    self.attribute_exception = attribute_exception
    self.type_exception = type_exception

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype222, _vtype223, _size221 ) = iprot.readMapBegin()
          for _i225 in xrange(_size221):
            _key226 = iprot.readString();
            _val227 = iprot.readI64();
            self.success[_key226] = _val227
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_exception = ServiceException()
          self.generic_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.authorization_exception = AuthorizationException()
          self.authorization_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.authentication_exception = AuthenticationException()
          self.authentication_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.reference_exception = ObjectReferenceException()
          self.reference_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.attribute_exception = AttributeException()
          self.attribute_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.type_exception = TypeException()
          self.type_exception.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_feature_type_counts_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.I64, len(self.success))
      for kiter228,viter229 in self.success.items():
        oprot.writeString(kiter228)
        oprot.writeI64(viter229)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.generic_exception is not None:
      oprot.writeFieldBegin('generic_exception', TType.STRUCT, 1)
      self.generic_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authorization_exception is not None:
      oprot.writeFieldBegin('authorization_exception', TType.STRUCT, 2)
      self.authorization_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authentication_exception is not None:
      oprot.writeFieldBegin('authentication_exception', TType.STRUCT, 3)
      self.authentication_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.reference_exception is not None:
      oprot.writeFieldBegin('reference_exception', TType.STRUCT, 4)
      self.reference_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.attribute_exception is not None:
      oprot.writeFieldBegin('attribute_exception', TType.STRUCT, 5)
      self.attribute_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.type_exception is not None:
      oprot.writeFieldBegin('type_exception', TType.STRUCT, 6)
      self.type_exception.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.generic_exception)
    value = (value * 31) ^ hash(self.authorization_exception)
    value = (value * 31) ^ hash(self.authentication_exception)
    value = (value * 31) ^ hash(self.reference_exception)
    value = (value * 31) ^ hash(self.attribute_exception)
    value = (value * 31) ^ hash(self.type_exception)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_feature_ids_args:
  """
  Attributes:
   - token
   - ref
   - filters
   - group_type
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token', None, None, ), # 1
    (2, TType.STRING, 'ref', None, None, ), # 2
    (3, TType.STRUCT, 'filters', (Feature_id_filters, Feature_id_filters.thrift_spec), None, ), # 3
    (4, TType.STRING, 'group_type', None, None, ), # 4
  )

  def __init__(self, token=None, ref=None, filters=None, group_type=None,):
    self.token = token
    self.ref = ref
    self.filters = filters
    self.group_type = group_type

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ref = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.filters = Feature_id_filters()
          self.filters.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.group_type = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_feature_ids_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 1)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    if self.ref is not None:
      oprot.writeFieldBegin('ref', TType.STRING, 2)
      oprot.writeString(self.ref)
      oprot.writeFieldEnd()
    if self.filters is not None:
      oprot.writeFieldBegin('filters', TType.STRUCT, 3)
      self.filters.write(oprot)
      oprot.writeFieldEnd()
    if self.group_type is not None:
      oprot.writeFieldBegin('group_type', TType.STRING, 4)
      oprot.writeString(self.group_type)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.token is None:
      raise TProtocol.TProtocolException(message='Required field token is unset!')
    if self.ref is None:
      raise TProtocol.TProtocolException(message='Required field ref is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.token)
    value = (value * 31) ^ hash(self.ref)
    value = (value * 31) ^ hash(self.filters)
    value = (value * 31) ^ hash(self.group_type)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_feature_ids_result:
  """
  Attributes:
   - success
   - generic_exception
   - authorization_exception
   - authentication_exception
   - reference_exception
   - attribute_exception
   - type_exception
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Feature_id_mapping, Feature_id_mapping.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'generic_exception', (ServiceException, ServiceException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'authorization_exception', (AuthorizationException, AuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'authentication_exception', (AuthenticationException, AuthenticationException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'reference_exception', (ObjectReferenceException, ObjectReferenceException.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'attribute_exception', (AttributeException, AttributeException.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'type_exception', (TypeException, TypeException.thrift_spec), None, ), # 6
  )

  def __init__(self, success=None, generic_exception=None, authorization_exception=None, authentication_exception=None, reference_exception=None, attribute_exception=None, type_exception=None,):
    self.success = success
    self.generic_exception = generic_exception
    self.authorization_exception = authorization_exception
    self.authentication_exception = authentication_exception
    self.reference_exception = reference_exception
    self.attribute_exception = attribute_exception
    self.type_exception = type_exception

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Feature_id_mapping()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_exception = ServiceException()
          self.generic_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.authorization_exception = AuthorizationException()
          self.authorization_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.authentication_exception = AuthenticationException()
          self.authentication_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.reference_exception = ObjectReferenceException()
          self.reference_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.attribute_exception = AttributeException()
          self.attribute_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.type_exception = TypeException()
          self.type_exception.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_feature_ids_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.generic_exception is not None:
      oprot.writeFieldBegin('generic_exception', TType.STRUCT, 1)
      self.generic_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authorization_exception is not None:
      oprot.writeFieldBegin('authorization_exception', TType.STRUCT, 2)
      self.authorization_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authentication_exception is not None:
      oprot.writeFieldBegin('authentication_exception', TType.STRUCT, 3)
      self.authentication_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.reference_exception is not None:
      oprot.writeFieldBegin('reference_exception', TType.STRUCT, 4)
      self.reference_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.attribute_exception is not None:
      oprot.writeFieldBegin('attribute_exception', TType.STRUCT, 5)
      self.attribute_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.type_exception is not None:
      oprot.writeFieldBegin('type_exception', TType.STRUCT, 6)
      self.type_exception.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.generic_exception)
    value = (value * 31) ^ hash(self.authorization_exception)
    value = (value * 31) ^ hash(self.authentication_exception)
    value = (value * 31) ^ hash(self.reference_exception)
    value = (value * 31) ^ hash(self.attribute_exception)
    value = (value * 31) ^ hash(self.type_exception)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_features_args:
  """
  Attributes:
   - token
   - ref
   - feature_id_list
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token', None, None, ), # 1
    (2, TType.STRING, 'ref', None, None, ), # 2
    (3, TType.LIST, 'feature_id_list', (TType.STRING,None), None, ), # 3
  )

  def __init__(self, token=None, ref=None, feature_id_list=None,):
    self.token = token
    self.ref = ref
    self.feature_id_list = feature_id_list

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ref = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.feature_id_list = []
          (_etype233, _size230) = iprot.readListBegin()
          for _i234 in xrange(_size230):
            _elem235 = iprot.readString();
            self.feature_id_list.append(_elem235)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_features_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 1)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    if self.ref is not None:
      oprot.writeFieldBegin('ref', TType.STRING, 2)
      oprot.writeString(self.ref)
      oprot.writeFieldEnd()
    if self.feature_id_list is not None:
      oprot.writeFieldBegin('feature_id_list', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.feature_id_list))
      for iter236 in self.feature_id_list:
        oprot.writeString(iter236)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.token is None:
      raise TProtocol.TProtocolException(message='Required field token is unset!')
    if self.ref is None:
      raise TProtocol.TProtocolException(message='Required field ref is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.token)
    value = (value * 31) ^ hash(self.ref)
    value = (value * 31) ^ hash(self.feature_id_list)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_features_result:
  """
  Attributes:
   - success
   - generic_exception
   - authorization_exception
   - authentication_exception
   - reference_exception
   - attribute_exception
   - type_exception
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.STRUCT,(Feature_data, Feature_data.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'generic_exception', (ServiceException, ServiceException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'authorization_exception', (AuthorizationException, AuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'authentication_exception', (AuthenticationException, AuthenticationException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'reference_exception', (ObjectReferenceException, ObjectReferenceException.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'attribute_exception', (AttributeException, AttributeException.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'type_exception', (TypeException, TypeException.thrift_spec), None, ), # 6
  )

  def __init__(self, success=None, generic_exception=None, authorization_exception=None, authentication_exception=None, reference_exception=None, attribute_exception=None, type_exception=None,):
    self.success = success
    self.generic_exception = generic_exception
    self.authorization_exception = authorization_exception
    self.authentication_exception = authentication_exception
    self.reference_exception = reference_exception
    self.attribute_exception = attribute_exception
    self.type_exception = type_exception

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype238, _vtype239, _size237 ) = iprot.readMapBegin()
          for _i241 in xrange(_size237):
            _key242 = iprot.readString();
            _val243 = Feature_data()
            _val243.read(iprot)
            self.success[_key242] = _val243
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_exception = ServiceException()
          self.generic_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.authorization_exception = AuthorizationException()
          self.authorization_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.authentication_exception = AuthenticationException()
          self.authentication_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.reference_exception = ObjectReferenceException()
          self.reference_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.attribute_exception = AttributeException()
          self.attribute_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.type_exception = TypeException()
          self.type_exception.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_features_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.success))
      for kiter244,viter245 in self.success.items():
        oprot.writeString(kiter244)
        viter245.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.generic_exception is not None:
      oprot.writeFieldBegin('generic_exception', TType.STRUCT, 1)
      self.generic_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authorization_exception is not None:
      oprot.writeFieldBegin('authorization_exception', TType.STRUCT, 2)
      self.authorization_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authentication_exception is not None:
      oprot.writeFieldBegin('authentication_exception', TType.STRUCT, 3)
      self.authentication_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.reference_exception is not None:
      oprot.writeFieldBegin('reference_exception', TType.STRUCT, 4)
      self.reference_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.attribute_exception is not None:
      oprot.writeFieldBegin('attribute_exception', TType.STRUCT, 5)
      self.attribute_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.type_exception is not None:
      oprot.writeFieldBegin('type_exception', TType.STRUCT, 6)
      self.type_exception.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.generic_exception)
    value = (value * 31) ^ hash(self.authorization_exception)
    value = (value * 31) ^ hash(self.authentication_exception)
    value = (value * 31) ^ hash(self.reference_exception)
    value = (value * 31) ^ hash(self.attribute_exception)
    value = (value * 31) ^ hash(self.type_exception)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_proteins_args:
  """
  Attributes:
   - token
   - ref
   - cds_id_list
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token', None, None, ), # 1
    (2, TType.STRING, 'ref', None, None, ), # 2
    (3, TType.LIST, 'cds_id_list', (TType.STRING,None), None, ), # 3
  )

  def __init__(self, token=None, ref=None, cds_id_list=None,):
    self.token = token
    self.ref = ref
    self.cds_id_list = cds_id_list

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ref = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.cds_id_list = []
          (_etype249, _size246) = iprot.readListBegin()
          for _i250 in xrange(_size246):
            _elem251 = iprot.readString();
            self.cds_id_list.append(_elem251)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_proteins_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 1)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    if self.ref is not None:
      oprot.writeFieldBegin('ref', TType.STRING, 2)
      oprot.writeString(self.ref)
      oprot.writeFieldEnd()
    if self.cds_id_list is not None:
      oprot.writeFieldBegin('cds_id_list', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.cds_id_list))
      for iter252 in self.cds_id_list:
        oprot.writeString(iter252)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.token is None:
      raise TProtocol.TProtocolException(message='Required field token is unset!')
    if self.ref is None:
      raise TProtocol.TProtocolException(message='Required field ref is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.token)
    value = (value * 31) ^ hash(self.ref)
    value = (value * 31) ^ hash(self.cds_id_list)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_proteins_result:
  """
  Attributes:
   - success
   - generic_exception
   - authorization_exception
   - authentication_exception
   - reference_exception
   - attribute_exception
   - type_exception
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.STRUCT,(Protein_data, Protein_data.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'generic_exception', (ServiceException, ServiceException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'authorization_exception', (AuthorizationException, AuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'authentication_exception', (AuthenticationException, AuthenticationException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'reference_exception', (ObjectReferenceException, ObjectReferenceException.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'attribute_exception', (AttributeException, AttributeException.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'type_exception', (TypeException, TypeException.thrift_spec), None, ), # 6
  )

  def __init__(self, success=None, generic_exception=None, authorization_exception=None, authentication_exception=None, reference_exception=None, attribute_exception=None, type_exception=None,):
    self.success = success
    self.generic_exception = generic_exception
    self.authorization_exception = authorization_exception
    self.authentication_exception = authentication_exception
    self.reference_exception = reference_exception
    self.attribute_exception = attribute_exception
    self.type_exception = type_exception

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype254, _vtype255, _size253 ) = iprot.readMapBegin()
          for _i257 in xrange(_size253):
            _key258 = iprot.readString();
            _val259 = Protein_data()
            _val259.read(iprot)
            self.success[_key258] = _val259
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_exception = ServiceException()
          self.generic_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.authorization_exception = AuthorizationException()
          self.authorization_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.authentication_exception = AuthenticationException()
          self.authentication_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.reference_exception = ObjectReferenceException()
          self.reference_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.attribute_exception = AttributeException()
          self.attribute_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.type_exception = TypeException()
          self.type_exception.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_proteins_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.success))
      for kiter260,viter261 in self.success.items():
        oprot.writeString(kiter260)
        viter261.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.generic_exception is not None:
      oprot.writeFieldBegin('generic_exception', TType.STRUCT, 1)
      self.generic_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authorization_exception is not None:
      oprot.writeFieldBegin('authorization_exception', TType.STRUCT, 2)
      self.authorization_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authentication_exception is not None:
      oprot.writeFieldBegin('authentication_exception', TType.STRUCT, 3)
      self.authentication_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.reference_exception is not None:
      oprot.writeFieldBegin('reference_exception', TType.STRUCT, 4)
      self.reference_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.attribute_exception is not None:
      oprot.writeFieldBegin('attribute_exception', TType.STRUCT, 5)
      self.attribute_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.type_exception is not None:
      oprot.writeFieldBegin('type_exception', TType.STRUCT, 6)
      self.type_exception.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.generic_exception)
    value = (value * 31) ^ hash(self.authorization_exception)
    value = (value * 31) ^ hash(self.authentication_exception)
    value = (value * 31) ^ hash(self.reference_exception)
    value = (value * 31) ^ hash(self.attribute_exception)
    value = (value * 31) ^ hash(self.type_exception)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_feature_locations_args:
  """
  Attributes:
   - token
   - ref
   - feature_id_list
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token', None, None, ), # 1
    (2, TType.STRING, 'ref', None, None, ), # 2
    (3, TType.LIST, 'feature_id_list', (TType.STRING,None), None, ), # 3
  )

  def __init__(self, token=None, ref=None, feature_id_list=None,):
    self.token = token
    self.ref = ref
    self.feature_id_list = feature_id_list

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ref = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.feature_id_list = []
          (_etype265, _size262) = iprot.readListBegin()
          for _i266 in xrange(_size262):
            _elem267 = iprot.readString();
            self.feature_id_list.append(_elem267)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_feature_locations_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 1)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    if self.ref is not None:
      oprot.writeFieldBegin('ref', TType.STRING, 2)
      oprot.writeString(self.ref)
      oprot.writeFieldEnd()
    if self.feature_id_list is not None:
      oprot.writeFieldBegin('feature_id_list', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.feature_id_list))
      for iter268 in self.feature_id_list:
        oprot.writeString(iter268)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.token is None:
      raise TProtocol.TProtocolException(message='Required field token is unset!')
    if self.ref is None:
      raise TProtocol.TProtocolException(message='Required field ref is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.token)
    value = (value * 31) ^ hash(self.ref)
    value = (value * 31) ^ hash(self.feature_id_list)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_feature_locations_result:
  """
  Attributes:
   - success
   - generic_exception
   - authorization_exception
   - authentication_exception
   - reference_exception
   - attribute_exception
   - type_exception
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.LIST,(TType.STRUCT,(Region, Region.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'generic_exception', (ServiceException, ServiceException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'authorization_exception', (AuthorizationException, AuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'authentication_exception', (AuthenticationException, AuthenticationException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'reference_exception', (ObjectReferenceException, ObjectReferenceException.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'attribute_exception', (AttributeException, AttributeException.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'type_exception', (TypeException, TypeException.thrift_spec), None, ), # 6
  )

  def __init__(self, success=None, generic_exception=None, authorization_exception=None, authentication_exception=None, reference_exception=None, attribute_exception=None, type_exception=None,):
    self.success = success
    self.generic_exception = generic_exception
    self.authorization_exception = authorization_exception
    self.authentication_exception = authentication_exception
    self.reference_exception = reference_exception
    self.attribute_exception = attribute_exception
    self.type_exception = type_exception

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype270, _vtype271, _size269 ) = iprot.readMapBegin()
          for _i273 in xrange(_size269):
            _key274 = iprot.readString();
            _val275 = []
            (_etype279, _size276) = iprot.readListBegin()
            for _i280 in xrange(_size276):
              _elem281 = Region()
              _elem281.read(iprot)
              _val275.append(_elem281)
            iprot.readListEnd()
            self.success[_key274] = _val275
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_exception = ServiceException()
          self.generic_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.authorization_exception = AuthorizationException()
          self.authorization_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.authentication_exception = AuthenticationException()
          self.authentication_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.reference_exception = ObjectReferenceException()
          self.reference_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.attribute_exception = AttributeException()
          self.attribute_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.type_exception = TypeException()
          self.type_exception.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_feature_locations_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.success))
      for kiter282,viter283 in self.success.items():
        oprot.writeString(kiter282)
        oprot.writeListBegin(TType.STRUCT, len(viter283))
        for iter284 in viter283:
          iter284.write(oprot)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.generic_exception is not None:
      oprot.writeFieldBegin('generic_exception', TType.STRUCT, 1)
      self.generic_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authorization_exception is not None:
      oprot.writeFieldBegin('authorization_exception', TType.STRUCT, 2)
      self.authorization_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authentication_exception is not None:
      oprot.writeFieldBegin('authentication_exception', TType.STRUCT, 3)
      self.authentication_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.reference_exception is not None:
      oprot.writeFieldBegin('reference_exception', TType.STRUCT, 4)
      self.reference_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.attribute_exception is not None:
      oprot.writeFieldBegin('attribute_exception', TType.STRUCT, 5)
      self.attribute_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.type_exception is not None:
      oprot.writeFieldBegin('type_exception', TType.STRUCT, 6)
      self.type_exception.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.generic_exception)
    value = (value * 31) ^ hash(self.authorization_exception)
    value = (value * 31) ^ hash(self.authentication_exception)
    value = (value * 31) ^ hash(self.reference_exception)
    value = (value * 31) ^ hash(self.attribute_exception)
    value = (value * 31) ^ hash(self.type_exception)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_feature_publications_args:
  """
  Attributes:
   - token
   - ref
   - feature_id_list
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token', None, None, ), # 1
    (2, TType.STRING, 'ref', None, None, ), # 2
    (3, TType.LIST, 'feature_id_list', (TType.STRING,None), None, ), # 3
  )

  def __init__(self, token=None, ref=None, feature_id_list=None,):
    self.token = token
    self.ref = ref
    self.feature_id_list = feature_id_list

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ref = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.feature_id_list = []
          (_etype288, _size285) = iprot.readListBegin()
          for _i289 in xrange(_size285):
            _elem290 = iprot.readString();
            self.feature_id_list.append(_elem290)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_feature_publications_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 1)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    if self.ref is not None:
      oprot.writeFieldBegin('ref', TType.STRING, 2)
      oprot.writeString(self.ref)
      oprot.writeFieldEnd()
    if self.feature_id_list is not None:
      oprot.writeFieldBegin('feature_id_list', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.feature_id_list))
      for iter291 in self.feature_id_list:
        oprot.writeString(iter291)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.token is None:
      raise TProtocol.TProtocolException(message='Required field token is unset!')
    if self.ref is None:
      raise TProtocol.TProtocolException(message='Required field ref is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.token)
    value = (value * 31) ^ hash(self.ref)
    value = (value * 31) ^ hash(self.feature_id_list)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_feature_publications_result:
  """
  Attributes:
   - success
   - generic_exception
   - authorization_exception
   - authentication_exception
   - reference_exception
   - attribute_exception
   - type_exception
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.LIST,(TType.STRING,None)), None, ), # 0
    (1, TType.STRUCT, 'generic_exception', (ServiceException, ServiceException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'authorization_exception', (AuthorizationException, AuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'authentication_exception', (AuthenticationException, AuthenticationException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'reference_exception', (ObjectReferenceException, ObjectReferenceException.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'attribute_exception', (AttributeException, AttributeException.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'type_exception', (TypeException, TypeException.thrift_spec), None, ), # 6
  )

  def __init__(self, success=None, generic_exception=None, authorization_exception=None, authentication_exception=None, reference_exception=None, attribute_exception=None, type_exception=None,):
    self.success = success
    self.generic_exception = generic_exception
    self.authorization_exception = authorization_exception
    self.authentication_exception = authentication_exception
    self.reference_exception = reference_exception
    self.attribute_exception = attribute_exception
    self.type_exception = type_exception

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype293, _vtype294, _size292 ) = iprot.readMapBegin()
          for _i296 in xrange(_size292):
            _key297 = iprot.readString();
            _val298 = []
            (_etype302, _size299) = iprot.readListBegin()
            for _i303 in xrange(_size299):
              _elem304 = iprot.readString();
              _val298.append(_elem304)
            iprot.readListEnd()
            self.success[_key297] = _val298
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_exception = ServiceException()
          self.generic_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.authorization_exception = AuthorizationException()
          self.authorization_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.authentication_exception = AuthenticationException()
          self.authentication_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.reference_exception = ObjectReferenceException()
          self.reference_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.attribute_exception = AttributeException()
          self.attribute_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.type_exception = TypeException()
          self.type_exception.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_feature_publications_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.success))
      for kiter305,viter306 in self.success.items():
        oprot.writeString(kiter305)
        oprot.writeListBegin(TType.STRING, len(viter306))
        for iter307 in viter306:
          oprot.writeString(iter307)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.generic_exception is not None:
      oprot.writeFieldBegin('generic_exception', TType.STRUCT, 1)
      self.generic_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authorization_exception is not None:
      oprot.writeFieldBegin('authorization_exception', TType.STRUCT, 2)
      self.authorization_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authentication_exception is not None:
      oprot.writeFieldBegin('authentication_exception', TType.STRUCT, 3)
      self.authentication_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.reference_exception is not None:
      oprot.writeFieldBegin('reference_exception', TType.STRUCT, 4)
      self.reference_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.attribute_exception is not None:
      oprot.writeFieldBegin('attribute_exception', TType.STRUCT, 5)
      self.attribute_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.type_exception is not None:
      oprot.writeFieldBegin('type_exception', TType.STRUCT, 6)
      self.type_exception.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.generic_exception)
    value = (value * 31) ^ hash(self.authorization_exception)
    value = (value * 31) ^ hash(self.authentication_exception)
    value = (value * 31) ^ hash(self.reference_exception)
    value = (value * 31) ^ hash(self.attribute_exception)
    value = (value * 31) ^ hash(self.type_exception)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_feature_dna_args:
  """
  Attributes:
   - token
   - ref
   - feature_id_list
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token', None, None, ), # 1
    (2, TType.STRING, 'ref', None, None, ), # 2
    (3, TType.LIST, 'feature_id_list', (TType.STRING,None), None, ), # 3
  )

  def __init__(self, token=None, ref=None, feature_id_list=None,):
    self.token = token
    self.ref = ref
    self.feature_id_list = feature_id_list

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ref = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.feature_id_list = []
          (_etype311, _size308) = iprot.readListBegin()
          for _i312 in xrange(_size308):
            _elem313 = iprot.readString();
            self.feature_id_list.append(_elem313)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_feature_dna_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 1)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    if self.ref is not None:
      oprot.writeFieldBegin('ref', TType.STRING, 2)
      oprot.writeString(self.ref)
      oprot.writeFieldEnd()
    if self.feature_id_list is not None:
      oprot.writeFieldBegin('feature_id_list', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.feature_id_list))
      for iter314 in self.feature_id_list:
        oprot.writeString(iter314)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.token is None:
      raise TProtocol.TProtocolException(message='Required field token is unset!')
    if self.ref is None:
      raise TProtocol.TProtocolException(message='Required field ref is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.token)
    value = (value * 31) ^ hash(self.ref)
    value = (value * 31) ^ hash(self.feature_id_list)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_feature_dna_result:
  """
  Attributes:
   - success
   - generic_exception
   - authorization_exception
   - authentication_exception
   - reference_exception
   - attribute_exception
   - type_exception
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'generic_exception', (ServiceException, ServiceException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'authorization_exception', (AuthorizationException, AuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'authentication_exception', (AuthenticationException, AuthenticationException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'reference_exception', (ObjectReferenceException, ObjectReferenceException.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'attribute_exception', (AttributeException, AttributeException.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'type_exception', (TypeException, TypeException.thrift_spec), None, ), # 6
  )

  def __init__(self, success=None, generic_exception=None, authorization_exception=None, authentication_exception=None, reference_exception=None, attribute_exception=None, type_exception=None,):
    self.success = success
    self.generic_exception = generic_exception
    self.authorization_exception = authorization_exception
    self.authentication_exception = authentication_exception
    self.reference_exception = reference_exception
    self.attribute_exception = attribute_exception
    self.type_exception = type_exception

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype316, _vtype317, _size315 ) = iprot.readMapBegin()
          for _i319 in xrange(_size315):
            _key320 = iprot.readString();
            _val321 = iprot.readString();
            self.success[_key320] = _val321
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_exception = ServiceException()
          self.generic_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.authorization_exception = AuthorizationException()
          self.authorization_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.authentication_exception = AuthenticationException()
          self.authentication_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.reference_exception = ObjectReferenceException()
          self.reference_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.attribute_exception = AttributeException()
          self.attribute_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.type_exception = TypeException()
          self.type_exception.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_feature_dna_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
      for kiter322,viter323 in self.success.items():
        oprot.writeString(kiter322)
        oprot.writeString(viter323)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.generic_exception is not None:
      oprot.writeFieldBegin('generic_exception', TType.STRUCT, 1)
      self.generic_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authorization_exception is not None:
      oprot.writeFieldBegin('authorization_exception', TType.STRUCT, 2)
      self.authorization_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authentication_exception is not None:
      oprot.writeFieldBegin('authentication_exception', TType.STRUCT, 3)
      self.authentication_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.reference_exception is not None:
      oprot.writeFieldBegin('reference_exception', TType.STRUCT, 4)
      self.reference_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.attribute_exception is not None:
      oprot.writeFieldBegin('attribute_exception', TType.STRUCT, 5)
      self.attribute_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.type_exception is not None:
      oprot.writeFieldBegin('type_exception', TType.STRUCT, 6)
      self.type_exception.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.generic_exception)
    value = (value * 31) ^ hash(self.authorization_exception)
    value = (value * 31) ^ hash(self.authentication_exception)
    value = (value * 31) ^ hash(self.reference_exception)
    value = (value * 31) ^ hash(self.attribute_exception)
    value = (value * 31) ^ hash(self.type_exception)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_feature_functions_args:
  """
  Attributes:
   - token
   - ref
   - feature_id_list
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token', None, None, ), # 1
    (2, TType.STRING, 'ref', None, None, ), # 2
    (3, TType.LIST, 'feature_id_list', (TType.STRING,None), None, ), # 3
  )

  def __init__(self, token=None, ref=None, feature_id_list=None,):
    self.token = token
    self.ref = ref
    self.feature_id_list = feature_id_list

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ref = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.feature_id_list = []
          (_etype327, _size324) = iprot.readListBegin()
          for _i328 in xrange(_size324):
            _elem329 = iprot.readString();
            self.feature_id_list.append(_elem329)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_feature_functions_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 1)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    if self.ref is not None:
      oprot.writeFieldBegin('ref', TType.STRING, 2)
      oprot.writeString(self.ref)
      oprot.writeFieldEnd()
    if self.feature_id_list is not None:
      oprot.writeFieldBegin('feature_id_list', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.feature_id_list))
      for iter330 in self.feature_id_list:
        oprot.writeString(iter330)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.token is None:
      raise TProtocol.TProtocolException(message='Required field token is unset!')
    if self.ref is None:
      raise TProtocol.TProtocolException(message='Required field ref is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.token)
    value = (value * 31) ^ hash(self.ref)
    value = (value * 31) ^ hash(self.feature_id_list)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_feature_functions_result:
  """
  Attributes:
   - success
   - generic_exception
   - authorization_exception
   - authentication_exception
   - reference_exception
   - attribute_exception
   - type_exception
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'generic_exception', (ServiceException, ServiceException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'authorization_exception', (AuthorizationException, AuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'authentication_exception', (AuthenticationException, AuthenticationException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'reference_exception', (ObjectReferenceException, ObjectReferenceException.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'attribute_exception', (AttributeException, AttributeException.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'type_exception', (TypeException, TypeException.thrift_spec), None, ), # 6
  )

  def __init__(self, success=None, generic_exception=None, authorization_exception=None, authentication_exception=None, reference_exception=None, attribute_exception=None, type_exception=None,):
    self.success = success
    self.generic_exception = generic_exception
    self.authorization_exception = authorization_exception
    self.authentication_exception = authentication_exception
    self.reference_exception = reference_exception
    self.attribute_exception = attribute_exception
    self.type_exception = type_exception

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype332, _vtype333, _size331 ) = iprot.readMapBegin()
          for _i335 in xrange(_size331):
            _key336 = iprot.readString();
            _val337 = iprot.readString();
            self.success[_key336] = _val337
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_exception = ServiceException()
          self.generic_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.authorization_exception = AuthorizationException()
          self.authorization_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.authentication_exception = AuthenticationException()
          self.authentication_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.reference_exception = ObjectReferenceException()
          self.reference_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.attribute_exception = AttributeException()
          self.attribute_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.type_exception = TypeException()
          self.type_exception.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_feature_functions_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
      for kiter338,viter339 in self.success.items():
        oprot.writeString(kiter338)
        oprot.writeString(viter339)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.generic_exception is not None:
      oprot.writeFieldBegin('generic_exception', TType.STRUCT, 1)
      self.generic_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authorization_exception is not None:
      oprot.writeFieldBegin('authorization_exception', TType.STRUCT, 2)
      self.authorization_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authentication_exception is not None:
      oprot.writeFieldBegin('authentication_exception', TType.STRUCT, 3)
      self.authentication_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.reference_exception is not None:
      oprot.writeFieldBegin('reference_exception', TType.STRUCT, 4)
      self.reference_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.attribute_exception is not None:
      oprot.writeFieldBegin('attribute_exception', TType.STRUCT, 5)
      self.attribute_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.type_exception is not None:
      oprot.writeFieldBegin('type_exception', TType.STRUCT, 6)
      self.type_exception.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.generic_exception)
    value = (value * 31) ^ hash(self.authorization_exception)
    value = (value * 31) ^ hash(self.authentication_exception)
    value = (value * 31) ^ hash(self.reference_exception)
    value = (value * 31) ^ hash(self.attribute_exception)
    value = (value * 31) ^ hash(self.type_exception)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_feature_aliases_args:
  """
  Attributes:
   - token
   - ref
   - feature_id_list
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token', None, None, ), # 1
    (2, TType.STRING, 'ref', None, None, ), # 2
    (3, TType.LIST, 'feature_id_list', (TType.STRING,None), None, ), # 3
  )

  def __init__(self, token=None, ref=None, feature_id_list=None,):
    self.token = token
    self.ref = ref
    self.feature_id_list = feature_id_list

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ref = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.feature_id_list = []
          (_etype343, _size340) = iprot.readListBegin()
          for _i344 in xrange(_size340):
            _elem345 = iprot.readString();
            self.feature_id_list.append(_elem345)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_feature_aliases_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 1)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    if self.ref is not None:
      oprot.writeFieldBegin('ref', TType.STRING, 2)
      oprot.writeString(self.ref)
      oprot.writeFieldEnd()
    if self.feature_id_list is not None:
      oprot.writeFieldBegin('feature_id_list', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.feature_id_list))
      for iter346 in self.feature_id_list:
        oprot.writeString(iter346)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.token is None:
      raise TProtocol.TProtocolException(message='Required field token is unset!')
    if self.ref is None:
      raise TProtocol.TProtocolException(message='Required field ref is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.token)
    value = (value * 31) ^ hash(self.ref)
    value = (value * 31) ^ hash(self.feature_id_list)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_feature_aliases_result:
  """
  Attributes:
   - success
   - generic_exception
   - authorization_exception
   - authentication_exception
   - reference_exception
   - attribute_exception
   - type_exception
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.LIST,(TType.STRING,None)), None, ), # 0
    (1, TType.STRUCT, 'generic_exception', (ServiceException, ServiceException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'authorization_exception', (AuthorizationException, AuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'authentication_exception', (AuthenticationException, AuthenticationException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'reference_exception', (ObjectReferenceException, ObjectReferenceException.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'attribute_exception', (AttributeException, AttributeException.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'type_exception', (TypeException, TypeException.thrift_spec), None, ), # 6
  )

  def __init__(self, success=None, generic_exception=None, authorization_exception=None, authentication_exception=None, reference_exception=None, attribute_exception=None, type_exception=None,):
    self.success = success
    self.generic_exception = generic_exception
    self.authorization_exception = authorization_exception
    self.authentication_exception = authentication_exception
    self.reference_exception = reference_exception
    self.attribute_exception = attribute_exception
    self.type_exception = type_exception

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype348, _vtype349, _size347 ) = iprot.readMapBegin()
          for _i351 in xrange(_size347):
            _key352 = iprot.readString();
            _val353 = []
            (_etype357, _size354) = iprot.readListBegin()
            for _i358 in xrange(_size354):
              _elem359 = iprot.readString();
              _val353.append(_elem359)
            iprot.readListEnd()
            self.success[_key352] = _val353
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_exception = ServiceException()
          self.generic_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.authorization_exception = AuthorizationException()
          self.authorization_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.authentication_exception = AuthenticationException()
          self.authentication_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.reference_exception = ObjectReferenceException()
          self.reference_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.attribute_exception = AttributeException()
          self.attribute_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.type_exception = TypeException()
          self.type_exception.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_feature_aliases_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.success))
      for kiter360,viter361 in self.success.items():
        oprot.writeString(kiter360)
        oprot.writeListBegin(TType.STRING, len(viter361))
        for iter362 in viter361:
          oprot.writeString(iter362)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.generic_exception is not None:
      oprot.writeFieldBegin('generic_exception', TType.STRUCT, 1)
      self.generic_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authorization_exception is not None:
      oprot.writeFieldBegin('authorization_exception', TType.STRUCT, 2)
      self.authorization_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authentication_exception is not None:
      oprot.writeFieldBegin('authentication_exception', TType.STRUCT, 3)
      self.authentication_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.reference_exception is not None:
      oprot.writeFieldBegin('reference_exception', TType.STRUCT, 4)
      self.reference_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.attribute_exception is not None:
      oprot.writeFieldBegin('attribute_exception', TType.STRUCT, 5)
      self.attribute_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.type_exception is not None:
      oprot.writeFieldBegin('type_exception', TType.STRUCT, 6)
      self.type_exception.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.generic_exception)
    value = (value * 31) ^ hash(self.authorization_exception)
    value = (value * 31) ^ hash(self.authentication_exception)
    value = (value * 31) ^ hash(self.reference_exception)
    value = (value * 31) ^ hash(self.attribute_exception)
    value = (value * 31) ^ hash(self.type_exception)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_cds_by_gene_args:
  """
  Attributes:
   - token
   - ref
   - gene_id_list
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token', None, None, ), # 1
    (2, TType.STRING, 'ref', None, None, ), # 2
    (3, TType.LIST, 'gene_id_list', (TType.STRING,None), None, ), # 3
  )

  def __init__(self, token=None, ref=None, gene_id_list=None,):
    self.token = token
    self.ref = ref
    self.gene_id_list = gene_id_list

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ref = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.gene_id_list = []
          (_etype366, _size363) = iprot.readListBegin()
          for _i367 in xrange(_size363):
            _elem368 = iprot.readString();
            self.gene_id_list.append(_elem368)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_cds_by_gene_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 1)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    if self.ref is not None:
      oprot.writeFieldBegin('ref', TType.STRING, 2)
      oprot.writeString(self.ref)
      oprot.writeFieldEnd()
    if self.gene_id_list is not None:
      oprot.writeFieldBegin('gene_id_list', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.gene_id_list))
      for iter369 in self.gene_id_list:
        oprot.writeString(iter369)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.token is None:
      raise TProtocol.TProtocolException(message='Required field token is unset!')
    if self.ref is None:
      raise TProtocol.TProtocolException(message='Required field ref is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.token)
    value = (value * 31) ^ hash(self.ref)
    value = (value * 31) ^ hash(self.gene_id_list)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_cds_by_gene_result:
  """
  Attributes:
   - success
   - generic_exception
   - authorization_exception
   - authentication_exception
   - reference_exception
   - attribute_exception
   - type_exception
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.LIST,(TType.STRING,None)), None, ), # 0
    (1, TType.STRUCT, 'generic_exception', (ServiceException, ServiceException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'authorization_exception', (AuthorizationException, AuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'authentication_exception', (AuthenticationException, AuthenticationException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'reference_exception', (ObjectReferenceException, ObjectReferenceException.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'attribute_exception', (AttributeException, AttributeException.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'type_exception', (TypeException, TypeException.thrift_spec), None, ), # 6
  )

  def __init__(self, success=None, generic_exception=None, authorization_exception=None, authentication_exception=None, reference_exception=None, attribute_exception=None, type_exception=None,):
    self.success = success
    self.generic_exception = generic_exception
    self.authorization_exception = authorization_exception
    self.authentication_exception = authentication_exception
    self.reference_exception = reference_exception
    self.attribute_exception = attribute_exception
    self.type_exception = type_exception

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype371, _vtype372, _size370 ) = iprot.readMapBegin()
          for _i374 in xrange(_size370):
            _key375 = iprot.readString();
            _val376 = []
            (_etype380, _size377) = iprot.readListBegin()
            for _i381 in xrange(_size377):
              _elem382 = iprot.readString();
              _val376.append(_elem382)
            iprot.readListEnd()
            self.success[_key375] = _val376
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_exception = ServiceException()
          self.generic_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.authorization_exception = AuthorizationException()
          self.authorization_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.authentication_exception = AuthenticationException()
          self.authentication_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.reference_exception = ObjectReferenceException()
          self.reference_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.attribute_exception = AttributeException()
          self.attribute_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.type_exception = TypeException()
          self.type_exception.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_cds_by_gene_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.success))
      for kiter383,viter384 in self.success.items():
        oprot.writeString(kiter383)
        oprot.writeListBegin(TType.STRING, len(viter384))
        for iter385 in viter384:
          oprot.writeString(iter385)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.generic_exception is not None:
      oprot.writeFieldBegin('generic_exception', TType.STRUCT, 1)
      self.generic_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authorization_exception is not None:
      oprot.writeFieldBegin('authorization_exception', TType.STRUCT, 2)
      self.authorization_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authentication_exception is not None:
      oprot.writeFieldBegin('authentication_exception', TType.STRUCT, 3)
      self.authentication_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.reference_exception is not None:
      oprot.writeFieldBegin('reference_exception', TType.STRUCT, 4)
      self.reference_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.attribute_exception is not None:
      oprot.writeFieldBegin('attribute_exception', TType.STRUCT, 5)
      self.attribute_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.type_exception is not None:
      oprot.writeFieldBegin('type_exception', TType.STRUCT, 6)
      self.type_exception.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.generic_exception)
    value = (value * 31) ^ hash(self.authorization_exception)
    value = (value * 31) ^ hash(self.authentication_exception)
    value = (value * 31) ^ hash(self.reference_exception)
    value = (value * 31) ^ hash(self.attribute_exception)
    value = (value * 31) ^ hash(self.type_exception)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_cds_by_mrna_args:
  """
  Attributes:
   - token
   - ref
   - mrna_id_list
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token', None, None, ), # 1
    (2, TType.STRING, 'ref', None, None, ), # 2
    (3, TType.LIST, 'mrna_id_list', (TType.STRING,None), None, ), # 3
  )

  def __init__(self, token=None, ref=None, mrna_id_list=None,):
    self.token = token
    self.ref = ref
    self.mrna_id_list = mrna_id_list

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ref = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.mrna_id_list = []
          (_etype389, _size386) = iprot.readListBegin()
          for _i390 in xrange(_size386):
            _elem391 = iprot.readString();
            self.mrna_id_list.append(_elem391)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_cds_by_mrna_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 1)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    if self.ref is not None:
      oprot.writeFieldBegin('ref', TType.STRING, 2)
      oprot.writeString(self.ref)
      oprot.writeFieldEnd()
    if self.mrna_id_list is not None:
      oprot.writeFieldBegin('mrna_id_list', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.mrna_id_list))
      for iter392 in self.mrna_id_list:
        oprot.writeString(iter392)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.token is None:
      raise TProtocol.TProtocolException(message='Required field token is unset!')
    if self.ref is None:
      raise TProtocol.TProtocolException(message='Required field ref is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.token)
    value = (value * 31) ^ hash(self.ref)
    value = (value * 31) ^ hash(self.mrna_id_list)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_cds_by_mrna_result:
  """
  Attributes:
   - success
   - generic_exception
   - authorization_exception
   - authentication_exception
   - reference_exception
   - attribute_exception
   - type_exception
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'generic_exception', (ServiceException, ServiceException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'authorization_exception', (AuthorizationException, AuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'authentication_exception', (AuthenticationException, AuthenticationException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'reference_exception', (ObjectReferenceException, ObjectReferenceException.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'attribute_exception', (AttributeException, AttributeException.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'type_exception', (TypeException, TypeException.thrift_spec), None, ), # 6
  )

  def __init__(self, success=None, generic_exception=None, authorization_exception=None, authentication_exception=None, reference_exception=None, attribute_exception=None, type_exception=None,):
    self.success = success
    self.generic_exception = generic_exception
    self.authorization_exception = authorization_exception
    self.authentication_exception = authentication_exception
    self.reference_exception = reference_exception
    self.attribute_exception = attribute_exception
    self.type_exception = type_exception

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype394, _vtype395, _size393 ) = iprot.readMapBegin()
          for _i397 in xrange(_size393):
            _key398 = iprot.readString();
            _val399 = iprot.readString();
            self.success[_key398] = _val399
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_exception = ServiceException()
          self.generic_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.authorization_exception = AuthorizationException()
          self.authorization_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.authentication_exception = AuthenticationException()
          self.authentication_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.reference_exception = ObjectReferenceException()
          self.reference_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.attribute_exception = AttributeException()
          self.attribute_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.type_exception = TypeException()
          self.type_exception.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_cds_by_mrna_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
      for kiter400,viter401 in self.success.items():
        oprot.writeString(kiter400)
        oprot.writeString(viter401)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.generic_exception is not None:
      oprot.writeFieldBegin('generic_exception', TType.STRUCT, 1)
      self.generic_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authorization_exception is not None:
      oprot.writeFieldBegin('authorization_exception', TType.STRUCT, 2)
      self.authorization_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authentication_exception is not None:
      oprot.writeFieldBegin('authentication_exception', TType.STRUCT, 3)
      self.authentication_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.reference_exception is not None:
      oprot.writeFieldBegin('reference_exception', TType.STRUCT, 4)
      self.reference_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.attribute_exception is not None:
      oprot.writeFieldBegin('attribute_exception', TType.STRUCT, 5)
      self.attribute_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.type_exception is not None:
      oprot.writeFieldBegin('type_exception', TType.STRUCT, 6)
      self.type_exception.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.generic_exception)
    value = (value * 31) ^ hash(self.authorization_exception)
    value = (value * 31) ^ hash(self.authentication_exception)
    value = (value * 31) ^ hash(self.reference_exception)
    value = (value * 31) ^ hash(self.attribute_exception)
    value = (value * 31) ^ hash(self.type_exception)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_gene_by_cds_args:
  """
  Attributes:
   - token
   - ref
   - cds_id_list
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token', None, None, ), # 1
    (2, TType.STRING, 'ref', None, None, ), # 2
    (3, TType.LIST, 'cds_id_list', (TType.STRING,None), None, ), # 3
  )

  def __init__(self, token=None, ref=None, cds_id_list=None,):
    self.token = token
    self.ref = ref
    self.cds_id_list = cds_id_list

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ref = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.cds_id_list = []
          (_etype405, _size402) = iprot.readListBegin()
          for _i406 in xrange(_size402):
            _elem407 = iprot.readString();
            self.cds_id_list.append(_elem407)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_gene_by_cds_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 1)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    if self.ref is not None:
      oprot.writeFieldBegin('ref', TType.STRING, 2)
      oprot.writeString(self.ref)
      oprot.writeFieldEnd()
    if self.cds_id_list is not None:
      oprot.writeFieldBegin('cds_id_list', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.cds_id_list))
      for iter408 in self.cds_id_list:
        oprot.writeString(iter408)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.token is None:
      raise TProtocol.TProtocolException(message='Required field token is unset!')
    if self.ref is None:
      raise TProtocol.TProtocolException(message='Required field ref is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.token)
    value = (value * 31) ^ hash(self.ref)
    value = (value * 31) ^ hash(self.cds_id_list)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_gene_by_cds_result:
  """
  Attributes:
   - success
   - generic_exception
   - authorization_exception
   - authentication_exception
   - reference_exception
   - attribute_exception
   - type_exception
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'generic_exception', (ServiceException, ServiceException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'authorization_exception', (AuthorizationException, AuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'authentication_exception', (AuthenticationException, AuthenticationException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'reference_exception', (ObjectReferenceException, ObjectReferenceException.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'attribute_exception', (AttributeException, AttributeException.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'type_exception', (TypeException, TypeException.thrift_spec), None, ), # 6
  )

  def __init__(self, success=None, generic_exception=None, authorization_exception=None, authentication_exception=None, reference_exception=None, attribute_exception=None, type_exception=None,):
    self.success = success
    self.generic_exception = generic_exception
    self.authorization_exception = authorization_exception
    self.authentication_exception = authentication_exception
    self.reference_exception = reference_exception
    self.attribute_exception = attribute_exception
    self.type_exception = type_exception

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype410, _vtype411, _size409 ) = iprot.readMapBegin()
          for _i413 in xrange(_size409):
            _key414 = iprot.readString();
            _val415 = iprot.readString();
            self.success[_key414] = _val415
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_exception = ServiceException()
          self.generic_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.authorization_exception = AuthorizationException()
          self.authorization_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.authentication_exception = AuthenticationException()
          self.authentication_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.reference_exception = ObjectReferenceException()
          self.reference_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.attribute_exception = AttributeException()
          self.attribute_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.type_exception = TypeException()
          self.type_exception.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_gene_by_cds_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
      for kiter416,viter417 in self.success.items():
        oprot.writeString(kiter416)
        oprot.writeString(viter417)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.generic_exception is not None:
      oprot.writeFieldBegin('generic_exception', TType.STRUCT, 1)
      self.generic_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authorization_exception is not None:
      oprot.writeFieldBegin('authorization_exception', TType.STRUCT, 2)
      self.authorization_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authentication_exception is not None:
      oprot.writeFieldBegin('authentication_exception', TType.STRUCT, 3)
      self.authentication_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.reference_exception is not None:
      oprot.writeFieldBegin('reference_exception', TType.STRUCT, 4)
      self.reference_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.attribute_exception is not None:
      oprot.writeFieldBegin('attribute_exception', TType.STRUCT, 5)
      self.attribute_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.type_exception is not None:
      oprot.writeFieldBegin('type_exception', TType.STRUCT, 6)
      self.type_exception.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.generic_exception)
    value = (value * 31) ^ hash(self.authorization_exception)
    value = (value * 31) ^ hash(self.authentication_exception)
    value = (value * 31) ^ hash(self.reference_exception)
    value = (value * 31) ^ hash(self.attribute_exception)
    value = (value * 31) ^ hash(self.type_exception)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_gene_by_mrna_args:
  """
  Attributes:
   - token
   - ref
   - mrna_id_list
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token', None, None, ), # 1
    (2, TType.STRING, 'ref', None, None, ), # 2
    (3, TType.LIST, 'mrna_id_list', (TType.STRING,None), None, ), # 3
  )

  def __init__(self, token=None, ref=None, mrna_id_list=None,):
    self.token = token
    self.ref = ref
    self.mrna_id_list = mrna_id_list

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ref = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.mrna_id_list = []
          (_etype421, _size418) = iprot.readListBegin()
          for _i422 in xrange(_size418):
            _elem423 = iprot.readString();
            self.mrna_id_list.append(_elem423)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_gene_by_mrna_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 1)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    if self.ref is not None:
      oprot.writeFieldBegin('ref', TType.STRING, 2)
      oprot.writeString(self.ref)
      oprot.writeFieldEnd()
    if self.mrna_id_list is not None:
      oprot.writeFieldBegin('mrna_id_list', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.mrna_id_list))
      for iter424 in self.mrna_id_list:
        oprot.writeString(iter424)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.token is None:
      raise TProtocol.TProtocolException(message='Required field token is unset!')
    if self.ref is None:
      raise TProtocol.TProtocolException(message='Required field ref is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.token)
    value = (value * 31) ^ hash(self.ref)
    value = (value * 31) ^ hash(self.mrna_id_list)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_gene_by_mrna_result:
  """
  Attributes:
   - success
   - generic_exception
   - authorization_exception
   - authentication_exception
   - reference_exception
   - attribute_exception
   - type_exception
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'generic_exception', (ServiceException, ServiceException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'authorization_exception', (AuthorizationException, AuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'authentication_exception', (AuthenticationException, AuthenticationException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'reference_exception', (ObjectReferenceException, ObjectReferenceException.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'attribute_exception', (AttributeException, AttributeException.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'type_exception', (TypeException, TypeException.thrift_spec), None, ), # 6
  )

  def __init__(self, success=None, generic_exception=None, authorization_exception=None, authentication_exception=None, reference_exception=None, attribute_exception=None, type_exception=None,):
    self.success = success
    self.generic_exception = generic_exception
    self.authorization_exception = authorization_exception
    self.authentication_exception = authentication_exception
    self.reference_exception = reference_exception
    self.attribute_exception = attribute_exception
    self.type_exception = type_exception

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype426, _vtype427, _size425 ) = iprot.readMapBegin()
          for _i429 in xrange(_size425):
            _key430 = iprot.readString();
            _val431 = iprot.readString();
            self.success[_key430] = _val431
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_exception = ServiceException()
          self.generic_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.authorization_exception = AuthorizationException()
          self.authorization_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.authentication_exception = AuthenticationException()
          self.authentication_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.reference_exception = ObjectReferenceException()
          self.reference_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.attribute_exception = AttributeException()
          self.attribute_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.type_exception = TypeException()
          self.type_exception.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_gene_by_mrna_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
      for kiter432,viter433 in self.success.items():
        oprot.writeString(kiter432)
        oprot.writeString(viter433)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.generic_exception is not None:
      oprot.writeFieldBegin('generic_exception', TType.STRUCT, 1)
      self.generic_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authorization_exception is not None:
      oprot.writeFieldBegin('authorization_exception', TType.STRUCT, 2)
      self.authorization_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authentication_exception is not None:
      oprot.writeFieldBegin('authentication_exception', TType.STRUCT, 3)
      self.authentication_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.reference_exception is not None:
      oprot.writeFieldBegin('reference_exception', TType.STRUCT, 4)
      self.reference_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.attribute_exception is not None:
      oprot.writeFieldBegin('attribute_exception', TType.STRUCT, 5)
      self.attribute_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.type_exception is not None:
      oprot.writeFieldBegin('type_exception', TType.STRUCT, 6)
      self.type_exception.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.generic_exception)
    value = (value * 31) ^ hash(self.authorization_exception)
    value = (value * 31) ^ hash(self.authentication_exception)
    value = (value * 31) ^ hash(self.reference_exception)
    value = (value * 31) ^ hash(self.attribute_exception)
    value = (value * 31) ^ hash(self.type_exception)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_mrna_by_cds_args:
  """
  Attributes:
   - token
   - ref
   - cds_id_list
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token', None, None, ), # 1
    (2, TType.STRING, 'ref', None, None, ), # 2
    (3, TType.LIST, 'cds_id_list', (TType.STRING,None), None, ), # 3
  )

  def __init__(self, token=None, ref=None, cds_id_list=None,):
    self.token = token
    self.ref = ref
    self.cds_id_list = cds_id_list

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ref = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.cds_id_list = []
          (_etype437, _size434) = iprot.readListBegin()
          for _i438 in xrange(_size434):
            _elem439 = iprot.readString();
            self.cds_id_list.append(_elem439)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_mrna_by_cds_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 1)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    if self.ref is not None:
      oprot.writeFieldBegin('ref', TType.STRING, 2)
      oprot.writeString(self.ref)
      oprot.writeFieldEnd()
    if self.cds_id_list is not None:
      oprot.writeFieldBegin('cds_id_list', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.cds_id_list))
      for iter440 in self.cds_id_list:
        oprot.writeString(iter440)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.token is None:
      raise TProtocol.TProtocolException(message='Required field token is unset!')
    if self.ref is None:
      raise TProtocol.TProtocolException(message='Required field ref is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.token)
    value = (value * 31) ^ hash(self.ref)
    value = (value * 31) ^ hash(self.cds_id_list)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_mrna_by_cds_result:
  """
  Attributes:
   - success
   - generic_exception
   - authorization_exception
   - authentication_exception
   - reference_exception
   - attribute_exception
   - type_exception
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'generic_exception', (ServiceException, ServiceException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'authorization_exception', (AuthorizationException, AuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'authentication_exception', (AuthenticationException, AuthenticationException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'reference_exception', (ObjectReferenceException, ObjectReferenceException.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'attribute_exception', (AttributeException, AttributeException.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'type_exception', (TypeException, TypeException.thrift_spec), None, ), # 6
  )

  def __init__(self, success=None, generic_exception=None, authorization_exception=None, authentication_exception=None, reference_exception=None, attribute_exception=None, type_exception=None,):
    self.success = success
    self.generic_exception = generic_exception
    self.authorization_exception = authorization_exception
    self.authentication_exception = authentication_exception
    self.reference_exception = reference_exception
    self.attribute_exception = attribute_exception
    self.type_exception = type_exception

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype442, _vtype443, _size441 ) = iprot.readMapBegin()
          for _i445 in xrange(_size441):
            _key446 = iprot.readString();
            _val447 = iprot.readString();
            self.success[_key446] = _val447
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_exception = ServiceException()
          self.generic_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.authorization_exception = AuthorizationException()
          self.authorization_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.authentication_exception = AuthenticationException()
          self.authentication_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.reference_exception = ObjectReferenceException()
          self.reference_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.attribute_exception = AttributeException()
          self.attribute_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.type_exception = TypeException()
          self.type_exception.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_mrna_by_cds_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
      for kiter448,viter449 in self.success.items():
        oprot.writeString(kiter448)
        oprot.writeString(viter449)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.generic_exception is not None:
      oprot.writeFieldBegin('generic_exception', TType.STRUCT, 1)
      self.generic_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authorization_exception is not None:
      oprot.writeFieldBegin('authorization_exception', TType.STRUCT, 2)
      self.authorization_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authentication_exception is not None:
      oprot.writeFieldBegin('authentication_exception', TType.STRUCT, 3)
      self.authentication_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.reference_exception is not None:
      oprot.writeFieldBegin('reference_exception', TType.STRUCT, 4)
      self.reference_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.attribute_exception is not None:
      oprot.writeFieldBegin('attribute_exception', TType.STRUCT, 5)
      self.attribute_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.type_exception is not None:
      oprot.writeFieldBegin('type_exception', TType.STRUCT, 6)
      self.type_exception.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.generic_exception)
    value = (value * 31) ^ hash(self.authorization_exception)
    value = (value * 31) ^ hash(self.authentication_exception)
    value = (value * 31) ^ hash(self.reference_exception)
    value = (value * 31) ^ hash(self.attribute_exception)
    value = (value * 31) ^ hash(self.type_exception)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_mrna_by_gene_args:
  """
  Attributes:
   - token
   - ref
   - gene_id_list
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token', None, None, ), # 1
    (2, TType.STRING, 'ref', None, None, ), # 2
    (3, TType.LIST, 'gene_id_list', (TType.STRING,None), None, ), # 3
  )

  def __init__(self, token=None, ref=None, gene_id_list=None,):
    self.token = token
    self.ref = ref
    self.gene_id_list = gene_id_list

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ref = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.gene_id_list = []
          (_etype453, _size450) = iprot.readListBegin()
          for _i454 in xrange(_size450):
            _elem455 = iprot.readString();
            self.gene_id_list.append(_elem455)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_mrna_by_gene_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 1)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    if self.ref is not None:
      oprot.writeFieldBegin('ref', TType.STRING, 2)
      oprot.writeString(self.ref)
      oprot.writeFieldEnd()
    if self.gene_id_list is not None:
      oprot.writeFieldBegin('gene_id_list', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.gene_id_list))
      for iter456 in self.gene_id_list:
        oprot.writeString(iter456)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.token is None:
      raise TProtocol.TProtocolException(message='Required field token is unset!')
    if self.ref is None:
      raise TProtocol.TProtocolException(message='Required field ref is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.token)
    value = (value * 31) ^ hash(self.ref)
    value = (value * 31) ^ hash(self.gene_id_list)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_mrna_by_gene_result:
  """
  Attributes:
   - success
   - generic_exception
   - authorization_exception
   - authentication_exception
   - reference_exception
   - attribute_exception
   - type_exception
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.LIST,(TType.STRING,None)), None, ), # 0
    (1, TType.STRUCT, 'generic_exception', (ServiceException, ServiceException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'authorization_exception', (AuthorizationException, AuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'authentication_exception', (AuthenticationException, AuthenticationException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'reference_exception', (ObjectReferenceException, ObjectReferenceException.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'attribute_exception', (AttributeException, AttributeException.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'type_exception', (TypeException, TypeException.thrift_spec), None, ), # 6
  )

  def __init__(self, success=None, generic_exception=None, authorization_exception=None, authentication_exception=None, reference_exception=None, attribute_exception=None, type_exception=None,):
    self.success = success
    self.generic_exception = generic_exception
    self.authorization_exception = authorization_exception
    self.authentication_exception = authentication_exception
    self.reference_exception = reference_exception
    self.attribute_exception = attribute_exception
    self.type_exception = type_exception

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype458, _vtype459, _size457 ) = iprot.readMapBegin()
          for _i461 in xrange(_size457):
            _key462 = iprot.readString();
            _val463 = []
            (_etype467, _size464) = iprot.readListBegin()
            for _i468 in xrange(_size464):
              _elem469 = iprot.readString();
              _val463.append(_elem469)
            iprot.readListEnd()
            self.success[_key462] = _val463
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_exception = ServiceException()
          self.generic_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.authorization_exception = AuthorizationException()
          self.authorization_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.authentication_exception = AuthenticationException()
          self.authentication_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.reference_exception = ObjectReferenceException()
          self.reference_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.attribute_exception = AttributeException()
          self.attribute_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.type_exception = TypeException()
          self.type_exception.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_mrna_by_gene_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.success))
      for kiter470,viter471 in self.success.items():
        oprot.writeString(kiter470)
        oprot.writeListBegin(TType.STRING, len(viter471))
        for iter472 in viter471:
          oprot.writeString(iter472)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.generic_exception is not None:
      oprot.writeFieldBegin('generic_exception', TType.STRUCT, 1)
      self.generic_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authorization_exception is not None:
      oprot.writeFieldBegin('authorization_exception', TType.STRUCT, 2)
      self.authorization_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authentication_exception is not None:
      oprot.writeFieldBegin('authentication_exception', TType.STRUCT, 3)
      self.authentication_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.reference_exception is not None:
      oprot.writeFieldBegin('reference_exception', TType.STRUCT, 4)
      self.reference_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.attribute_exception is not None:
      oprot.writeFieldBegin('attribute_exception', TType.STRUCT, 5)
      self.attribute_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.type_exception is not None:
      oprot.writeFieldBegin('type_exception', TType.STRUCT, 6)
      self.type_exception.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.generic_exception)
    value = (value * 31) ^ hash(self.authorization_exception)
    value = (value * 31) ^ hash(self.authentication_exception)
    value = (value * 31) ^ hash(self.reference_exception)
    value = (value * 31) ^ hash(self.attribute_exception)
    value = (value * 31) ^ hash(self.type_exception)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_mrna_exons_args:
  """
  Attributes:
   - token
   - ref
   - mrna_id_list
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token', None, None, ), # 1
    (2, TType.STRING, 'ref', None, None, ), # 2
    (3, TType.LIST, 'mrna_id_list', (TType.STRING,None), None, ), # 3
  )

  def __init__(self, token=None, ref=None, mrna_id_list=None,):
    self.token = token
    self.ref = ref
    self.mrna_id_list = mrna_id_list

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ref = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.mrna_id_list = []
          (_etype476, _size473) = iprot.readListBegin()
          for _i477 in xrange(_size473):
            _elem478 = iprot.readString();
            self.mrna_id_list.append(_elem478)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_mrna_exons_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 1)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    if self.ref is not None:
      oprot.writeFieldBegin('ref', TType.STRING, 2)
      oprot.writeString(self.ref)
      oprot.writeFieldEnd()
    if self.mrna_id_list is not None:
      oprot.writeFieldBegin('mrna_id_list', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.mrna_id_list))
      for iter479 in self.mrna_id_list:
        oprot.writeString(iter479)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.token is None:
      raise TProtocol.TProtocolException(message='Required field token is unset!')
    if self.ref is None:
      raise TProtocol.TProtocolException(message='Required field ref is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.token)
    value = (value * 31) ^ hash(self.ref)
    value = (value * 31) ^ hash(self.mrna_id_list)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_mrna_exons_result:
  """
  Attributes:
   - success
   - generic_exception
   - authorization_exception
   - authentication_exception
   - reference_exception
   - attribute_exception
   - type_exception
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.LIST,(TType.STRUCT,(Exon_data, Exon_data.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'generic_exception', (ServiceException, ServiceException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'authorization_exception', (AuthorizationException, AuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'authentication_exception', (AuthenticationException, AuthenticationException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'reference_exception', (ObjectReferenceException, ObjectReferenceException.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'attribute_exception', (AttributeException, AttributeException.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'type_exception', (TypeException, TypeException.thrift_spec), None, ), # 6
  )

  def __init__(self, success=None, generic_exception=None, authorization_exception=None, authentication_exception=None, reference_exception=None, attribute_exception=None, type_exception=None,):
    self.success = success
    self.generic_exception = generic_exception
    self.authorization_exception = authorization_exception
    self.authentication_exception = authentication_exception
    self.reference_exception = reference_exception
    self.attribute_exception = attribute_exception
    self.type_exception = type_exception

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype481, _vtype482, _size480 ) = iprot.readMapBegin()
          for _i484 in xrange(_size480):
            _key485 = iprot.readString();
            _val486 = []
            (_etype490, _size487) = iprot.readListBegin()
            for _i491 in xrange(_size487):
              _elem492 = Exon_data()
              _elem492.read(iprot)
              _val486.append(_elem492)
            iprot.readListEnd()
            self.success[_key485] = _val486
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_exception = ServiceException()
          self.generic_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.authorization_exception = AuthorizationException()
          self.authorization_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.authentication_exception = AuthenticationException()
          self.authentication_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.reference_exception = ObjectReferenceException()
          self.reference_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.attribute_exception = AttributeException()
          self.attribute_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.type_exception = TypeException()
          self.type_exception.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_mrna_exons_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.success))
      for kiter493,viter494 in self.success.items():
        oprot.writeString(kiter493)
        oprot.writeListBegin(TType.STRUCT, len(viter494))
        for iter495 in viter494:
          iter495.write(oprot)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.generic_exception is not None:
      oprot.writeFieldBegin('generic_exception', TType.STRUCT, 1)
      self.generic_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authorization_exception is not None:
      oprot.writeFieldBegin('authorization_exception', TType.STRUCT, 2)
      self.authorization_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authentication_exception is not None:
      oprot.writeFieldBegin('authentication_exception', TType.STRUCT, 3)
      self.authentication_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.reference_exception is not None:
      oprot.writeFieldBegin('reference_exception', TType.STRUCT, 4)
      self.reference_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.attribute_exception is not None:
      oprot.writeFieldBegin('attribute_exception', TType.STRUCT, 5)
      self.attribute_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.type_exception is not None:
      oprot.writeFieldBegin('type_exception', TType.STRUCT, 6)
      self.type_exception.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.generic_exception)
    value = (value * 31) ^ hash(self.authorization_exception)
    value = (value * 31) ^ hash(self.authentication_exception)
    value = (value * 31) ^ hash(self.reference_exception)
    value = (value * 31) ^ hash(self.attribute_exception)
    value = (value * 31) ^ hash(self.type_exception)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_mrna_utrs_args:
  """
  Attributes:
   - token
   - ref
   - mrna_id_list
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token', None, None, ), # 1
    (2, TType.STRING, 'ref', None, None, ), # 2
    (3, TType.LIST, 'mrna_id_list', (TType.STRING,None), None, ), # 3
  )

  def __init__(self, token=None, ref=None, mrna_id_list=None,):
    self.token = token
    self.ref = ref
    self.mrna_id_list = mrna_id_list

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ref = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.mrna_id_list = []
          (_etype499, _size496) = iprot.readListBegin()
          for _i500 in xrange(_size496):
            _elem501 = iprot.readString();
            self.mrna_id_list.append(_elem501)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_mrna_utrs_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 1)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    if self.ref is not None:
      oprot.writeFieldBegin('ref', TType.STRING, 2)
      oprot.writeString(self.ref)
      oprot.writeFieldEnd()
    if self.mrna_id_list is not None:
      oprot.writeFieldBegin('mrna_id_list', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.mrna_id_list))
      for iter502 in self.mrna_id_list:
        oprot.writeString(iter502)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.token is None:
      raise TProtocol.TProtocolException(message='Required field token is unset!')
    if self.ref is None:
      raise TProtocol.TProtocolException(message='Required field ref is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.token)
    value = (value * 31) ^ hash(self.ref)
    value = (value * 31) ^ hash(self.mrna_id_list)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_mrna_utrs_result:
  """
  Attributes:
   - success
   - generic_exception
   - authorization_exception
   - authentication_exception
   - reference_exception
   - attribute_exception
   - type_exception
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.MAP,(TType.STRING,None,TType.STRUCT,(UTR_data, UTR_data.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'generic_exception', (ServiceException, ServiceException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'authorization_exception', (AuthorizationException, AuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'authentication_exception', (AuthenticationException, AuthenticationException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'reference_exception', (ObjectReferenceException, ObjectReferenceException.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'attribute_exception', (AttributeException, AttributeException.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'type_exception', (TypeException, TypeException.thrift_spec), None, ), # 6
  )

  def __init__(self, success=None, generic_exception=None, authorization_exception=None, authentication_exception=None, reference_exception=None, attribute_exception=None, type_exception=None,):
    self.success = success
    self.generic_exception = generic_exception
    self.authorization_exception = authorization_exception
    self.authentication_exception = authentication_exception
    self.reference_exception = reference_exception
    self.attribute_exception = attribute_exception
    self.type_exception = type_exception

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype504, _vtype505, _size503 ) = iprot.readMapBegin()
          for _i507 in xrange(_size503):
            _key508 = iprot.readString();
            _val509 = {}
            (_ktype511, _vtype512, _size510 ) = iprot.readMapBegin()
            for _i514 in xrange(_size510):
              _key515 = iprot.readString();
              _val516 = UTR_data()
              _val516.read(iprot)
              _val509[_key515] = _val516
            iprot.readMapEnd()
            self.success[_key508] = _val509
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_exception = ServiceException()
          self.generic_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.authorization_exception = AuthorizationException()
          self.authorization_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.authentication_exception = AuthenticationException()
          self.authentication_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.reference_exception = ObjectReferenceException()
          self.reference_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.attribute_exception = AttributeException()
          self.attribute_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.type_exception = TypeException()
          self.type_exception.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_mrna_utrs_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.MAP, len(self.success))
      for kiter517,viter518 in self.success.items():
        oprot.writeString(kiter517)
        oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(viter518))
        for kiter519,viter520 in viter518.items():
          oprot.writeString(kiter519)
          viter520.write(oprot)
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.generic_exception is not None:
      oprot.writeFieldBegin('generic_exception', TType.STRUCT, 1)
      self.generic_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authorization_exception is not None:
      oprot.writeFieldBegin('authorization_exception', TType.STRUCT, 2)
      self.authorization_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authentication_exception is not None:
      oprot.writeFieldBegin('authentication_exception', TType.STRUCT, 3)
      self.authentication_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.reference_exception is not None:
      oprot.writeFieldBegin('reference_exception', TType.STRUCT, 4)
      self.reference_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.attribute_exception is not None:
      oprot.writeFieldBegin('attribute_exception', TType.STRUCT, 5)
      self.attribute_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.type_exception is not None:
      oprot.writeFieldBegin('type_exception', TType.STRUCT, 6)
      self.type_exception.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.generic_exception)
    value = (value * 31) ^ hash(self.authorization_exception)
    value = (value * 31) ^ hash(self.authentication_exception)
    value = (value * 31) ^ hash(self.reference_exception)
    value = (value * 31) ^ hash(self.attribute_exception)
    value = (value * 31) ^ hash(self.type_exception)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_gff_args:
  """
  Attributes:
   - token
   - ref
   - gene_id_list
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token', None, None, ), # 1
    (2, TType.STRING, 'ref', None, None, ), # 2
    (3, TType.LIST, 'gene_id_list', (TType.STRING,None), None, ), # 3
  )

  def __init__(self, token=None, ref=None, gene_id_list=None,):
    self.token = token
    self.ref = ref
    self.gene_id_list = gene_id_list

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ref = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.gene_id_list = []
          (_etype524, _size521) = iprot.readListBegin()
          for _i525 in xrange(_size521):
            _elem526 = iprot.readString();
            self.gene_id_list.append(_elem526)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_gff_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 1)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    if self.ref is not None:
      oprot.writeFieldBegin('ref', TType.STRING, 2)
      oprot.writeString(self.ref)
      oprot.writeFieldEnd()
    if self.gene_id_list is not None:
      oprot.writeFieldBegin('gene_id_list', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.gene_id_list))
      for iter527 in self.gene_id_list:
        oprot.writeString(iter527)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.token is None:
      raise TProtocol.TProtocolException(message='Required field token is unset!')
    if self.ref is None:
      raise TProtocol.TProtocolException(message='Required field ref is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.token)
    value = (value * 31) ^ hash(self.ref)
    value = (value * 31) ^ hash(self.gene_id_list)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_gff_result:
  """
  Attributes:
   - success
   - generic_exception
   - authorization_exception
   - authentication_exception
   - reference_exception
   - attribute_exception
   - type_exception
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'generic_exception', (ServiceException, ServiceException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'authorization_exception', (AuthorizationException, AuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'authentication_exception', (AuthenticationException, AuthenticationException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'reference_exception', (ObjectReferenceException, ObjectReferenceException.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'attribute_exception', (AttributeException, AttributeException.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'type_exception', (TypeException, TypeException.thrift_spec), None, ), # 6
  )

  def __init__(self, success=None, generic_exception=None, authorization_exception=None, authentication_exception=None, reference_exception=None, attribute_exception=None, type_exception=None,):
    self.success = success
    self.generic_exception = generic_exception
    self.authorization_exception = authorization_exception
    self.authentication_exception = authentication_exception
    self.reference_exception = reference_exception
    self.attribute_exception = attribute_exception
    self.type_exception = type_exception

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_exception = ServiceException()
          self.generic_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.authorization_exception = AuthorizationException()
          self.authorization_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.authentication_exception = AuthenticationException()
          self.authentication_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.reference_exception = ObjectReferenceException()
          self.reference_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.attribute_exception = AttributeException()
          self.attribute_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.type_exception = TypeException()
          self.type_exception.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_gff_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.generic_exception is not None:
      oprot.writeFieldBegin('generic_exception', TType.STRUCT, 1)
      self.generic_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authorization_exception is not None:
      oprot.writeFieldBegin('authorization_exception', TType.STRUCT, 2)
      self.authorization_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authentication_exception is not None:
      oprot.writeFieldBegin('authentication_exception', TType.STRUCT, 3)
      self.authentication_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.reference_exception is not None:
      oprot.writeFieldBegin('reference_exception', TType.STRUCT, 4)
      self.reference_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.attribute_exception is not None:
      oprot.writeFieldBegin('attribute_exception', TType.STRUCT, 5)
      self.attribute_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.type_exception is not None:
      oprot.writeFieldBegin('type_exception', TType.STRUCT, 6)
      self.type_exception.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.generic_exception)
    value = (value * 31) ^ hash(self.authorization_exception)
    value = (value * 31) ^ hash(self.authentication_exception)
    value = (value * 31) ^ hash(self.reference_exception)
    value = (value * 31) ^ hash(self.attribute_exception)
    value = (value * 31) ^ hash(self.type_exception)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
