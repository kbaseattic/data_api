#
# Autogenerated by Thrift Compiler (0.9.2)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:twisted
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
from ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None

from zope.interface import Interface, implements
from twisted.internet import defer
from thrift.transport import TTwisted

class Iface(Interface):
  def get_assembly_id(token, ref):
    """
    Retrieve Assembly identifier string.


    Parameters:
     - token
     - ref
    """
    pass

  def get_genome_annotations(token, ref):
    """
    Retrieve associated GenomeAnnotation objects.


    Parameters:
     - token
     - ref
    """
    pass

  def get_external_source_info(token, ref):
    """
    Retrieve the external source information for this Assembly.


    Parameters:
     - token
     - ref
    """
    pass

  def get_stats(token, ref):
    """
    Retrieve the Assembly stats.


    Parameters:
     - token
     - ref
    """
    pass

  def get_number_contigs(token, ref):
    """
    Retrieve the number of contigs for this Assembly.


    Parameters:
     - token
     - ref
    """
    pass

  def get_gc_content(token, ref):
    """
    Retrieve the total GC content for this Assembly.


    Parameters:
     - token
     - ref
    """
    pass

  def get_dna_size(token, ref):
    """
    Retrieve the total DNA size for this Assembly.


    Parameters:
     - token
     - ref
    """
    pass

  def get_contig_ids(token, ref):
    """
    Retrieve the contig identifiers for this Assembly.


    Parameters:
     - token
     - ref
    """
    pass

  def get_contig_lengths(token, ref, contig_id_list):
    """
    Retrieve the lengths of the contigs in this Assembly.


    Parameters:
     - token
     - ref
     - contig_id_list
    """
    pass

  def get_contig_gc_content(token, ref, contig_id_list):
    """
    Retrieve the gc content for contigs in this Assembly.


    Parameters:
     - token
     - ref
     - contig_id_list
    """
    pass

  def get_contigs(token, ref, contig_id_list):
    """
    Retrieve all the data for the contigs in this Assembly.


    Parameters:
     - token
     - ref
     - contig_id_list
    """
    pass


class Client:
  implements(Iface)

  def __init__(self, transport, oprot_factory):
    self._transport = transport
    self._oprot_factory = oprot_factory
    self._seqid = 0
    self._reqs = {}

  def get_assembly_id(self, token, ref):
    """
    Retrieve Assembly identifier string.


    Parameters:
     - token
     - ref
    """
    seqid = self._seqid = self._seqid + 1
    self._reqs[seqid] = defer.Deferred()

    d = defer.maybeDeferred(self.send_get_assembly_id, token, ref)
    d.addCallbacks(
      callback=self.cb_send_get_assembly_id,
      callbackArgs=(seqid,),
      errback=self.eb_send_get_assembly_id,
      errbackArgs=(seqid,))
    return d

  def cb_send_get_assembly_id(self, _, seqid):
    return self._reqs[seqid]

  def eb_send_get_assembly_id(self, f, seqid):
    d = self._reqs.pop(seqid)
    d.errback(f)
    return d

  def send_get_assembly_id(self, token, ref):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('get_assembly_id', TMessageType.CALL, self._seqid)
    args = get_assembly_id_args()
    args.token = token
    args.ref = ref
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_get_assembly_id(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = get_assembly_id_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    if result.generic_exception is not None:
      return d.errback(result.generic_exception)
    if result.authorization_exception is not None:
      return d.errback(result.authorization_exception)
    if result.authentication_exception is not None:
      return d.errback(result.authentication_exception)
    if result.reference_exception is not None:
      return d.errback(result.reference_exception)
    if result.attribute_exception is not None:
      return d.errback(result.attribute_exception)
    if result.type_exception is not None:
      return d.errback(result.type_exception)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "get_assembly_id failed: unknown result"))

  def get_genome_annotations(self, token, ref):
    """
    Retrieve associated GenomeAnnotation objects.


    Parameters:
     - token
     - ref
    """
    seqid = self._seqid = self._seqid + 1
    self._reqs[seqid] = defer.Deferred()

    d = defer.maybeDeferred(self.send_get_genome_annotations, token, ref)
    d.addCallbacks(
      callback=self.cb_send_get_genome_annotations,
      callbackArgs=(seqid,),
      errback=self.eb_send_get_genome_annotations,
      errbackArgs=(seqid,))
    return d

  def cb_send_get_genome_annotations(self, _, seqid):
    return self._reqs[seqid]

  def eb_send_get_genome_annotations(self, f, seqid):
    d = self._reqs.pop(seqid)
    d.errback(f)
    return d

  def send_get_genome_annotations(self, token, ref):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('get_genome_annotations', TMessageType.CALL, self._seqid)
    args = get_genome_annotations_args()
    args.token = token
    args.ref = ref
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_get_genome_annotations(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = get_genome_annotations_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    if result.generic_exception is not None:
      return d.errback(result.generic_exception)
    if result.authorization_exception is not None:
      return d.errback(result.authorization_exception)
    if result.authentication_exception is not None:
      return d.errback(result.authentication_exception)
    if result.reference_exception is not None:
      return d.errback(result.reference_exception)
    if result.attribute_exception is not None:
      return d.errback(result.attribute_exception)
    if result.type_exception is not None:
      return d.errback(result.type_exception)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "get_genome_annotations failed: unknown result"))

  def get_external_source_info(self, token, ref):
    """
    Retrieve the external source information for this Assembly.


    Parameters:
     - token
     - ref
    """
    seqid = self._seqid = self._seqid + 1
    self._reqs[seqid] = defer.Deferred()

    d = defer.maybeDeferred(self.send_get_external_source_info, token, ref)
    d.addCallbacks(
      callback=self.cb_send_get_external_source_info,
      callbackArgs=(seqid,),
      errback=self.eb_send_get_external_source_info,
      errbackArgs=(seqid,))
    return d

  def cb_send_get_external_source_info(self, _, seqid):
    return self._reqs[seqid]

  def eb_send_get_external_source_info(self, f, seqid):
    d = self._reqs.pop(seqid)
    d.errback(f)
    return d

  def send_get_external_source_info(self, token, ref):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('get_external_source_info', TMessageType.CALL, self._seqid)
    args = get_external_source_info_args()
    args.token = token
    args.ref = ref
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_get_external_source_info(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = get_external_source_info_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    if result.generic_exception is not None:
      return d.errback(result.generic_exception)
    if result.authorization_exception is not None:
      return d.errback(result.authorization_exception)
    if result.authentication_exception is not None:
      return d.errback(result.authentication_exception)
    if result.reference_exception is not None:
      return d.errback(result.reference_exception)
    if result.attribute_exception is not None:
      return d.errback(result.attribute_exception)
    if result.type_exception is not None:
      return d.errback(result.type_exception)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "get_external_source_info failed: unknown result"))

  def get_stats(self, token, ref):
    """
    Retrieve the Assembly stats.


    Parameters:
     - token
     - ref
    """
    seqid = self._seqid = self._seqid + 1
    self._reqs[seqid] = defer.Deferred()

    d = defer.maybeDeferred(self.send_get_stats, token, ref)
    d.addCallbacks(
      callback=self.cb_send_get_stats,
      callbackArgs=(seqid,),
      errback=self.eb_send_get_stats,
      errbackArgs=(seqid,))
    return d

  def cb_send_get_stats(self, _, seqid):
    return self._reqs[seqid]

  def eb_send_get_stats(self, f, seqid):
    d = self._reqs.pop(seqid)
    d.errback(f)
    return d

  def send_get_stats(self, token, ref):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('get_stats', TMessageType.CALL, self._seqid)
    args = get_stats_args()
    args.token = token
    args.ref = ref
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_get_stats(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = get_stats_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    if result.generic_exception is not None:
      return d.errback(result.generic_exception)
    if result.authorization_exception is not None:
      return d.errback(result.authorization_exception)
    if result.authentication_exception is not None:
      return d.errback(result.authentication_exception)
    if result.reference_exception is not None:
      return d.errback(result.reference_exception)
    if result.attribute_exception is not None:
      return d.errback(result.attribute_exception)
    if result.type_exception is not None:
      return d.errback(result.type_exception)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "get_stats failed: unknown result"))

  def get_number_contigs(self, token, ref):
    """
    Retrieve the number of contigs for this Assembly.


    Parameters:
     - token
     - ref
    """
    seqid = self._seqid = self._seqid + 1
    self._reqs[seqid] = defer.Deferred()

    d = defer.maybeDeferred(self.send_get_number_contigs, token, ref)
    d.addCallbacks(
      callback=self.cb_send_get_number_contigs,
      callbackArgs=(seqid,),
      errback=self.eb_send_get_number_contigs,
      errbackArgs=(seqid,))
    return d

  def cb_send_get_number_contigs(self, _, seqid):
    return self._reqs[seqid]

  def eb_send_get_number_contigs(self, f, seqid):
    d = self._reqs.pop(seqid)
    d.errback(f)
    return d

  def send_get_number_contigs(self, token, ref):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('get_number_contigs', TMessageType.CALL, self._seqid)
    args = get_number_contigs_args()
    args.token = token
    args.ref = ref
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_get_number_contigs(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = get_number_contigs_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    if result.generic_exception is not None:
      return d.errback(result.generic_exception)
    if result.authorization_exception is not None:
      return d.errback(result.authorization_exception)
    if result.authentication_exception is not None:
      return d.errback(result.authentication_exception)
    if result.reference_exception is not None:
      return d.errback(result.reference_exception)
    if result.attribute_exception is not None:
      return d.errback(result.attribute_exception)
    if result.type_exception is not None:
      return d.errback(result.type_exception)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "get_number_contigs failed: unknown result"))

  def get_gc_content(self, token, ref):
    """
    Retrieve the total GC content for this Assembly.


    Parameters:
     - token
     - ref
    """
    seqid = self._seqid = self._seqid + 1
    self._reqs[seqid] = defer.Deferred()

    d = defer.maybeDeferred(self.send_get_gc_content, token, ref)
    d.addCallbacks(
      callback=self.cb_send_get_gc_content,
      callbackArgs=(seqid,),
      errback=self.eb_send_get_gc_content,
      errbackArgs=(seqid,))
    return d

  def cb_send_get_gc_content(self, _, seqid):
    return self._reqs[seqid]

  def eb_send_get_gc_content(self, f, seqid):
    d = self._reqs.pop(seqid)
    d.errback(f)
    return d

  def send_get_gc_content(self, token, ref):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('get_gc_content', TMessageType.CALL, self._seqid)
    args = get_gc_content_args()
    args.token = token
    args.ref = ref
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_get_gc_content(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = get_gc_content_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    if result.generic_exception is not None:
      return d.errback(result.generic_exception)
    if result.authorization_exception is not None:
      return d.errback(result.authorization_exception)
    if result.authentication_exception is not None:
      return d.errback(result.authentication_exception)
    if result.reference_exception is not None:
      return d.errback(result.reference_exception)
    if result.attribute_exception is not None:
      return d.errback(result.attribute_exception)
    if result.type_exception is not None:
      return d.errback(result.type_exception)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "get_gc_content failed: unknown result"))

  def get_dna_size(self, token, ref):
    """
    Retrieve the total DNA size for this Assembly.


    Parameters:
     - token
     - ref
    """
    seqid = self._seqid = self._seqid + 1
    self._reqs[seqid] = defer.Deferred()

    d = defer.maybeDeferred(self.send_get_dna_size, token, ref)
    d.addCallbacks(
      callback=self.cb_send_get_dna_size,
      callbackArgs=(seqid,),
      errback=self.eb_send_get_dna_size,
      errbackArgs=(seqid,))
    return d

  def cb_send_get_dna_size(self, _, seqid):
    return self._reqs[seqid]

  def eb_send_get_dna_size(self, f, seqid):
    d = self._reqs.pop(seqid)
    d.errback(f)
    return d

  def send_get_dna_size(self, token, ref):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('get_dna_size', TMessageType.CALL, self._seqid)
    args = get_dna_size_args()
    args.token = token
    args.ref = ref
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_get_dna_size(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = get_dna_size_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    if result.generic_exception is not None:
      return d.errback(result.generic_exception)
    if result.authorization_exception is not None:
      return d.errback(result.authorization_exception)
    if result.authentication_exception is not None:
      return d.errback(result.authentication_exception)
    if result.reference_exception is not None:
      return d.errback(result.reference_exception)
    if result.attribute_exception is not None:
      return d.errback(result.attribute_exception)
    if result.type_exception is not None:
      return d.errback(result.type_exception)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "get_dna_size failed: unknown result"))

  def get_contig_ids(self, token, ref):
    """
    Retrieve the contig identifiers for this Assembly.


    Parameters:
     - token
     - ref
    """
    seqid = self._seqid = self._seqid + 1
    self._reqs[seqid] = defer.Deferred()

    d = defer.maybeDeferred(self.send_get_contig_ids, token, ref)
    d.addCallbacks(
      callback=self.cb_send_get_contig_ids,
      callbackArgs=(seqid,),
      errback=self.eb_send_get_contig_ids,
      errbackArgs=(seqid,))
    return d

  def cb_send_get_contig_ids(self, _, seqid):
    return self._reqs[seqid]

  def eb_send_get_contig_ids(self, f, seqid):
    d = self._reqs.pop(seqid)
    d.errback(f)
    return d

  def send_get_contig_ids(self, token, ref):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('get_contig_ids', TMessageType.CALL, self._seqid)
    args = get_contig_ids_args()
    args.token = token
    args.ref = ref
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_get_contig_ids(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = get_contig_ids_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    if result.generic_exception is not None:
      return d.errback(result.generic_exception)
    if result.authorization_exception is not None:
      return d.errback(result.authorization_exception)
    if result.authentication_exception is not None:
      return d.errback(result.authentication_exception)
    if result.reference_exception is not None:
      return d.errback(result.reference_exception)
    if result.attribute_exception is not None:
      return d.errback(result.attribute_exception)
    if result.type_exception is not None:
      return d.errback(result.type_exception)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "get_contig_ids failed: unknown result"))

  def get_contig_lengths(self, token, ref, contig_id_list):
    """
    Retrieve the lengths of the contigs in this Assembly.


    Parameters:
     - token
     - ref
     - contig_id_list
    """
    seqid = self._seqid = self._seqid + 1
    self._reqs[seqid] = defer.Deferred()

    d = defer.maybeDeferred(self.send_get_contig_lengths, token, ref, contig_id_list)
    d.addCallbacks(
      callback=self.cb_send_get_contig_lengths,
      callbackArgs=(seqid,),
      errback=self.eb_send_get_contig_lengths,
      errbackArgs=(seqid,))
    return d

  def cb_send_get_contig_lengths(self, _, seqid):
    return self._reqs[seqid]

  def eb_send_get_contig_lengths(self, f, seqid):
    d = self._reqs.pop(seqid)
    d.errback(f)
    return d

  def send_get_contig_lengths(self, token, ref, contig_id_list):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('get_contig_lengths', TMessageType.CALL, self._seqid)
    args = get_contig_lengths_args()
    args.token = token
    args.ref = ref
    args.contig_id_list = contig_id_list
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_get_contig_lengths(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = get_contig_lengths_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    if result.generic_exception is not None:
      return d.errback(result.generic_exception)
    if result.authorization_exception is not None:
      return d.errback(result.authorization_exception)
    if result.authentication_exception is not None:
      return d.errback(result.authentication_exception)
    if result.reference_exception is not None:
      return d.errback(result.reference_exception)
    if result.attribute_exception is not None:
      return d.errback(result.attribute_exception)
    if result.type_exception is not None:
      return d.errback(result.type_exception)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "get_contig_lengths failed: unknown result"))

  def get_contig_gc_content(self, token, ref, contig_id_list):
    """
    Retrieve the gc content for contigs in this Assembly.


    Parameters:
     - token
     - ref
     - contig_id_list
    """
    seqid = self._seqid = self._seqid + 1
    self._reqs[seqid] = defer.Deferred()

    d = defer.maybeDeferred(self.send_get_contig_gc_content, token, ref, contig_id_list)
    d.addCallbacks(
      callback=self.cb_send_get_contig_gc_content,
      callbackArgs=(seqid,),
      errback=self.eb_send_get_contig_gc_content,
      errbackArgs=(seqid,))
    return d

  def cb_send_get_contig_gc_content(self, _, seqid):
    return self._reqs[seqid]

  def eb_send_get_contig_gc_content(self, f, seqid):
    d = self._reqs.pop(seqid)
    d.errback(f)
    return d

  def send_get_contig_gc_content(self, token, ref, contig_id_list):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('get_contig_gc_content', TMessageType.CALL, self._seqid)
    args = get_contig_gc_content_args()
    args.token = token
    args.ref = ref
    args.contig_id_list = contig_id_list
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_get_contig_gc_content(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = get_contig_gc_content_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    if result.generic_exception is not None:
      return d.errback(result.generic_exception)
    if result.authorization_exception is not None:
      return d.errback(result.authorization_exception)
    if result.authentication_exception is not None:
      return d.errback(result.authentication_exception)
    if result.reference_exception is not None:
      return d.errback(result.reference_exception)
    if result.attribute_exception is not None:
      return d.errback(result.attribute_exception)
    if result.type_exception is not None:
      return d.errback(result.type_exception)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "get_contig_gc_content failed: unknown result"))

  def get_contigs(self, token, ref, contig_id_list):
    """
    Retrieve all the data for the contigs in this Assembly.


    Parameters:
     - token
     - ref
     - contig_id_list
    """
    seqid = self._seqid = self._seqid + 1
    self._reqs[seqid] = defer.Deferred()

    d = defer.maybeDeferred(self.send_get_contigs, token, ref, contig_id_list)
    d.addCallbacks(
      callback=self.cb_send_get_contigs,
      callbackArgs=(seqid,),
      errback=self.eb_send_get_contigs,
      errbackArgs=(seqid,))
    return d

  def cb_send_get_contigs(self, _, seqid):
    return self._reqs[seqid]

  def eb_send_get_contigs(self, f, seqid):
    d = self._reqs.pop(seqid)
    d.errback(f)
    return d

  def send_get_contigs(self, token, ref, contig_id_list):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('get_contigs', TMessageType.CALL, self._seqid)
    args = get_contigs_args()
    args.token = token
    args.ref = ref
    args.contig_id_list = contig_id_list
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_get_contigs(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = get_contigs_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    if result.generic_exception is not None:
      return d.errback(result.generic_exception)
    if result.authorization_exception is not None:
      return d.errback(result.authorization_exception)
    if result.authentication_exception is not None:
      return d.errback(result.authentication_exception)
    if result.reference_exception is not None:
      return d.errback(result.reference_exception)
    if result.attribute_exception is not None:
      return d.errback(result.attribute_exception)
    if result.type_exception is not None:
      return d.errback(result.type_exception)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "get_contigs failed: unknown result"))


class Processor(TProcessor):
  implements(Iface)

  def __init__(self, handler):
    self._handler = Iface(handler)
    self._processMap = {}
    self._processMap["get_assembly_id"] = Processor.process_get_assembly_id
    self._processMap["get_genome_annotations"] = Processor.process_get_genome_annotations
    self._processMap["get_external_source_info"] = Processor.process_get_external_source_info
    self._processMap["get_stats"] = Processor.process_get_stats
    self._processMap["get_number_contigs"] = Processor.process_get_number_contigs
    self._processMap["get_gc_content"] = Processor.process_get_gc_content
    self._processMap["get_dna_size"] = Processor.process_get_dna_size
    self._processMap["get_contig_ids"] = Processor.process_get_contig_ids
    self._processMap["get_contig_lengths"] = Processor.process_get_contig_lengths
    self._processMap["get_contig_gc_content"] = Processor.process_get_contig_gc_content
    self._processMap["get_contigs"] = Processor.process_get_contigs

  def process(self, iprot, oprot):
    (name, type, seqid) = iprot.readMessageBegin()
    if name not in self._processMap:
      iprot.skip(TType.STRUCT)
      iprot.readMessageEnd()
      x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
      oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
      x.write(oprot)
      oprot.writeMessageEnd()
      oprot.trans.flush()
      return defer.succeed(None)
    else:
      return self._processMap[name](self, seqid, iprot, oprot)

  def process_get_assembly_id(self, seqid, iprot, oprot):
    args = get_assembly_id_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_assembly_id_result()
    d = defer.maybeDeferred(self._handler.get_assembly_id, args.token, args.ref)
    d.addCallback(self.write_results_success_get_assembly_id, result, seqid, oprot)
    d.addErrback(self.write_results_exception_get_assembly_id, result, seqid, oprot)
    return d

  def write_results_success_get_assembly_id(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("get_assembly_id", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def write_results_exception_get_assembly_id(self, error, result, seqid, oprot):
    try:
      error.raiseException()
    except ServiceException, generic_exception:
      result.generic_exception = generic_exception
    except AuthorizationException, authorization_exception:
      result.authorization_exception = authorization_exception
    except AuthenticationException, authentication_exception:
      result.authentication_exception = authentication_exception
    except ObjectReferenceException, reference_exception:
      result.reference_exception = reference_exception
    except AttributeException, attribute_exception:
      result.attribute_exception = attribute_exception
    except TypeException, type_exception:
      result.type_exception = type_exception
    oprot.writeMessageBegin("get_assembly_id", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_genome_annotations(self, seqid, iprot, oprot):
    args = get_genome_annotations_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_genome_annotations_result()
    d = defer.maybeDeferred(self._handler.get_genome_annotations, args.token, args.ref)
    d.addCallback(self.write_results_success_get_genome_annotations, result, seqid, oprot)
    d.addErrback(self.write_results_exception_get_genome_annotations, result, seqid, oprot)
    return d

  def write_results_success_get_genome_annotations(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("get_genome_annotations", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def write_results_exception_get_genome_annotations(self, error, result, seqid, oprot):
    try:
      error.raiseException()
    except ServiceException, generic_exception:
      result.generic_exception = generic_exception
    except AuthorizationException, authorization_exception:
      result.authorization_exception = authorization_exception
    except AuthenticationException, authentication_exception:
      result.authentication_exception = authentication_exception
    except ObjectReferenceException, reference_exception:
      result.reference_exception = reference_exception
    except AttributeException, attribute_exception:
      result.attribute_exception = attribute_exception
    except TypeException, type_exception:
      result.type_exception = type_exception
    oprot.writeMessageBegin("get_genome_annotations", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_external_source_info(self, seqid, iprot, oprot):
    args = get_external_source_info_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_external_source_info_result()
    d = defer.maybeDeferred(self._handler.get_external_source_info, args.token, args.ref)
    d.addCallback(self.write_results_success_get_external_source_info, result, seqid, oprot)
    d.addErrback(self.write_results_exception_get_external_source_info, result, seqid, oprot)
    return d

  def write_results_success_get_external_source_info(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("get_external_source_info", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def write_results_exception_get_external_source_info(self, error, result, seqid, oprot):
    try:
      error.raiseException()
    except ServiceException, generic_exception:
      result.generic_exception = generic_exception
    except AuthorizationException, authorization_exception:
      result.authorization_exception = authorization_exception
    except AuthenticationException, authentication_exception:
      result.authentication_exception = authentication_exception
    except ObjectReferenceException, reference_exception:
      result.reference_exception = reference_exception
    except AttributeException, attribute_exception:
      result.attribute_exception = attribute_exception
    except TypeException, type_exception:
      result.type_exception = type_exception
    oprot.writeMessageBegin("get_external_source_info", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_stats(self, seqid, iprot, oprot):
    args = get_stats_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_stats_result()
    d = defer.maybeDeferred(self._handler.get_stats, args.token, args.ref)
    d.addCallback(self.write_results_success_get_stats, result, seqid, oprot)
    d.addErrback(self.write_results_exception_get_stats, result, seqid, oprot)
    return d

  def write_results_success_get_stats(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("get_stats", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def write_results_exception_get_stats(self, error, result, seqid, oprot):
    try:
      error.raiseException()
    except ServiceException, generic_exception:
      result.generic_exception = generic_exception
    except AuthorizationException, authorization_exception:
      result.authorization_exception = authorization_exception
    except AuthenticationException, authentication_exception:
      result.authentication_exception = authentication_exception
    except ObjectReferenceException, reference_exception:
      result.reference_exception = reference_exception
    except AttributeException, attribute_exception:
      result.attribute_exception = attribute_exception
    except TypeException, type_exception:
      result.type_exception = type_exception
    oprot.writeMessageBegin("get_stats", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_number_contigs(self, seqid, iprot, oprot):
    args = get_number_contigs_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_number_contigs_result()
    d = defer.maybeDeferred(self._handler.get_number_contigs, args.token, args.ref)
    d.addCallback(self.write_results_success_get_number_contigs, result, seqid, oprot)
    d.addErrback(self.write_results_exception_get_number_contigs, result, seqid, oprot)
    return d

  def write_results_success_get_number_contigs(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("get_number_contigs", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def write_results_exception_get_number_contigs(self, error, result, seqid, oprot):
    try:
      error.raiseException()
    except ServiceException, generic_exception:
      result.generic_exception = generic_exception
    except AuthorizationException, authorization_exception:
      result.authorization_exception = authorization_exception
    except AuthenticationException, authentication_exception:
      result.authentication_exception = authentication_exception
    except ObjectReferenceException, reference_exception:
      result.reference_exception = reference_exception
    except AttributeException, attribute_exception:
      result.attribute_exception = attribute_exception
    except TypeException, type_exception:
      result.type_exception = type_exception
    oprot.writeMessageBegin("get_number_contigs", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_gc_content(self, seqid, iprot, oprot):
    args = get_gc_content_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_gc_content_result()
    d = defer.maybeDeferred(self._handler.get_gc_content, args.token, args.ref)
    d.addCallback(self.write_results_success_get_gc_content, result, seqid, oprot)
    d.addErrback(self.write_results_exception_get_gc_content, result, seqid, oprot)
    return d

  def write_results_success_get_gc_content(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("get_gc_content", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def write_results_exception_get_gc_content(self, error, result, seqid, oprot):
    try:
      error.raiseException()
    except ServiceException, generic_exception:
      result.generic_exception = generic_exception
    except AuthorizationException, authorization_exception:
      result.authorization_exception = authorization_exception
    except AuthenticationException, authentication_exception:
      result.authentication_exception = authentication_exception
    except ObjectReferenceException, reference_exception:
      result.reference_exception = reference_exception
    except AttributeException, attribute_exception:
      result.attribute_exception = attribute_exception
    except TypeException, type_exception:
      result.type_exception = type_exception
    oprot.writeMessageBegin("get_gc_content", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_dna_size(self, seqid, iprot, oprot):
    args = get_dna_size_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_dna_size_result()
    d = defer.maybeDeferred(self._handler.get_dna_size, args.token, args.ref)
    d.addCallback(self.write_results_success_get_dna_size, result, seqid, oprot)
    d.addErrback(self.write_results_exception_get_dna_size, result, seqid, oprot)
    return d

  def write_results_success_get_dna_size(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("get_dna_size", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def write_results_exception_get_dna_size(self, error, result, seqid, oprot):
    try:
      error.raiseException()
    except ServiceException, generic_exception:
      result.generic_exception = generic_exception
    except AuthorizationException, authorization_exception:
      result.authorization_exception = authorization_exception
    except AuthenticationException, authentication_exception:
      result.authentication_exception = authentication_exception
    except ObjectReferenceException, reference_exception:
      result.reference_exception = reference_exception
    except AttributeException, attribute_exception:
      result.attribute_exception = attribute_exception
    except TypeException, type_exception:
      result.type_exception = type_exception
    oprot.writeMessageBegin("get_dna_size", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_contig_ids(self, seqid, iprot, oprot):
    args = get_contig_ids_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_contig_ids_result()
    d = defer.maybeDeferred(self._handler.get_contig_ids, args.token, args.ref)
    d.addCallback(self.write_results_success_get_contig_ids, result, seqid, oprot)
    d.addErrback(self.write_results_exception_get_contig_ids, result, seqid, oprot)
    return d

  def write_results_success_get_contig_ids(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("get_contig_ids", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def write_results_exception_get_contig_ids(self, error, result, seqid, oprot):
    try:
      error.raiseException()
    except ServiceException, generic_exception:
      result.generic_exception = generic_exception
    except AuthorizationException, authorization_exception:
      result.authorization_exception = authorization_exception
    except AuthenticationException, authentication_exception:
      result.authentication_exception = authentication_exception
    except ObjectReferenceException, reference_exception:
      result.reference_exception = reference_exception
    except AttributeException, attribute_exception:
      result.attribute_exception = attribute_exception
    except TypeException, type_exception:
      result.type_exception = type_exception
    oprot.writeMessageBegin("get_contig_ids", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_contig_lengths(self, seqid, iprot, oprot):
    args = get_contig_lengths_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_contig_lengths_result()
    d = defer.maybeDeferred(self._handler.get_contig_lengths, args.token, args.ref, args.contig_id_list)
    d.addCallback(self.write_results_success_get_contig_lengths, result, seqid, oprot)
    d.addErrback(self.write_results_exception_get_contig_lengths, result, seqid, oprot)
    return d

  def write_results_success_get_contig_lengths(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("get_contig_lengths", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def write_results_exception_get_contig_lengths(self, error, result, seqid, oprot):
    try:
      error.raiseException()
    except ServiceException, generic_exception:
      result.generic_exception = generic_exception
    except AuthorizationException, authorization_exception:
      result.authorization_exception = authorization_exception
    except AuthenticationException, authentication_exception:
      result.authentication_exception = authentication_exception
    except ObjectReferenceException, reference_exception:
      result.reference_exception = reference_exception
    except AttributeException, attribute_exception:
      result.attribute_exception = attribute_exception
    except TypeException, type_exception:
      result.type_exception = type_exception
    oprot.writeMessageBegin("get_contig_lengths", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_contig_gc_content(self, seqid, iprot, oprot):
    args = get_contig_gc_content_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_contig_gc_content_result()
    d = defer.maybeDeferred(self._handler.get_contig_gc_content, args.token, args.ref, args.contig_id_list)
    d.addCallback(self.write_results_success_get_contig_gc_content, result, seqid, oprot)
    d.addErrback(self.write_results_exception_get_contig_gc_content, result, seqid, oprot)
    return d

  def write_results_success_get_contig_gc_content(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("get_contig_gc_content", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def write_results_exception_get_contig_gc_content(self, error, result, seqid, oprot):
    try:
      error.raiseException()
    except ServiceException, generic_exception:
      result.generic_exception = generic_exception
    except AuthorizationException, authorization_exception:
      result.authorization_exception = authorization_exception
    except AuthenticationException, authentication_exception:
      result.authentication_exception = authentication_exception
    except ObjectReferenceException, reference_exception:
      result.reference_exception = reference_exception
    except AttributeException, attribute_exception:
      result.attribute_exception = attribute_exception
    except TypeException, type_exception:
      result.type_exception = type_exception
    oprot.writeMessageBegin("get_contig_gc_content", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_contigs(self, seqid, iprot, oprot):
    args = get_contigs_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_contigs_result()
    d = defer.maybeDeferred(self._handler.get_contigs, args.token, args.ref, args.contig_id_list)
    d.addCallback(self.write_results_success_get_contigs, result, seqid, oprot)
    d.addErrback(self.write_results_exception_get_contigs, result, seqid, oprot)
    return d

  def write_results_success_get_contigs(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("get_contigs", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def write_results_exception_get_contigs(self, error, result, seqid, oprot):
    try:
      error.raiseException()
    except ServiceException, generic_exception:
      result.generic_exception = generic_exception
    except AuthorizationException, authorization_exception:
      result.authorization_exception = authorization_exception
    except AuthenticationException, authentication_exception:
      result.authentication_exception = authentication_exception
    except ObjectReferenceException, reference_exception:
      result.reference_exception = reference_exception
    except AttributeException, attribute_exception:
      result.attribute_exception = attribute_exception
    except TypeException, type_exception:
      result.type_exception = type_exception
    oprot.writeMessageBegin("get_contigs", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()


# HELPER FUNCTIONS AND STRUCTURES

class get_assembly_id_args:
  """
  Attributes:
   - token
   - ref
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token', None, None, ), # 1
    (2, TType.STRING, 'ref', None, None, ), # 2
  )

  def __init__(self, token=None, ref=None,):
    self.token = token
    self.ref = ref

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ref = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_assembly_id_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 1)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    if self.ref is not None:
      oprot.writeFieldBegin('ref', TType.STRING, 2)
      oprot.writeString(self.ref)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.token is None:
      raise TProtocol.TProtocolException(message='Required field token is unset!')
    if self.ref is None:
      raise TProtocol.TProtocolException(message='Required field ref is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.token)
    value = (value * 31) ^ hash(self.ref)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_assembly_id_result:
  """
  Attributes:
   - success
   - generic_exception
   - authorization_exception
   - authentication_exception
   - reference_exception
   - attribute_exception
   - type_exception
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'generic_exception', (ServiceException, ServiceException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'authorization_exception', (AuthorizationException, AuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'authentication_exception', (AuthenticationException, AuthenticationException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'reference_exception', (ObjectReferenceException, ObjectReferenceException.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'attribute_exception', (AttributeException, AttributeException.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'type_exception', (TypeException, TypeException.thrift_spec), None, ), # 6
  )

  def __init__(self, success=None, generic_exception=None, authorization_exception=None, authentication_exception=None, reference_exception=None, attribute_exception=None, type_exception=None,):
    self.success = success
    self.generic_exception = generic_exception
    self.authorization_exception = authorization_exception
    self.authentication_exception = authentication_exception
    self.reference_exception = reference_exception
    self.attribute_exception = attribute_exception
    self.type_exception = type_exception

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_exception = ServiceException()
          self.generic_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.authorization_exception = AuthorizationException()
          self.authorization_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.authentication_exception = AuthenticationException()
          self.authentication_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.reference_exception = ObjectReferenceException()
          self.reference_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.attribute_exception = AttributeException()
          self.attribute_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.type_exception = TypeException()
          self.type_exception.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_assembly_id_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.generic_exception is not None:
      oprot.writeFieldBegin('generic_exception', TType.STRUCT, 1)
      self.generic_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authorization_exception is not None:
      oprot.writeFieldBegin('authorization_exception', TType.STRUCT, 2)
      self.authorization_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authentication_exception is not None:
      oprot.writeFieldBegin('authentication_exception', TType.STRUCT, 3)
      self.authentication_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.reference_exception is not None:
      oprot.writeFieldBegin('reference_exception', TType.STRUCT, 4)
      self.reference_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.attribute_exception is not None:
      oprot.writeFieldBegin('attribute_exception', TType.STRUCT, 5)
      self.attribute_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.type_exception is not None:
      oprot.writeFieldBegin('type_exception', TType.STRUCT, 6)
      self.type_exception.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.generic_exception)
    value = (value * 31) ^ hash(self.authorization_exception)
    value = (value * 31) ^ hash(self.authentication_exception)
    value = (value * 31) ^ hash(self.reference_exception)
    value = (value * 31) ^ hash(self.attribute_exception)
    value = (value * 31) ^ hash(self.type_exception)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_genome_annotations_args:
  """
  Attributes:
   - token
   - ref
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token', None, None, ), # 1
    (2, TType.STRING, 'ref', None, None, ), # 2
  )

  def __init__(self, token=None, ref=None,):
    self.token = token
    self.ref = ref

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ref = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_genome_annotations_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 1)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    if self.ref is not None:
      oprot.writeFieldBegin('ref', TType.STRING, 2)
      oprot.writeString(self.ref)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.token is None:
      raise TProtocol.TProtocolException(message='Required field token is unset!')
    if self.ref is None:
      raise TProtocol.TProtocolException(message='Required field ref is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.token)
    value = (value * 31) ^ hash(self.ref)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_genome_annotations_result:
  """
  Attributes:
   - success
   - generic_exception
   - authorization_exception
   - authentication_exception
   - reference_exception
   - attribute_exception
   - type_exception
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'generic_exception', (ServiceException, ServiceException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'authorization_exception', (AuthorizationException, AuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'authentication_exception', (AuthenticationException, AuthenticationException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'reference_exception', (ObjectReferenceException, ObjectReferenceException.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'attribute_exception', (AttributeException, AttributeException.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'type_exception', (TypeException, TypeException.thrift_spec), None, ), # 6
  )

  def __init__(self, success=None, generic_exception=None, authorization_exception=None, authentication_exception=None, reference_exception=None, attribute_exception=None, type_exception=None,):
    self.success = success
    self.generic_exception = generic_exception
    self.authorization_exception = authorization_exception
    self.authentication_exception = authentication_exception
    self.reference_exception = reference_exception
    self.attribute_exception = attribute_exception
    self.type_exception = type_exception

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype19, _size16) = iprot.readListBegin()
          for _i20 in xrange(_size16):
            _elem21 = iprot.readString();
            self.success.append(_elem21)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_exception = ServiceException()
          self.generic_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.authorization_exception = AuthorizationException()
          self.authorization_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.authentication_exception = AuthenticationException()
          self.authentication_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.reference_exception = ObjectReferenceException()
          self.reference_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.attribute_exception = AttributeException()
          self.attribute_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.type_exception = TypeException()
          self.type_exception.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_genome_annotations_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter22 in self.success:
        oprot.writeString(iter22)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.generic_exception is not None:
      oprot.writeFieldBegin('generic_exception', TType.STRUCT, 1)
      self.generic_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authorization_exception is not None:
      oprot.writeFieldBegin('authorization_exception', TType.STRUCT, 2)
      self.authorization_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authentication_exception is not None:
      oprot.writeFieldBegin('authentication_exception', TType.STRUCT, 3)
      self.authentication_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.reference_exception is not None:
      oprot.writeFieldBegin('reference_exception', TType.STRUCT, 4)
      self.reference_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.attribute_exception is not None:
      oprot.writeFieldBegin('attribute_exception', TType.STRUCT, 5)
      self.attribute_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.type_exception is not None:
      oprot.writeFieldBegin('type_exception', TType.STRUCT, 6)
      self.type_exception.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.generic_exception)
    value = (value * 31) ^ hash(self.authorization_exception)
    value = (value * 31) ^ hash(self.authentication_exception)
    value = (value * 31) ^ hash(self.reference_exception)
    value = (value * 31) ^ hash(self.attribute_exception)
    value = (value * 31) ^ hash(self.type_exception)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_external_source_info_args:
  """
  Attributes:
   - token
   - ref
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token', None, None, ), # 1
    (2, TType.STRING, 'ref', None, None, ), # 2
  )

  def __init__(self, token=None, ref=None,):
    self.token = token
    self.ref = ref

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ref = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_external_source_info_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 1)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    if self.ref is not None:
      oprot.writeFieldBegin('ref', TType.STRING, 2)
      oprot.writeString(self.ref)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.token is None:
      raise TProtocol.TProtocolException(message='Required field token is unset!')
    if self.ref is None:
      raise TProtocol.TProtocolException(message='Required field ref is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.token)
    value = (value * 31) ^ hash(self.ref)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_external_source_info_result:
  """
  Attributes:
   - success
   - generic_exception
   - authorization_exception
   - authentication_exception
   - reference_exception
   - attribute_exception
   - type_exception
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (AssemblyExternalSourceInfo, AssemblyExternalSourceInfo.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'generic_exception', (ServiceException, ServiceException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'authorization_exception', (AuthorizationException, AuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'authentication_exception', (AuthenticationException, AuthenticationException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'reference_exception', (ObjectReferenceException, ObjectReferenceException.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'attribute_exception', (AttributeException, AttributeException.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'type_exception', (TypeException, TypeException.thrift_spec), None, ), # 6
  )

  def __init__(self, success=None, generic_exception=None, authorization_exception=None, authentication_exception=None, reference_exception=None, attribute_exception=None, type_exception=None,):
    self.success = success
    self.generic_exception = generic_exception
    self.authorization_exception = authorization_exception
    self.authentication_exception = authentication_exception
    self.reference_exception = reference_exception
    self.attribute_exception = attribute_exception
    self.type_exception = type_exception

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = AssemblyExternalSourceInfo()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_exception = ServiceException()
          self.generic_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.authorization_exception = AuthorizationException()
          self.authorization_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.authentication_exception = AuthenticationException()
          self.authentication_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.reference_exception = ObjectReferenceException()
          self.reference_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.attribute_exception = AttributeException()
          self.attribute_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.type_exception = TypeException()
          self.type_exception.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_external_source_info_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.generic_exception is not None:
      oprot.writeFieldBegin('generic_exception', TType.STRUCT, 1)
      self.generic_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authorization_exception is not None:
      oprot.writeFieldBegin('authorization_exception', TType.STRUCT, 2)
      self.authorization_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authentication_exception is not None:
      oprot.writeFieldBegin('authentication_exception', TType.STRUCT, 3)
      self.authentication_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.reference_exception is not None:
      oprot.writeFieldBegin('reference_exception', TType.STRUCT, 4)
      self.reference_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.attribute_exception is not None:
      oprot.writeFieldBegin('attribute_exception', TType.STRUCT, 5)
      self.attribute_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.type_exception is not None:
      oprot.writeFieldBegin('type_exception', TType.STRUCT, 6)
      self.type_exception.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.generic_exception)
    value = (value * 31) ^ hash(self.authorization_exception)
    value = (value * 31) ^ hash(self.authentication_exception)
    value = (value * 31) ^ hash(self.reference_exception)
    value = (value * 31) ^ hash(self.attribute_exception)
    value = (value * 31) ^ hash(self.type_exception)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_stats_args:
  """
  Attributes:
   - token
   - ref
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token', None, None, ), # 1
    (2, TType.STRING, 'ref', None, None, ), # 2
  )

  def __init__(self, token=None, ref=None,):
    self.token = token
    self.ref = ref

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ref = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_stats_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 1)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    if self.ref is not None:
      oprot.writeFieldBegin('ref', TType.STRING, 2)
      oprot.writeString(self.ref)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.token is None:
      raise TProtocol.TProtocolException(message='Required field token is unset!')
    if self.ref is None:
      raise TProtocol.TProtocolException(message='Required field ref is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.token)
    value = (value * 31) ^ hash(self.ref)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_stats_result:
  """
  Attributes:
   - success
   - generic_exception
   - authorization_exception
   - authentication_exception
   - reference_exception
   - attribute_exception
   - type_exception
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (AssemblyStats, AssemblyStats.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'generic_exception', (ServiceException, ServiceException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'authorization_exception', (AuthorizationException, AuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'authentication_exception', (AuthenticationException, AuthenticationException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'reference_exception', (ObjectReferenceException, ObjectReferenceException.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'attribute_exception', (AttributeException, AttributeException.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'type_exception', (TypeException, TypeException.thrift_spec), None, ), # 6
  )

  def __init__(self, success=None, generic_exception=None, authorization_exception=None, authentication_exception=None, reference_exception=None, attribute_exception=None, type_exception=None,):
    self.success = success
    self.generic_exception = generic_exception
    self.authorization_exception = authorization_exception
    self.authentication_exception = authentication_exception
    self.reference_exception = reference_exception
    self.attribute_exception = attribute_exception
    self.type_exception = type_exception

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = AssemblyStats()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_exception = ServiceException()
          self.generic_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.authorization_exception = AuthorizationException()
          self.authorization_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.authentication_exception = AuthenticationException()
          self.authentication_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.reference_exception = ObjectReferenceException()
          self.reference_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.attribute_exception = AttributeException()
          self.attribute_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.type_exception = TypeException()
          self.type_exception.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_stats_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.generic_exception is not None:
      oprot.writeFieldBegin('generic_exception', TType.STRUCT, 1)
      self.generic_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authorization_exception is not None:
      oprot.writeFieldBegin('authorization_exception', TType.STRUCT, 2)
      self.authorization_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authentication_exception is not None:
      oprot.writeFieldBegin('authentication_exception', TType.STRUCT, 3)
      self.authentication_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.reference_exception is not None:
      oprot.writeFieldBegin('reference_exception', TType.STRUCT, 4)
      self.reference_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.attribute_exception is not None:
      oprot.writeFieldBegin('attribute_exception', TType.STRUCT, 5)
      self.attribute_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.type_exception is not None:
      oprot.writeFieldBegin('type_exception', TType.STRUCT, 6)
      self.type_exception.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.generic_exception)
    value = (value * 31) ^ hash(self.authorization_exception)
    value = (value * 31) ^ hash(self.authentication_exception)
    value = (value * 31) ^ hash(self.reference_exception)
    value = (value * 31) ^ hash(self.attribute_exception)
    value = (value * 31) ^ hash(self.type_exception)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_number_contigs_args:
  """
  Attributes:
   - token
   - ref
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token', None, None, ), # 1
    (2, TType.STRING, 'ref', None, None, ), # 2
  )

  def __init__(self, token=None, ref=None,):
    self.token = token
    self.ref = ref

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ref = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_number_contigs_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 1)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    if self.ref is not None:
      oprot.writeFieldBegin('ref', TType.STRING, 2)
      oprot.writeString(self.ref)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.token is None:
      raise TProtocol.TProtocolException(message='Required field token is unset!')
    if self.ref is None:
      raise TProtocol.TProtocolException(message='Required field ref is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.token)
    value = (value * 31) ^ hash(self.ref)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_number_contigs_result:
  """
  Attributes:
   - success
   - generic_exception
   - authorization_exception
   - authentication_exception
   - reference_exception
   - attribute_exception
   - type_exception
  """

  thrift_spec = (
    (0, TType.I64, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'generic_exception', (ServiceException, ServiceException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'authorization_exception', (AuthorizationException, AuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'authentication_exception', (AuthenticationException, AuthenticationException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'reference_exception', (ObjectReferenceException, ObjectReferenceException.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'attribute_exception', (AttributeException, AttributeException.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'type_exception', (TypeException, TypeException.thrift_spec), None, ), # 6
  )

  def __init__(self, success=None, generic_exception=None, authorization_exception=None, authentication_exception=None, reference_exception=None, attribute_exception=None, type_exception=None,):
    self.success = success
    self.generic_exception = generic_exception
    self.authorization_exception = authorization_exception
    self.authentication_exception = authentication_exception
    self.reference_exception = reference_exception
    self.attribute_exception = attribute_exception
    self.type_exception = type_exception

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I64:
          self.success = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_exception = ServiceException()
          self.generic_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.authorization_exception = AuthorizationException()
          self.authorization_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.authentication_exception = AuthenticationException()
          self.authentication_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.reference_exception = ObjectReferenceException()
          self.reference_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.attribute_exception = AttributeException()
          self.attribute_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.type_exception = TypeException()
          self.type_exception.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_number_contigs_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I64, 0)
      oprot.writeI64(self.success)
      oprot.writeFieldEnd()
    if self.generic_exception is not None:
      oprot.writeFieldBegin('generic_exception', TType.STRUCT, 1)
      self.generic_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authorization_exception is not None:
      oprot.writeFieldBegin('authorization_exception', TType.STRUCT, 2)
      self.authorization_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authentication_exception is not None:
      oprot.writeFieldBegin('authentication_exception', TType.STRUCT, 3)
      self.authentication_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.reference_exception is not None:
      oprot.writeFieldBegin('reference_exception', TType.STRUCT, 4)
      self.reference_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.attribute_exception is not None:
      oprot.writeFieldBegin('attribute_exception', TType.STRUCT, 5)
      self.attribute_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.type_exception is not None:
      oprot.writeFieldBegin('type_exception', TType.STRUCT, 6)
      self.type_exception.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.generic_exception)
    value = (value * 31) ^ hash(self.authorization_exception)
    value = (value * 31) ^ hash(self.authentication_exception)
    value = (value * 31) ^ hash(self.reference_exception)
    value = (value * 31) ^ hash(self.attribute_exception)
    value = (value * 31) ^ hash(self.type_exception)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_gc_content_args:
  """
  Attributes:
   - token
   - ref
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token', None, None, ), # 1
    (2, TType.STRING, 'ref', None, None, ), # 2
  )

  def __init__(self, token=None, ref=None,):
    self.token = token
    self.ref = ref

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ref = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_gc_content_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 1)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    if self.ref is not None:
      oprot.writeFieldBegin('ref', TType.STRING, 2)
      oprot.writeString(self.ref)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.token is None:
      raise TProtocol.TProtocolException(message='Required field token is unset!')
    if self.ref is None:
      raise TProtocol.TProtocolException(message='Required field ref is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.token)
    value = (value * 31) ^ hash(self.ref)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_gc_content_result:
  """
  Attributes:
   - success
   - generic_exception
   - authorization_exception
   - authentication_exception
   - reference_exception
   - attribute_exception
   - type_exception
  """

  thrift_spec = (
    (0, TType.DOUBLE, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'generic_exception', (ServiceException, ServiceException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'authorization_exception', (AuthorizationException, AuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'authentication_exception', (AuthenticationException, AuthenticationException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'reference_exception', (ObjectReferenceException, ObjectReferenceException.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'attribute_exception', (AttributeException, AttributeException.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'type_exception', (TypeException, TypeException.thrift_spec), None, ), # 6
  )

  def __init__(self, success=None, generic_exception=None, authorization_exception=None, authentication_exception=None, reference_exception=None, attribute_exception=None, type_exception=None,):
    self.success = success
    self.generic_exception = generic_exception
    self.authorization_exception = authorization_exception
    self.authentication_exception = authentication_exception
    self.reference_exception = reference_exception
    self.attribute_exception = attribute_exception
    self.type_exception = type_exception

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.DOUBLE:
          self.success = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_exception = ServiceException()
          self.generic_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.authorization_exception = AuthorizationException()
          self.authorization_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.authentication_exception = AuthenticationException()
          self.authentication_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.reference_exception = ObjectReferenceException()
          self.reference_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.attribute_exception = AttributeException()
          self.attribute_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.type_exception = TypeException()
          self.type_exception.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_gc_content_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.DOUBLE, 0)
      oprot.writeDouble(self.success)
      oprot.writeFieldEnd()
    if self.generic_exception is not None:
      oprot.writeFieldBegin('generic_exception', TType.STRUCT, 1)
      self.generic_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authorization_exception is not None:
      oprot.writeFieldBegin('authorization_exception', TType.STRUCT, 2)
      self.authorization_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authentication_exception is not None:
      oprot.writeFieldBegin('authentication_exception', TType.STRUCT, 3)
      self.authentication_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.reference_exception is not None:
      oprot.writeFieldBegin('reference_exception', TType.STRUCT, 4)
      self.reference_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.attribute_exception is not None:
      oprot.writeFieldBegin('attribute_exception', TType.STRUCT, 5)
      self.attribute_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.type_exception is not None:
      oprot.writeFieldBegin('type_exception', TType.STRUCT, 6)
      self.type_exception.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.generic_exception)
    value = (value * 31) ^ hash(self.authorization_exception)
    value = (value * 31) ^ hash(self.authentication_exception)
    value = (value * 31) ^ hash(self.reference_exception)
    value = (value * 31) ^ hash(self.attribute_exception)
    value = (value * 31) ^ hash(self.type_exception)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_dna_size_args:
  """
  Attributes:
   - token
   - ref
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token', None, None, ), # 1
    (2, TType.STRING, 'ref', None, None, ), # 2
  )

  def __init__(self, token=None, ref=None,):
    self.token = token
    self.ref = ref

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ref = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_dna_size_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 1)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    if self.ref is not None:
      oprot.writeFieldBegin('ref', TType.STRING, 2)
      oprot.writeString(self.ref)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.token is None:
      raise TProtocol.TProtocolException(message='Required field token is unset!')
    if self.ref is None:
      raise TProtocol.TProtocolException(message='Required field ref is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.token)
    value = (value * 31) ^ hash(self.ref)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_dna_size_result:
  """
  Attributes:
   - success
   - generic_exception
   - authorization_exception
   - authentication_exception
   - reference_exception
   - attribute_exception
   - type_exception
  """

  thrift_spec = (
    (0, TType.I64, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'generic_exception', (ServiceException, ServiceException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'authorization_exception', (AuthorizationException, AuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'authentication_exception', (AuthenticationException, AuthenticationException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'reference_exception', (ObjectReferenceException, ObjectReferenceException.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'attribute_exception', (AttributeException, AttributeException.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'type_exception', (TypeException, TypeException.thrift_spec), None, ), # 6
  )

  def __init__(self, success=None, generic_exception=None, authorization_exception=None, authentication_exception=None, reference_exception=None, attribute_exception=None, type_exception=None,):
    self.success = success
    self.generic_exception = generic_exception
    self.authorization_exception = authorization_exception
    self.authentication_exception = authentication_exception
    self.reference_exception = reference_exception
    self.attribute_exception = attribute_exception
    self.type_exception = type_exception

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I64:
          self.success = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_exception = ServiceException()
          self.generic_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.authorization_exception = AuthorizationException()
          self.authorization_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.authentication_exception = AuthenticationException()
          self.authentication_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.reference_exception = ObjectReferenceException()
          self.reference_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.attribute_exception = AttributeException()
          self.attribute_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.type_exception = TypeException()
          self.type_exception.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_dna_size_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I64, 0)
      oprot.writeI64(self.success)
      oprot.writeFieldEnd()
    if self.generic_exception is not None:
      oprot.writeFieldBegin('generic_exception', TType.STRUCT, 1)
      self.generic_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authorization_exception is not None:
      oprot.writeFieldBegin('authorization_exception', TType.STRUCT, 2)
      self.authorization_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authentication_exception is not None:
      oprot.writeFieldBegin('authentication_exception', TType.STRUCT, 3)
      self.authentication_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.reference_exception is not None:
      oprot.writeFieldBegin('reference_exception', TType.STRUCT, 4)
      self.reference_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.attribute_exception is not None:
      oprot.writeFieldBegin('attribute_exception', TType.STRUCT, 5)
      self.attribute_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.type_exception is not None:
      oprot.writeFieldBegin('type_exception', TType.STRUCT, 6)
      self.type_exception.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.generic_exception)
    value = (value * 31) ^ hash(self.authorization_exception)
    value = (value * 31) ^ hash(self.authentication_exception)
    value = (value * 31) ^ hash(self.reference_exception)
    value = (value * 31) ^ hash(self.attribute_exception)
    value = (value * 31) ^ hash(self.type_exception)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_contig_ids_args:
  """
  Attributes:
   - token
   - ref
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token', None, None, ), # 1
    (2, TType.STRING, 'ref', None, None, ), # 2
  )

  def __init__(self, token=None, ref=None,):
    self.token = token
    self.ref = ref

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ref = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_contig_ids_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 1)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    if self.ref is not None:
      oprot.writeFieldBegin('ref', TType.STRING, 2)
      oprot.writeString(self.ref)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.token is None:
      raise TProtocol.TProtocolException(message='Required field token is unset!')
    if self.ref is None:
      raise TProtocol.TProtocolException(message='Required field ref is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.token)
    value = (value * 31) ^ hash(self.ref)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_contig_ids_result:
  """
  Attributes:
   - success
   - generic_exception
   - authorization_exception
   - authentication_exception
   - reference_exception
   - attribute_exception
   - type_exception
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'generic_exception', (ServiceException, ServiceException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'authorization_exception', (AuthorizationException, AuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'authentication_exception', (AuthenticationException, AuthenticationException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'reference_exception', (ObjectReferenceException, ObjectReferenceException.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'attribute_exception', (AttributeException, AttributeException.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'type_exception', (TypeException, TypeException.thrift_spec), None, ), # 6
  )

  def __init__(self, success=None, generic_exception=None, authorization_exception=None, authentication_exception=None, reference_exception=None, attribute_exception=None, type_exception=None,):
    self.success = success
    self.generic_exception = generic_exception
    self.authorization_exception = authorization_exception
    self.authentication_exception = authentication_exception
    self.reference_exception = reference_exception
    self.attribute_exception = attribute_exception
    self.type_exception = type_exception

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype26, _size23) = iprot.readListBegin()
          for _i27 in xrange(_size23):
            _elem28 = iprot.readString();
            self.success.append(_elem28)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_exception = ServiceException()
          self.generic_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.authorization_exception = AuthorizationException()
          self.authorization_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.authentication_exception = AuthenticationException()
          self.authentication_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.reference_exception = ObjectReferenceException()
          self.reference_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.attribute_exception = AttributeException()
          self.attribute_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.type_exception = TypeException()
          self.type_exception.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_contig_ids_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter29 in self.success:
        oprot.writeString(iter29)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.generic_exception is not None:
      oprot.writeFieldBegin('generic_exception', TType.STRUCT, 1)
      self.generic_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authorization_exception is not None:
      oprot.writeFieldBegin('authorization_exception', TType.STRUCT, 2)
      self.authorization_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authentication_exception is not None:
      oprot.writeFieldBegin('authentication_exception', TType.STRUCT, 3)
      self.authentication_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.reference_exception is not None:
      oprot.writeFieldBegin('reference_exception', TType.STRUCT, 4)
      self.reference_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.attribute_exception is not None:
      oprot.writeFieldBegin('attribute_exception', TType.STRUCT, 5)
      self.attribute_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.type_exception is not None:
      oprot.writeFieldBegin('type_exception', TType.STRUCT, 6)
      self.type_exception.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.generic_exception)
    value = (value * 31) ^ hash(self.authorization_exception)
    value = (value * 31) ^ hash(self.authentication_exception)
    value = (value * 31) ^ hash(self.reference_exception)
    value = (value * 31) ^ hash(self.attribute_exception)
    value = (value * 31) ^ hash(self.type_exception)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_contig_lengths_args:
  """
  Attributes:
   - token
   - ref
   - contig_id_list
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token', None, None, ), # 1
    (2, TType.STRING, 'ref', None, None, ), # 2
    (3, TType.LIST, 'contig_id_list', (TType.STRING,None), None, ), # 3
  )

  def __init__(self, token=None, ref=None, contig_id_list=None,):
    self.token = token
    self.ref = ref
    self.contig_id_list = contig_id_list

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ref = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.contig_id_list = []
          (_etype33, _size30) = iprot.readListBegin()
          for _i34 in xrange(_size30):
            _elem35 = iprot.readString();
            self.contig_id_list.append(_elem35)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_contig_lengths_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 1)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    if self.ref is not None:
      oprot.writeFieldBegin('ref', TType.STRING, 2)
      oprot.writeString(self.ref)
      oprot.writeFieldEnd()
    if self.contig_id_list is not None:
      oprot.writeFieldBegin('contig_id_list', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.contig_id_list))
      for iter36 in self.contig_id_list:
        oprot.writeString(iter36)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.token is None:
      raise TProtocol.TProtocolException(message='Required field token is unset!')
    if self.ref is None:
      raise TProtocol.TProtocolException(message='Required field ref is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.token)
    value = (value * 31) ^ hash(self.ref)
    value = (value * 31) ^ hash(self.contig_id_list)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_contig_lengths_result:
  """
  Attributes:
   - success
   - generic_exception
   - authorization_exception
   - authentication_exception
   - reference_exception
   - attribute_exception
   - type_exception
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.I64,None), None, ), # 0
    (1, TType.STRUCT, 'generic_exception', (ServiceException, ServiceException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'authorization_exception', (AuthorizationException, AuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'authentication_exception', (AuthenticationException, AuthenticationException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'reference_exception', (ObjectReferenceException, ObjectReferenceException.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'attribute_exception', (AttributeException, AttributeException.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'type_exception', (TypeException, TypeException.thrift_spec), None, ), # 6
  )

  def __init__(self, success=None, generic_exception=None, authorization_exception=None, authentication_exception=None, reference_exception=None, attribute_exception=None, type_exception=None,):
    self.success = success
    self.generic_exception = generic_exception
    self.authorization_exception = authorization_exception
    self.authentication_exception = authentication_exception
    self.reference_exception = reference_exception
    self.attribute_exception = attribute_exception
    self.type_exception = type_exception

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype38, _vtype39, _size37 ) = iprot.readMapBegin()
          for _i41 in xrange(_size37):
            _key42 = iprot.readString();
            _val43 = iprot.readI64();
            self.success[_key42] = _val43
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_exception = ServiceException()
          self.generic_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.authorization_exception = AuthorizationException()
          self.authorization_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.authentication_exception = AuthenticationException()
          self.authentication_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.reference_exception = ObjectReferenceException()
          self.reference_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.attribute_exception = AttributeException()
          self.attribute_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.type_exception = TypeException()
          self.type_exception.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_contig_lengths_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.I64, len(self.success))
      for kiter44,viter45 in self.success.items():
        oprot.writeString(kiter44)
        oprot.writeI64(viter45)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.generic_exception is not None:
      oprot.writeFieldBegin('generic_exception', TType.STRUCT, 1)
      self.generic_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authorization_exception is not None:
      oprot.writeFieldBegin('authorization_exception', TType.STRUCT, 2)
      self.authorization_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authentication_exception is not None:
      oprot.writeFieldBegin('authentication_exception', TType.STRUCT, 3)
      self.authentication_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.reference_exception is not None:
      oprot.writeFieldBegin('reference_exception', TType.STRUCT, 4)
      self.reference_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.attribute_exception is not None:
      oprot.writeFieldBegin('attribute_exception', TType.STRUCT, 5)
      self.attribute_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.type_exception is not None:
      oprot.writeFieldBegin('type_exception', TType.STRUCT, 6)
      self.type_exception.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.generic_exception)
    value = (value * 31) ^ hash(self.authorization_exception)
    value = (value * 31) ^ hash(self.authentication_exception)
    value = (value * 31) ^ hash(self.reference_exception)
    value = (value * 31) ^ hash(self.attribute_exception)
    value = (value * 31) ^ hash(self.type_exception)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_contig_gc_content_args:
  """
  Attributes:
   - token
   - ref
   - contig_id_list
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token', None, None, ), # 1
    (2, TType.STRING, 'ref', None, None, ), # 2
    (3, TType.LIST, 'contig_id_list', (TType.STRING,None), None, ), # 3
  )

  def __init__(self, token=None, ref=None, contig_id_list=None,):
    self.token = token
    self.ref = ref
    self.contig_id_list = contig_id_list

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ref = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.contig_id_list = []
          (_etype49, _size46) = iprot.readListBegin()
          for _i50 in xrange(_size46):
            _elem51 = iprot.readString();
            self.contig_id_list.append(_elem51)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_contig_gc_content_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 1)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    if self.ref is not None:
      oprot.writeFieldBegin('ref', TType.STRING, 2)
      oprot.writeString(self.ref)
      oprot.writeFieldEnd()
    if self.contig_id_list is not None:
      oprot.writeFieldBegin('contig_id_list', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.contig_id_list))
      for iter52 in self.contig_id_list:
        oprot.writeString(iter52)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.token is None:
      raise TProtocol.TProtocolException(message='Required field token is unset!')
    if self.ref is None:
      raise TProtocol.TProtocolException(message='Required field ref is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.token)
    value = (value * 31) ^ hash(self.ref)
    value = (value * 31) ^ hash(self.contig_id_list)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_contig_gc_content_result:
  """
  Attributes:
   - success
   - generic_exception
   - authorization_exception
   - authentication_exception
   - reference_exception
   - attribute_exception
   - type_exception
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.DOUBLE,None), None, ), # 0
    (1, TType.STRUCT, 'generic_exception', (ServiceException, ServiceException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'authorization_exception', (AuthorizationException, AuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'authentication_exception', (AuthenticationException, AuthenticationException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'reference_exception', (ObjectReferenceException, ObjectReferenceException.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'attribute_exception', (AttributeException, AttributeException.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'type_exception', (TypeException, TypeException.thrift_spec), None, ), # 6
  )

  def __init__(self, success=None, generic_exception=None, authorization_exception=None, authentication_exception=None, reference_exception=None, attribute_exception=None, type_exception=None,):
    self.success = success
    self.generic_exception = generic_exception
    self.authorization_exception = authorization_exception
    self.authentication_exception = authentication_exception
    self.reference_exception = reference_exception
    self.attribute_exception = attribute_exception
    self.type_exception = type_exception

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype54, _vtype55, _size53 ) = iprot.readMapBegin()
          for _i57 in xrange(_size53):
            _key58 = iprot.readString();
            _val59 = iprot.readDouble();
            self.success[_key58] = _val59
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_exception = ServiceException()
          self.generic_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.authorization_exception = AuthorizationException()
          self.authorization_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.authentication_exception = AuthenticationException()
          self.authentication_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.reference_exception = ObjectReferenceException()
          self.reference_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.attribute_exception = AttributeException()
          self.attribute_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.type_exception = TypeException()
          self.type_exception.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_contig_gc_content_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.DOUBLE, len(self.success))
      for kiter60,viter61 in self.success.items():
        oprot.writeString(kiter60)
        oprot.writeDouble(viter61)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.generic_exception is not None:
      oprot.writeFieldBegin('generic_exception', TType.STRUCT, 1)
      self.generic_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authorization_exception is not None:
      oprot.writeFieldBegin('authorization_exception', TType.STRUCT, 2)
      self.authorization_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authentication_exception is not None:
      oprot.writeFieldBegin('authentication_exception', TType.STRUCT, 3)
      self.authentication_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.reference_exception is not None:
      oprot.writeFieldBegin('reference_exception', TType.STRUCT, 4)
      self.reference_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.attribute_exception is not None:
      oprot.writeFieldBegin('attribute_exception', TType.STRUCT, 5)
      self.attribute_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.type_exception is not None:
      oprot.writeFieldBegin('type_exception', TType.STRUCT, 6)
      self.type_exception.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.generic_exception)
    value = (value * 31) ^ hash(self.authorization_exception)
    value = (value * 31) ^ hash(self.authentication_exception)
    value = (value * 31) ^ hash(self.reference_exception)
    value = (value * 31) ^ hash(self.attribute_exception)
    value = (value * 31) ^ hash(self.type_exception)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_contigs_args:
  """
  Attributes:
   - token
   - ref
   - contig_id_list
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token', None, None, ), # 1
    (2, TType.STRING, 'ref', None, None, ), # 2
    (3, TType.LIST, 'contig_id_list', (TType.STRING,None), None, ), # 3
  )

  def __init__(self, token=None, ref=None, contig_id_list=None,):
    self.token = token
    self.ref = ref
    self.contig_id_list = contig_id_list

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ref = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.contig_id_list = []
          (_etype65, _size62) = iprot.readListBegin()
          for _i66 in xrange(_size62):
            _elem67 = iprot.readString();
            self.contig_id_list.append(_elem67)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_contigs_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 1)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    if self.ref is not None:
      oprot.writeFieldBegin('ref', TType.STRING, 2)
      oprot.writeString(self.ref)
      oprot.writeFieldEnd()
    if self.contig_id_list is not None:
      oprot.writeFieldBegin('contig_id_list', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.contig_id_list))
      for iter68 in self.contig_id_list:
        oprot.writeString(iter68)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.token is None:
      raise TProtocol.TProtocolException(message='Required field token is unset!')
    if self.ref is None:
      raise TProtocol.TProtocolException(message='Required field ref is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.token)
    value = (value * 31) ^ hash(self.ref)
    value = (value * 31) ^ hash(self.contig_id_list)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_contigs_result:
  """
  Attributes:
   - success
   - generic_exception
   - authorization_exception
   - authentication_exception
   - reference_exception
   - attribute_exception
   - type_exception
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.STRUCT,(AssemblyContig, AssemblyContig.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'generic_exception', (ServiceException, ServiceException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'authorization_exception', (AuthorizationException, AuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'authentication_exception', (AuthenticationException, AuthenticationException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'reference_exception', (ObjectReferenceException, ObjectReferenceException.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'attribute_exception', (AttributeException, AttributeException.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'type_exception', (TypeException, TypeException.thrift_spec), None, ), # 6
  )

  def __init__(self, success=None, generic_exception=None, authorization_exception=None, authentication_exception=None, reference_exception=None, attribute_exception=None, type_exception=None,):
    self.success = success
    self.generic_exception = generic_exception
    self.authorization_exception = authorization_exception
    self.authentication_exception = authentication_exception
    self.reference_exception = reference_exception
    self.attribute_exception = attribute_exception
    self.type_exception = type_exception

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype70, _vtype71, _size69 ) = iprot.readMapBegin()
          for _i73 in xrange(_size69):
            _key74 = iprot.readString();
            _val75 = AssemblyContig()
            _val75.read(iprot)
            self.success[_key74] = _val75
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_exception = ServiceException()
          self.generic_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.authorization_exception = AuthorizationException()
          self.authorization_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.authentication_exception = AuthenticationException()
          self.authentication_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.reference_exception = ObjectReferenceException()
          self.reference_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.attribute_exception = AttributeException()
          self.attribute_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.type_exception = TypeException()
          self.type_exception.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_contigs_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.success))
      for kiter76,viter77 in self.success.items():
        oprot.writeString(kiter76)
        viter77.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.generic_exception is not None:
      oprot.writeFieldBegin('generic_exception', TType.STRUCT, 1)
      self.generic_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authorization_exception is not None:
      oprot.writeFieldBegin('authorization_exception', TType.STRUCT, 2)
      self.authorization_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authentication_exception is not None:
      oprot.writeFieldBegin('authentication_exception', TType.STRUCT, 3)
      self.authentication_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.reference_exception is not None:
      oprot.writeFieldBegin('reference_exception', TType.STRUCT, 4)
      self.reference_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.attribute_exception is not None:
      oprot.writeFieldBegin('attribute_exception', TType.STRUCT, 5)
      self.attribute_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.type_exception is not None:
      oprot.writeFieldBegin('type_exception', TType.STRUCT, 6)
      self.type_exception.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.generic_exception)
    value = (value * 31) ^ hash(self.authorization_exception)
    value = (value * 31) ^ hash(self.authentication_exception)
    value = (value * 31) ^ hash(self.reference_exception)
    value = (value * 31) ^ hash(self.attribute_exception)
    value = (value * 31) ^ hash(self.type_exception)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
