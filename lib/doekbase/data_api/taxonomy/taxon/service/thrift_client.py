#
# Autogenerated by Thrift Compiler (0.9.2)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:twisted
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
from ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None

from zope.interface import Interface, implements
from twisted.internet import defer
from thrift.transport import TTwisted

class Iface(Interface):
  def get_info(token, ref):
    """
    Retrieve object info.


    Parameters:
     - token
     - ref
    """
    pass

  def get_history(token, ref):
    """
    Retrieve object history.


    Parameters:
     - token
     - ref
    """
    pass

  def get_provenance(token, ref):
    """
    Retrieve object provenance.


    Parameters:
     - token
     - ref
    """
    pass

  def get_id(token, ref):
    """
    Retrieve object identifier.


    Parameters:
     - token
     - ref
    """
    pass

  def get_name(token, ref):
    """
    Retrieve object name.


    Parameters:
     - token
     - ref
    """
    pass

  def get_version(token, ref):
    """
    Retrieve object version.


    Parameters:
     - token
     - ref
    """
    pass

  def get_parent(token, ref):
    """
    Retrieve parent Taxon.


    Parameters:
     - token
     - ref
    """
    pass

  def get_children(token, ref):
    """
    Retrieve children Taxon.


    Parameters:
     - token
     - ref
    """
    pass

  def get_genome_annotations(token, ref):
    """
    Retrieve associated GenomeAnnotation objects.


    Parameters:
     - token
     - ref
    """
    pass

  def get_scientific_lineage(token, ref):
    """
    Retrieve the scientific lineage.


    Parameters:
     - token
     - ref
    """
    pass

  def get_scientific_name(token, ref):
    """
    Retrieve the scientific name.


    Parameters:
     - token
     - ref
    """
    pass

  def get_taxonomic_id(token, ref):
    """
    Retrieve the taxonomic id.


    Parameters:
     - token
     - ref
    """
    pass

  def get_kingdom(token, ref):
    """
    Retrieve the kingdom.


    Parameters:
     - token
     - ref
    """
    pass

  def get_domain(token, ref):
    """
    Retrieve the domain.


    Parameters:
     - token
     - ref
    """
    pass

  def get_genetic_code(token, ref):
    """
    Retrieve the genetic code.


    Parameters:
     - token
     - ref
    """
    pass

  def get_aliases(token, ref):
    """
    Retrieve the aliases.


    Parameters:
     - token
     - ref
    """
    pass


class Client:
  implements(Iface)

  def __init__(self, transport, oprot_factory):
    self._transport = transport
    self._oprot_factory = oprot_factory
    self._seqid = 0
    self._reqs = {}

  def get_info(self, token, ref):
    """
    Retrieve object info.


    Parameters:
     - token
     - ref
    """
    seqid = self._seqid = self._seqid + 1
    self._reqs[seqid] = defer.Deferred()

    d = defer.maybeDeferred(self.send_get_info, token, ref)
    d.addCallbacks(
      callback=self.cb_send_get_info,
      callbackArgs=(seqid,),
      errback=self.eb_send_get_info,
      errbackArgs=(seqid,))
    return d

  def cb_send_get_info(self, _, seqid):
    return self._reqs[seqid]

  def eb_send_get_info(self, f, seqid):
    d = self._reqs.pop(seqid)
    d.errback(f)
    return d

  def send_get_info(self, token, ref):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('get_info', TMessageType.CALL, self._seqid)
    args = get_info_args()
    args.token = token
    args.ref = ref
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_get_info(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = get_info_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    if result.generic_exception is not None:
      return d.errback(result.generic_exception)
    if result.authorization_exception is not None:
      return d.errback(result.authorization_exception)
    if result.authentication_exception is not None:
      return d.errback(result.authentication_exception)
    if result.reference_exception is not None:
      return d.errback(result.reference_exception)
    if result.attribute_exception is not None:
      return d.errback(result.attribute_exception)
    if result.type_exception is not None:
      return d.errback(result.type_exception)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "get_info failed: unknown result"))

  def get_history(self, token, ref):
    """
    Retrieve object history.


    Parameters:
     - token
     - ref
    """
    seqid = self._seqid = self._seqid + 1
    self._reqs[seqid] = defer.Deferred()

    d = defer.maybeDeferred(self.send_get_history, token, ref)
    d.addCallbacks(
      callback=self.cb_send_get_history,
      callbackArgs=(seqid,),
      errback=self.eb_send_get_history,
      errbackArgs=(seqid,))
    return d

  def cb_send_get_history(self, _, seqid):
    return self._reqs[seqid]

  def eb_send_get_history(self, f, seqid):
    d = self._reqs.pop(seqid)
    d.errback(f)
    return d

  def send_get_history(self, token, ref):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('get_history', TMessageType.CALL, self._seqid)
    args = get_history_args()
    args.token = token
    args.ref = ref
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_get_history(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = get_history_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    if result.generic_exception is not None:
      return d.errback(result.generic_exception)
    if result.authorization_exception is not None:
      return d.errback(result.authorization_exception)
    if result.authentication_exception is not None:
      return d.errback(result.authentication_exception)
    if result.reference_exception is not None:
      return d.errback(result.reference_exception)
    if result.attribute_exception is not None:
      return d.errback(result.attribute_exception)
    if result.type_exception is not None:
      return d.errback(result.type_exception)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "get_history failed: unknown result"))

  def get_provenance(self, token, ref):
    """
    Retrieve object provenance.


    Parameters:
     - token
     - ref
    """
    seqid = self._seqid = self._seqid + 1
    self._reqs[seqid] = defer.Deferred()

    d = defer.maybeDeferred(self.send_get_provenance, token, ref)
    d.addCallbacks(
      callback=self.cb_send_get_provenance,
      callbackArgs=(seqid,),
      errback=self.eb_send_get_provenance,
      errbackArgs=(seqid,))
    return d

  def cb_send_get_provenance(self, _, seqid):
    return self._reqs[seqid]

  def eb_send_get_provenance(self, f, seqid):
    d = self._reqs.pop(seqid)
    d.errback(f)
    return d

  def send_get_provenance(self, token, ref):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('get_provenance', TMessageType.CALL, self._seqid)
    args = get_provenance_args()
    args.token = token
    args.ref = ref
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_get_provenance(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = get_provenance_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    if result.generic_exception is not None:
      return d.errback(result.generic_exception)
    if result.authorization_exception is not None:
      return d.errback(result.authorization_exception)
    if result.authentication_exception is not None:
      return d.errback(result.authentication_exception)
    if result.reference_exception is not None:
      return d.errback(result.reference_exception)
    if result.attribute_exception is not None:
      return d.errback(result.attribute_exception)
    if result.type_exception is not None:
      return d.errback(result.type_exception)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "get_provenance failed: unknown result"))

  def get_id(self, token, ref):
    """
    Retrieve object identifier.


    Parameters:
     - token
     - ref
    """
    seqid = self._seqid = self._seqid + 1
    self._reqs[seqid] = defer.Deferred()

    d = defer.maybeDeferred(self.send_get_id, token, ref)
    d.addCallbacks(
      callback=self.cb_send_get_id,
      callbackArgs=(seqid,),
      errback=self.eb_send_get_id,
      errbackArgs=(seqid,))
    return d

  def cb_send_get_id(self, _, seqid):
    return self._reqs[seqid]

  def eb_send_get_id(self, f, seqid):
    d = self._reqs.pop(seqid)
    d.errback(f)
    return d

  def send_get_id(self, token, ref):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('get_id', TMessageType.CALL, self._seqid)
    args = get_id_args()
    args.token = token
    args.ref = ref
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_get_id(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = get_id_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    if result.generic_exception is not None:
      return d.errback(result.generic_exception)
    if result.authorization_exception is not None:
      return d.errback(result.authorization_exception)
    if result.authentication_exception is not None:
      return d.errback(result.authentication_exception)
    if result.reference_exception is not None:
      return d.errback(result.reference_exception)
    if result.attribute_exception is not None:
      return d.errback(result.attribute_exception)
    if result.type_exception is not None:
      return d.errback(result.type_exception)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "get_id failed: unknown result"))

  def get_name(self, token, ref):
    """
    Retrieve object name.


    Parameters:
     - token
     - ref
    """
    seqid = self._seqid = self._seqid + 1
    self._reqs[seqid] = defer.Deferred()

    d = defer.maybeDeferred(self.send_get_name, token, ref)
    d.addCallbacks(
      callback=self.cb_send_get_name,
      callbackArgs=(seqid,),
      errback=self.eb_send_get_name,
      errbackArgs=(seqid,))
    return d

  def cb_send_get_name(self, _, seqid):
    return self._reqs[seqid]

  def eb_send_get_name(self, f, seqid):
    d = self._reqs.pop(seqid)
    d.errback(f)
    return d

  def send_get_name(self, token, ref):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('get_name', TMessageType.CALL, self._seqid)
    args = get_name_args()
    args.token = token
    args.ref = ref
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_get_name(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = get_name_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    if result.generic_exception is not None:
      return d.errback(result.generic_exception)
    if result.authorization_exception is not None:
      return d.errback(result.authorization_exception)
    if result.authentication_exception is not None:
      return d.errback(result.authentication_exception)
    if result.reference_exception is not None:
      return d.errback(result.reference_exception)
    if result.attribute_exception is not None:
      return d.errback(result.attribute_exception)
    if result.type_exception is not None:
      return d.errback(result.type_exception)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "get_name failed: unknown result"))

  def get_version(self, token, ref):
    """
    Retrieve object version.


    Parameters:
     - token
     - ref
    """
    seqid = self._seqid = self._seqid + 1
    self._reqs[seqid] = defer.Deferred()

    d = defer.maybeDeferred(self.send_get_version, token, ref)
    d.addCallbacks(
      callback=self.cb_send_get_version,
      callbackArgs=(seqid,),
      errback=self.eb_send_get_version,
      errbackArgs=(seqid,))
    return d

  def cb_send_get_version(self, _, seqid):
    return self._reqs[seqid]

  def eb_send_get_version(self, f, seqid):
    d = self._reqs.pop(seqid)
    d.errback(f)
    return d

  def send_get_version(self, token, ref):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('get_version', TMessageType.CALL, self._seqid)
    args = get_version_args()
    args.token = token
    args.ref = ref
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_get_version(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = get_version_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    if result.generic_exception is not None:
      return d.errback(result.generic_exception)
    if result.authorization_exception is not None:
      return d.errback(result.authorization_exception)
    if result.authentication_exception is not None:
      return d.errback(result.authentication_exception)
    if result.reference_exception is not None:
      return d.errback(result.reference_exception)
    if result.attribute_exception is not None:
      return d.errback(result.attribute_exception)
    if result.type_exception is not None:
      return d.errback(result.type_exception)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "get_version failed: unknown result"))

  def get_parent(self, token, ref):
    """
    Retrieve parent Taxon.


    Parameters:
     - token
     - ref
    """
    seqid = self._seqid = self._seqid + 1
    self._reqs[seqid] = defer.Deferred()

    d = defer.maybeDeferred(self.send_get_parent, token, ref)
    d.addCallbacks(
      callback=self.cb_send_get_parent,
      callbackArgs=(seqid,),
      errback=self.eb_send_get_parent,
      errbackArgs=(seqid,))
    return d

  def cb_send_get_parent(self, _, seqid):
    return self._reqs[seqid]

  def eb_send_get_parent(self, f, seqid):
    d = self._reqs.pop(seqid)
    d.errback(f)
    return d

  def send_get_parent(self, token, ref):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('get_parent', TMessageType.CALL, self._seqid)
    args = get_parent_args()
    args.token = token
    args.ref = ref
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_get_parent(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = get_parent_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    if result.generic_exception is not None:
      return d.errback(result.generic_exception)
    if result.authorization_exception is not None:
      return d.errback(result.authorization_exception)
    if result.authentication_exception is not None:
      return d.errback(result.authentication_exception)
    if result.reference_exception is not None:
      return d.errback(result.reference_exception)
    if result.attribute_exception is not None:
      return d.errback(result.attribute_exception)
    if result.type_exception is not None:
      return d.errback(result.type_exception)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "get_parent failed: unknown result"))

  def get_children(self, token, ref):
    """
    Retrieve children Taxon.


    Parameters:
     - token
     - ref
    """
    seqid = self._seqid = self._seqid + 1
    self._reqs[seqid] = defer.Deferred()

    d = defer.maybeDeferred(self.send_get_children, token, ref)
    d.addCallbacks(
      callback=self.cb_send_get_children,
      callbackArgs=(seqid,),
      errback=self.eb_send_get_children,
      errbackArgs=(seqid,))
    return d

  def cb_send_get_children(self, _, seqid):
    return self._reqs[seqid]

  def eb_send_get_children(self, f, seqid):
    d = self._reqs.pop(seqid)
    d.errback(f)
    return d

  def send_get_children(self, token, ref):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('get_children', TMessageType.CALL, self._seqid)
    args = get_children_args()
    args.token = token
    args.ref = ref
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_get_children(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = get_children_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    if result.generic_exception is not None:
      return d.errback(result.generic_exception)
    if result.authorization_exception is not None:
      return d.errback(result.authorization_exception)
    if result.authentication_exception is not None:
      return d.errback(result.authentication_exception)
    if result.reference_exception is not None:
      return d.errback(result.reference_exception)
    if result.attribute_exception is not None:
      return d.errback(result.attribute_exception)
    if result.type_exception is not None:
      return d.errback(result.type_exception)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "get_children failed: unknown result"))

  def get_genome_annotations(self, token, ref):
    """
    Retrieve associated GenomeAnnotation objects.


    Parameters:
     - token
     - ref
    """
    seqid = self._seqid = self._seqid + 1
    self._reqs[seqid] = defer.Deferred()

    d = defer.maybeDeferred(self.send_get_genome_annotations, token, ref)
    d.addCallbacks(
      callback=self.cb_send_get_genome_annotations,
      callbackArgs=(seqid,),
      errback=self.eb_send_get_genome_annotations,
      errbackArgs=(seqid,))
    return d

  def cb_send_get_genome_annotations(self, _, seqid):
    return self._reqs[seqid]

  def eb_send_get_genome_annotations(self, f, seqid):
    d = self._reqs.pop(seqid)
    d.errback(f)
    return d

  def send_get_genome_annotations(self, token, ref):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('get_genome_annotations', TMessageType.CALL, self._seqid)
    args = get_genome_annotations_args()
    args.token = token
    args.ref = ref
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_get_genome_annotations(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = get_genome_annotations_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    if result.generic_exception is not None:
      return d.errback(result.generic_exception)
    if result.authorization_exception is not None:
      return d.errback(result.authorization_exception)
    if result.authentication_exception is not None:
      return d.errback(result.authentication_exception)
    if result.reference_exception is not None:
      return d.errback(result.reference_exception)
    if result.attribute_exception is not None:
      return d.errback(result.attribute_exception)
    if result.type_exception is not None:
      return d.errback(result.type_exception)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "get_genome_annotations failed: unknown result"))

  def get_scientific_lineage(self, token, ref):
    """
    Retrieve the scientific lineage.


    Parameters:
     - token
     - ref
    """
    seqid = self._seqid = self._seqid + 1
    self._reqs[seqid] = defer.Deferred()

    d = defer.maybeDeferred(self.send_get_scientific_lineage, token, ref)
    d.addCallbacks(
      callback=self.cb_send_get_scientific_lineage,
      callbackArgs=(seqid,),
      errback=self.eb_send_get_scientific_lineage,
      errbackArgs=(seqid,))
    return d

  def cb_send_get_scientific_lineage(self, _, seqid):
    return self._reqs[seqid]

  def eb_send_get_scientific_lineage(self, f, seqid):
    d = self._reqs.pop(seqid)
    d.errback(f)
    return d

  def send_get_scientific_lineage(self, token, ref):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('get_scientific_lineage', TMessageType.CALL, self._seqid)
    args = get_scientific_lineage_args()
    args.token = token
    args.ref = ref
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_get_scientific_lineage(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = get_scientific_lineage_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    if result.generic_exception is not None:
      return d.errback(result.generic_exception)
    if result.authorization_exception is not None:
      return d.errback(result.authorization_exception)
    if result.authentication_exception is not None:
      return d.errback(result.authentication_exception)
    if result.reference_exception is not None:
      return d.errback(result.reference_exception)
    if result.attribute_exception is not None:
      return d.errback(result.attribute_exception)
    if result.type_exception is not None:
      return d.errback(result.type_exception)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "get_scientific_lineage failed: unknown result"))

  def get_scientific_name(self, token, ref):
    """
    Retrieve the scientific name.


    Parameters:
     - token
     - ref
    """
    seqid = self._seqid = self._seqid + 1
    self._reqs[seqid] = defer.Deferred()

    d = defer.maybeDeferred(self.send_get_scientific_name, token, ref)
    d.addCallbacks(
      callback=self.cb_send_get_scientific_name,
      callbackArgs=(seqid,),
      errback=self.eb_send_get_scientific_name,
      errbackArgs=(seqid,))
    return d

  def cb_send_get_scientific_name(self, _, seqid):
    return self._reqs[seqid]

  def eb_send_get_scientific_name(self, f, seqid):
    d = self._reqs.pop(seqid)
    d.errback(f)
    return d

  def send_get_scientific_name(self, token, ref):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('get_scientific_name', TMessageType.CALL, self._seqid)
    args = get_scientific_name_args()
    args.token = token
    args.ref = ref
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_get_scientific_name(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = get_scientific_name_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    if result.generic_exception is not None:
      return d.errback(result.generic_exception)
    if result.authorization_exception is not None:
      return d.errback(result.authorization_exception)
    if result.authentication_exception is not None:
      return d.errback(result.authentication_exception)
    if result.reference_exception is not None:
      return d.errback(result.reference_exception)
    if result.attribute_exception is not None:
      return d.errback(result.attribute_exception)
    if result.type_exception is not None:
      return d.errback(result.type_exception)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "get_scientific_name failed: unknown result"))

  def get_taxonomic_id(self, token, ref):
    """
    Retrieve the taxonomic id.


    Parameters:
     - token
     - ref
    """
    seqid = self._seqid = self._seqid + 1
    self._reqs[seqid] = defer.Deferred()

    d = defer.maybeDeferred(self.send_get_taxonomic_id, token, ref)
    d.addCallbacks(
      callback=self.cb_send_get_taxonomic_id,
      callbackArgs=(seqid,),
      errback=self.eb_send_get_taxonomic_id,
      errbackArgs=(seqid,))
    return d

  def cb_send_get_taxonomic_id(self, _, seqid):
    return self._reqs[seqid]

  def eb_send_get_taxonomic_id(self, f, seqid):
    d = self._reqs.pop(seqid)
    d.errback(f)
    return d

  def send_get_taxonomic_id(self, token, ref):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('get_taxonomic_id', TMessageType.CALL, self._seqid)
    args = get_taxonomic_id_args()
    args.token = token
    args.ref = ref
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_get_taxonomic_id(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = get_taxonomic_id_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    if result.generic_exception is not None:
      return d.errback(result.generic_exception)
    if result.authorization_exception is not None:
      return d.errback(result.authorization_exception)
    if result.authentication_exception is not None:
      return d.errback(result.authentication_exception)
    if result.reference_exception is not None:
      return d.errback(result.reference_exception)
    if result.attribute_exception is not None:
      return d.errback(result.attribute_exception)
    if result.type_exception is not None:
      return d.errback(result.type_exception)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "get_taxonomic_id failed: unknown result"))

  def get_kingdom(self, token, ref):
    """
    Retrieve the kingdom.


    Parameters:
     - token
     - ref
    """
    seqid = self._seqid = self._seqid + 1
    self._reqs[seqid] = defer.Deferred()

    d = defer.maybeDeferred(self.send_get_kingdom, token, ref)
    d.addCallbacks(
      callback=self.cb_send_get_kingdom,
      callbackArgs=(seqid,),
      errback=self.eb_send_get_kingdom,
      errbackArgs=(seqid,))
    return d

  def cb_send_get_kingdom(self, _, seqid):
    return self._reqs[seqid]

  def eb_send_get_kingdom(self, f, seqid):
    d = self._reqs.pop(seqid)
    d.errback(f)
    return d

  def send_get_kingdom(self, token, ref):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('get_kingdom', TMessageType.CALL, self._seqid)
    args = get_kingdom_args()
    args.token = token
    args.ref = ref
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_get_kingdom(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = get_kingdom_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    if result.generic_exception is not None:
      return d.errback(result.generic_exception)
    if result.authorization_exception is not None:
      return d.errback(result.authorization_exception)
    if result.authentication_exception is not None:
      return d.errback(result.authentication_exception)
    if result.reference_exception is not None:
      return d.errback(result.reference_exception)
    if result.attribute_exception is not None:
      return d.errback(result.attribute_exception)
    if result.type_exception is not None:
      return d.errback(result.type_exception)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "get_kingdom failed: unknown result"))

  def get_domain(self, token, ref):
    """
    Retrieve the domain.


    Parameters:
     - token
     - ref
    """
    seqid = self._seqid = self._seqid + 1
    self._reqs[seqid] = defer.Deferred()

    d = defer.maybeDeferred(self.send_get_domain, token, ref)
    d.addCallbacks(
      callback=self.cb_send_get_domain,
      callbackArgs=(seqid,),
      errback=self.eb_send_get_domain,
      errbackArgs=(seqid,))
    return d

  def cb_send_get_domain(self, _, seqid):
    return self._reqs[seqid]

  def eb_send_get_domain(self, f, seqid):
    d = self._reqs.pop(seqid)
    d.errback(f)
    return d

  def send_get_domain(self, token, ref):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('get_domain', TMessageType.CALL, self._seqid)
    args = get_domain_args()
    args.token = token
    args.ref = ref
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_get_domain(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = get_domain_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    if result.generic_exception is not None:
      return d.errback(result.generic_exception)
    if result.authorization_exception is not None:
      return d.errback(result.authorization_exception)
    if result.authentication_exception is not None:
      return d.errback(result.authentication_exception)
    if result.reference_exception is not None:
      return d.errback(result.reference_exception)
    if result.attribute_exception is not None:
      return d.errback(result.attribute_exception)
    if result.type_exception is not None:
      return d.errback(result.type_exception)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "get_domain failed: unknown result"))

  def get_genetic_code(self, token, ref):
    """
    Retrieve the genetic code.


    Parameters:
     - token
     - ref
    """
    seqid = self._seqid = self._seqid + 1
    self._reqs[seqid] = defer.Deferred()

    d = defer.maybeDeferred(self.send_get_genetic_code, token, ref)
    d.addCallbacks(
      callback=self.cb_send_get_genetic_code,
      callbackArgs=(seqid,),
      errback=self.eb_send_get_genetic_code,
      errbackArgs=(seqid,))
    return d

  def cb_send_get_genetic_code(self, _, seqid):
    return self._reqs[seqid]

  def eb_send_get_genetic_code(self, f, seqid):
    d = self._reqs.pop(seqid)
    d.errback(f)
    return d

  def send_get_genetic_code(self, token, ref):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('get_genetic_code', TMessageType.CALL, self._seqid)
    args = get_genetic_code_args()
    args.token = token
    args.ref = ref
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_get_genetic_code(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = get_genetic_code_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    if result.generic_exception is not None:
      return d.errback(result.generic_exception)
    if result.authorization_exception is not None:
      return d.errback(result.authorization_exception)
    if result.authentication_exception is not None:
      return d.errback(result.authentication_exception)
    if result.reference_exception is not None:
      return d.errback(result.reference_exception)
    if result.attribute_exception is not None:
      return d.errback(result.attribute_exception)
    if result.type_exception is not None:
      return d.errback(result.type_exception)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "get_genetic_code failed: unknown result"))

  def get_aliases(self, token, ref):
    """
    Retrieve the aliases.


    Parameters:
     - token
     - ref
    """
    seqid = self._seqid = self._seqid + 1
    self._reqs[seqid] = defer.Deferred()

    d = defer.maybeDeferred(self.send_get_aliases, token, ref)
    d.addCallbacks(
      callback=self.cb_send_get_aliases,
      callbackArgs=(seqid,),
      errback=self.eb_send_get_aliases,
      errbackArgs=(seqid,))
    return d

  def cb_send_get_aliases(self, _, seqid):
    return self._reqs[seqid]

  def eb_send_get_aliases(self, f, seqid):
    d = self._reqs.pop(seqid)
    d.errback(f)
    return d

  def send_get_aliases(self, token, ref):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('get_aliases', TMessageType.CALL, self._seqid)
    args = get_aliases_args()
    args.token = token
    args.ref = ref
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_get_aliases(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = get_aliases_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    if result.generic_exception is not None:
      return d.errback(result.generic_exception)
    if result.authorization_exception is not None:
      return d.errback(result.authorization_exception)
    if result.authentication_exception is not None:
      return d.errback(result.authentication_exception)
    if result.reference_exception is not None:
      return d.errback(result.reference_exception)
    if result.attribute_exception is not None:
      return d.errback(result.attribute_exception)
    if result.type_exception is not None:
      return d.errback(result.type_exception)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "get_aliases failed: unknown result"))


class Processor(TProcessor):
  implements(Iface)

  def __init__(self, handler):
    self._handler = Iface(handler)
    self._processMap = {}
    self._processMap["get_info"] = Processor.process_get_info
    self._processMap["get_history"] = Processor.process_get_history
    self._processMap["get_provenance"] = Processor.process_get_provenance
    self._processMap["get_id"] = Processor.process_get_id
    self._processMap["get_name"] = Processor.process_get_name
    self._processMap["get_version"] = Processor.process_get_version
    self._processMap["get_parent"] = Processor.process_get_parent
    self._processMap["get_children"] = Processor.process_get_children
    self._processMap["get_genome_annotations"] = Processor.process_get_genome_annotations
    self._processMap["get_scientific_lineage"] = Processor.process_get_scientific_lineage
    self._processMap["get_scientific_name"] = Processor.process_get_scientific_name
    self._processMap["get_taxonomic_id"] = Processor.process_get_taxonomic_id
    self._processMap["get_kingdom"] = Processor.process_get_kingdom
    self._processMap["get_domain"] = Processor.process_get_domain
    self._processMap["get_genetic_code"] = Processor.process_get_genetic_code
    self._processMap["get_aliases"] = Processor.process_get_aliases

  def process(self, iprot, oprot):
    (name, type, seqid) = iprot.readMessageBegin()
    if name not in self._processMap:
      iprot.skip(TType.STRUCT)
      iprot.readMessageEnd()
      x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
      oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
      x.write(oprot)
      oprot.writeMessageEnd()
      oprot.trans.flush()
      return defer.succeed(None)
    else:
      return self._processMap[name](self, seqid, iprot, oprot)

  def process_get_info(self, seqid, iprot, oprot):
    args = get_info_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_info_result()
    d = defer.maybeDeferred(self._handler.get_info, args.token, args.ref)
    d.addCallback(self.write_results_success_get_info, result, seqid, oprot)
    d.addErrback(self.write_results_exception_get_info, result, seqid, oprot)
    return d

  def write_results_success_get_info(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("get_info", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def write_results_exception_get_info(self, error, result, seqid, oprot):
    try:
      error.raiseException()
    except ServiceException, generic_exception:
      result.generic_exception = generic_exception
    except AuthorizationException, authorization_exception:
      result.authorization_exception = authorization_exception
    except AuthenticationException, authentication_exception:
      result.authentication_exception = authentication_exception
    except ObjectReferenceException, reference_exception:
      result.reference_exception = reference_exception
    except AttributeException, attribute_exception:
      result.attribute_exception = attribute_exception
    except TypeException, type_exception:
      result.type_exception = type_exception
    oprot.writeMessageBegin("get_info", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_history(self, seqid, iprot, oprot):
    args = get_history_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_history_result()
    d = defer.maybeDeferred(self._handler.get_history, args.token, args.ref)
    d.addCallback(self.write_results_success_get_history, result, seqid, oprot)
    d.addErrback(self.write_results_exception_get_history, result, seqid, oprot)
    return d

  def write_results_success_get_history(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("get_history", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def write_results_exception_get_history(self, error, result, seqid, oprot):
    try:
      error.raiseException()
    except ServiceException, generic_exception:
      result.generic_exception = generic_exception
    except AuthorizationException, authorization_exception:
      result.authorization_exception = authorization_exception
    except AuthenticationException, authentication_exception:
      result.authentication_exception = authentication_exception
    except ObjectReferenceException, reference_exception:
      result.reference_exception = reference_exception
    except AttributeException, attribute_exception:
      result.attribute_exception = attribute_exception
    except TypeException, type_exception:
      result.type_exception = type_exception
    oprot.writeMessageBegin("get_history", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_provenance(self, seqid, iprot, oprot):
    args = get_provenance_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_provenance_result()
    d = defer.maybeDeferred(self._handler.get_provenance, args.token, args.ref)
    d.addCallback(self.write_results_success_get_provenance, result, seqid, oprot)
    d.addErrback(self.write_results_exception_get_provenance, result, seqid, oprot)
    return d

  def write_results_success_get_provenance(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("get_provenance", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def write_results_exception_get_provenance(self, error, result, seqid, oprot):
    try:
      error.raiseException()
    except ServiceException, generic_exception:
      result.generic_exception = generic_exception
    except AuthorizationException, authorization_exception:
      result.authorization_exception = authorization_exception
    except AuthenticationException, authentication_exception:
      result.authentication_exception = authentication_exception
    except ObjectReferenceException, reference_exception:
      result.reference_exception = reference_exception
    except AttributeException, attribute_exception:
      result.attribute_exception = attribute_exception
    except TypeException, type_exception:
      result.type_exception = type_exception
    oprot.writeMessageBegin("get_provenance", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_id(self, seqid, iprot, oprot):
    args = get_id_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_id_result()
    d = defer.maybeDeferred(self._handler.get_id, args.token, args.ref)
    d.addCallback(self.write_results_success_get_id, result, seqid, oprot)
    d.addErrback(self.write_results_exception_get_id, result, seqid, oprot)
    return d

  def write_results_success_get_id(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("get_id", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def write_results_exception_get_id(self, error, result, seqid, oprot):
    try:
      error.raiseException()
    except ServiceException, generic_exception:
      result.generic_exception = generic_exception
    except AuthorizationException, authorization_exception:
      result.authorization_exception = authorization_exception
    except AuthenticationException, authentication_exception:
      result.authentication_exception = authentication_exception
    except ObjectReferenceException, reference_exception:
      result.reference_exception = reference_exception
    except AttributeException, attribute_exception:
      result.attribute_exception = attribute_exception
    except TypeException, type_exception:
      result.type_exception = type_exception
    oprot.writeMessageBegin("get_id", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_name(self, seqid, iprot, oprot):
    args = get_name_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_name_result()
    d = defer.maybeDeferred(self._handler.get_name, args.token, args.ref)
    d.addCallback(self.write_results_success_get_name, result, seqid, oprot)
    d.addErrback(self.write_results_exception_get_name, result, seqid, oprot)
    return d

  def write_results_success_get_name(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("get_name", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def write_results_exception_get_name(self, error, result, seqid, oprot):
    try:
      error.raiseException()
    except ServiceException, generic_exception:
      result.generic_exception = generic_exception
    except AuthorizationException, authorization_exception:
      result.authorization_exception = authorization_exception
    except AuthenticationException, authentication_exception:
      result.authentication_exception = authentication_exception
    except ObjectReferenceException, reference_exception:
      result.reference_exception = reference_exception
    except AttributeException, attribute_exception:
      result.attribute_exception = attribute_exception
    except TypeException, type_exception:
      result.type_exception = type_exception
    oprot.writeMessageBegin("get_name", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_version(self, seqid, iprot, oprot):
    args = get_version_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_version_result()
    d = defer.maybeDeferred(self._handler.get_version, args.token, args.ref)
    d.addCallback(self.write_results_success_get_version, result, seqid, oprot)
    d.addErrback(self.write_results_exception_get_version, result, seqid, oprot)
    return d

  def write_results_success_get_version(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("get_version", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def write_results_exception_get_version(self, error, result, seqid, oprot):
    try:
      error.raiseException()
    except ServiceException, generic_exception:
      result.generic_exception = generic_exception
    except AuthorizationException, authorization_exception:
      result.authorization_exception = authorization_exception
    except AuthenticationException, authentication_exception:
      result.authentication_exception = authentication_exception
    except ObjectReferenceException, reference_exception:
      result.reference_exception = reference_exception
    except AttributeException, attribute_exception:
      result.attribute_exception = attribute_exception
    except TypeException, type_exception:
      result.type_exception = type_exception
    oprot.writeMessageBegin("get_version", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_parent(self, seqid, iprot, oprot):
    args = get_parent_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_parent_result()
    d = defer.maybeDeferred(self._handler.get_parent, args.token, args.ref)
    d.addCallback(self.write_results_success_get_parent, result, seqid, oprot)
    d.addErrback(self.write_results_exception_get_parent, result, seqid, oprot)
    return d

  def write_results_success_get_parent(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("get_parent", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def write_results_exception_get_parent(self, error, result, seqid, oprot):
    try:
      error.raiseException()
    except ServiceException, generic_exception:
      result.generic_exception = generic_exception
    except AuthorizationException, authorization_exception:
      result.authorization_exception = authorization_exception
    except AuthenticationException, authentication_exception:
      result.authentication_exception = authentication_exception
    except ObjectReferenceException, reference_exception:
      result.reference_exception = reference_exception
    except AttributeException, attribute_exception:
      result.attribute_exception = attribute_exception
    except TypeException, type_exception:
      result.type_exception = type_exception
    oprot.writeMessageBegin("get_parent", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_children(self, seqid, iprot, oprot):
    args = get_children_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_children_result()
    d = defer.maybeDeferred(self._handler.get_children, args.token, args.ref)
    d.addCallback(self.write_results_success_get_children, result, seqid, oprot)
    d.addErrback(self.write_results_exception_get_children, result, seqid, oprot)
    return d

  def write_results_success_get_children(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("get_children", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def write_results_exception_get_children(self, error, result, seqid, oprot):
    try:
      error.raiseException()
    except ServiceException, generic_exception:
      result.generic_exception = generic_exception
    except AuthorizationException, authorization_exception:
      result.authorization_exception = authorization_exception
    except AuthenticationException, authentication_exception:
      result.authentication_exception = authentication_exception
    except ObjectReferenceException, reference_exception:
      result.reference_exception = reference_exception
    except AttributeException, attribute_exception:
      result.attribute_exception = attribute_exception
    except TypeException, type_exception:
      result.type_exception = type_exception
    oprot.writeMessageBegin("get_children", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_genome_annotations(self, seqid, iprot, oprot):
    args = get_genome_annotations_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_genome_annotations_result()
    d = defer.maybeDeferred(self._handler.get_genome_annotations, args.token, args.ref)
    d.addCallback(self.write_results_success_get_genome_annotations, result, seqid, oprot)
    d.addErrback(self.write_results_exception_get_genome_annotations, result, seqid, oprot)
    return d

  def write_results_success_get_genome_annotations(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("get_genome_annotations", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def write_results_exception_get_genome_annotations(self, error, result, seqid, oprot):
    try:
      error.raiseException()
    except ServiceException, generic_exception:
      result.generic_exception = generic_exception
    except AuthorizationException, authorization_exception:
      result.authorization_exception = authorization_exception
    except AuthenticationException, authentication_exception:
      result.authentication_exception = authentication_exception
    except ObjectReferenceException, reference_exception:
      result.reference_exception = reference_exception
    except AttributeException, attribute_exception:
      result.attribute_exception = attribute_exception
    except TypeException, type_exception:
      result.type_exception = type_exception
    oprot.writeMessageBegin("get_genome_annotations", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_scientific_lineage(self, seqid, iprot, oprot):
    args = get_scientific_lineage_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_scientific_lineage_result()
    d = defer.maybeDeferred(self._handler.get_scientific_lineage, args.token, args.ref)
    d.addCallback(self.write_results_success_get_scientific_lineage, result, seqid, oprot)
    d.addErrback(self.write_results_exception_get_scientific_lineage, result, seqid, oprot)
    return d

  def write_results_success_get_scientific_lineage(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("get_scientific_lineage", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def write_results_exception_get_scientific_lineage(self, error, result, seqid, oprot):
    try:
      error.raiseException()
    except ServiceException, generic_exception:
      result.generic_exception = generic_exception
    except AuthorizationException, authorization_exception:
      result.authorization_exception = authorization_exception
    except AuthenticationException, authentication_exception:
      result.authentication_exception = authentication_exception
    except ObjectReferenceException, reference_exception:
      result.reference_exception = reference_exception
    except AttributeException, attribute_exception:
      result.attribute_exception = attribute_exception
    except TypeException, type_exception:
      result.type_exception = type_exception
    oprot.writeMessageBegin("get_scientific_lineage", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_scientific_name(self, seqid, iprot, oprot):
    args = get_scientific_name_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_scientific_name_result()
    d = defer.maybeDeferred(self._handler.get_scientific_name, args.token, args.ref)
    d.addCallback(self.write_results_success_get_scientific_name, result, seqid, oprot)
    d.addErrback(self.write_results_exception_get_scientific_name, result, seqid, oprot)
    return d

  def write_results_success_get_scientific_name(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("get_scientific_name", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def write_results_exception_get_scientific_name(self, error, result, seqid, oprot):
    try:
      error.raiseException()
    except ServiceException, generic_exception:
      result.generic_exception = generic_exception
    except AuthorizationException, authorization_exception:
      result.authorization_exception = authorization_exception
    except AuthenticationException, authentication_exception:
      result.authentication_exception = authentication_exception
    except ObjectReferenceException, reference_exception:
      result.reference_exception = reference_exception
    except AttributeException, attribute_exception:
      result.attribute_exception = attribute_exception
    except TypeException, type_exception:
      result.type_exception = type_exception
    oprot.writeMessageBegin("get_scientific_name", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_taxonomic_id(self, seqid, iprot, oprot):
    args = get_taxonomic_id_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_taxonomic_id_result()
    d = defer.maybeDeferred(self._handler.get_taxonomic_id, args.token, args.ref)
    d.addCallback(self.write_results_success_get_taxonomic_id, result, seqid, oprot)
    d.addErrback(self.write_results_exception_get_taxonomic_id, result, seqid, oprot)
    return d

  def write_results_success_get_taxonomic_id(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("get_taxonomic_id", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def write_results_exception_get_taxonomic_id(self, error, result, seqid, oprot):
    try:
      error.raiseException()
    except ServiceException, generic_exception:
      result.generic_exception = generic_exception
    except AuthorizationException, authorization_exception:
      result.authorization_exception = authorization_exception
    except AuthenticationException, authentication_exception:
      result.authentication_exception = authentication_exception
    except ObjectReferenceException, reference_exception:
      result.reference_exception = reference_exception
    except AttributeException, attribute_exception:
      result.attribute_exception = attribute_exception
    except TypeException, type_exception:
      result.type_exception = type_exception
    oprot.writeMessageBegin("get_taxonomic_id", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_kingdom(self, seqid, iprot, oprot):
    args = get_kingdom_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_kingdom_result()
    d = defer.maybeDeferred(self._handler.get_kingdom, args.token, args.ref)
    d.addCallback(self.write_results_success_get_kingdom, result, seqid, oprot)
    d.addErrback(self.write_results_exception_get_kingdom, result, seqid, oprot)
    return d

  def write_results_success_get_kingdom(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("get_kingdom", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def write_results_exception_get_kingdom(self, error, result, seqid, oprot):
    try:
      error.raiseException()
    except ServiceException, generic_exception:
      result.generic_exception = generic_exception
    except AuthorizationException, authorization_exception:
      result.authorization_exception = authorization_exception
    except AuthenticationException, authentication_exception:
      result.authentication_exception = authentication_exception
    except ObjectReferenceException, reference_exception:
      result.reference_exception = reference_exception
    except AttributeException, attribute_exception:
      result.attribute_exception = attribute_exception
    except TypeException, type_exception:
      result.type_exception = type_exception
    oprot.writeMessageBegin("get_kingdom", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_domain(self, seqid, iprot, oprot):
    args = get_domain_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_domain_result()
    d = defer.maybeDeferred(self._handler.get_domain, args.token, args.ref)
    d.addCallback(self.write_results_success_get_domain, result, seqid, oprot)
    d.addErrback(self.write_results_exception_get_domain, result, seqid, oprot)
    return d

  def write_results_success_get_domain(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("get_domain", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def write_results_exception_get_domain(self, error, result, seqid, oprot):
    try:
      error.raiseException()
    except ServiceException, generic_exception:
      result.generic_exception = generic_exception
    except AuthorizationException, authorization_exception:
      result.authorization_exception = authorization_exception
    except AuthenticationException, authentication_exception:
      result.authentication_exception = authentication_exception
    except ObjectReferenceException, reference_exception:
      result.reference_exception = reference_exception
    except AttributeException, attribute_exception:
      result.attribute_exception = attribute_exception
    except TypeException, type_exception:
      result.type_exception = type_exception
    oprot.writeMessageBegin("get_domain", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_genetic_code(self, seqid, iprot, oprot):
    args = get_genetic_code_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_genetic_code_result()
    d = defer.maybeDeferred(self._handler.get_genetic_code, args.token, args.ref)
    d.addCallback(self.write_results_success_get_genetic_code, result, seqid, oprot)
    d.addErrback(self.write_results_exception_get_genetic_code, result, seqid, oprot)
    return d

  def write_results_success_get_genetic_code(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("get_genetic_code", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def write_results_exception_get_genetic_code(self, error, result, seqid, oprot):
    try:
      error.raiseException()
    except ServiceException, generic_exception:
      result.generic_exception = generic_exception
    except AuthorizationException, authorization_exception:
      result.authorization_exception = authorization_exception
    except AuthenticationException, authentication_exception:
      result.authentication_exception = authentication_exception
    except ObjectReferenceException, reference_exception:
      result.reference_exception = reference_exception
    except AttributeException, attribute_exception:
      result.attribute_exception = attribute_exception
    except TypeException, type_exception:
      result.type_exception = type_exception
    oprot.writeMessageBegin("get_genetic_code", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_aliases(self, seqid, iprot, oprot):
    args = get_aliases_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_aliases_result()
    d = defer.maybeDeferred(self._handler.get_aliases, args.token, args.ref)
    d.addCallback(self.write_results_success_get_aliases, result, seqid, oprot)
    d.addErrback(self.write_results_exception_get_aliases, result, seqid, oprot)
    return d

  def write_results_success_get_aliases(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("get_aliases", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def write_results_exception_get_aliases(self, error, result, seqid, oprot):
    try:
      error.raiseException()
    except ServiceException, generic_exception:
      result.generic_exception = generic_exception
    except AuthorizationException, authorization_exception:
      result.authorization_exception = authorization_exception
    except AuthenticationException, authentication_exception:
      result.authentication_exception = authentication_exception
    except ObjectReferenceException, reference_exception:
      result.reference_exception = reference_exception
    except AttributeException, attribute_exception:
      result.attribute_exception = attribute_exception
    except TypeException, type_exception:
      result.type_exception = type_exception
    oprot.writeMessageBegin("get_aliases", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()


# HELPER FUNCTIONS AND STRUCTURES

class get_info_args:
  """
  Attributes:
   - token
   - ref
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token', None, None, ), # 1
    (2, TType.STRING, 'ref', None, None, ), # 2
  )

  def __init__(self, token=None, ref=None,):
    self.token = token
    self.ref = ref

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ref = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_info_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 1)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    if self.ref is not None:
      oprot.writeFieldBegin('ref', TType.STRING, 2)
      oprot.writeString(self.ref)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.token)
    value = (value * 31) ^ hash(self.ref)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_info_result:
  """
  Attributes:
   - success
   - generic_exception
   - authorization_exception
   - authentication_exception
   - reference_exception
   - attribute_exception
   - type_exception
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (ObjectInfo, ObjectInfo.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'generic_exception', (ServiceException, ServiceException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'authorization_exception', (AuthorizationException, AuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'authentication_exception', (AuthenticationException, AuthenticationException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'reference_exception', (ObjectReferenceException, ObjectReferenceException.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'attribute_exception', (AttributeException, AttributeException.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'type_exception', (TypeException, TypeException.thrift_spec), None, ), # 6
  )

  def __init__(self, success=None, generic_exception=None, authorization_exception=None, authentication_exception=None, reference_exception=None, attribute_exception=None, type_exception=None,):
    self.success = success
    self.generic_exception = generic_exception
    self.authorization_exception = authorization_exception
    self.authentication_exception = authentication_exception
    self.reference_exception = reference_exception
    self.attribute_exception = attribute_exception
    self.type_exception = type_exception

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = ObjectInfo()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_exception = ServiceException()
          self.generic_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.authorization_exception = AuthorizationException()
          self.authorization_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.authentication_exception = AuthenticationException()
          self.authentication_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.reference_exception = ObjectReferenceException()
          self.reference_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.attribute_exception = AttributeException()
          self.attribute_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.type_exception = TypeException()
          self.type_exception.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_info_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.generic_exception is not None:
      oprot.writeFieldBegin('generic_exception', TType.STRUCT, 1)
      self.generic_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authorization_exception is not None:
      oprot.writeFieldBegin('authorization_exception', TType.STRUCT, 2)
      self.authorization_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authentication_exception is not None:
      oprot.writeFieldBegin('authentication_exception', TType.STRUCT, 3)
      self.authentication_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.reference_exception is not None:
      oprot.writeFieldBegin('reference_exception', TType.STRUCT, 4)
      self.reference_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.attribute_exception is not None:
      oprot.writeFieldBegin('attribute_exception', TType.STRUCT, 5)
      self.attribute_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.type_exception is not None:
      oprot.writeFieldBegin('type_exception', TType.STRUCT, 6)
      self.type_exception.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.generic_exception)
    value = (value * 31) ^ hash(self.authorization_exception)
    value = (value * 31) ^ hash(self.authentication_exception)
    value = (value * 31) ^ hash(self.reference_exception)
    value = (value * 31) ^ hash(self.attribute_exception)
    value = (value * 31) ^ hash(self.type_exception)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_history_args:
  """
  Attributes:
   - token
   - ref
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token', None, None, ), # 1
    (2, TType.STRING, 'ref', None, None, ), # 2
  )

  def __init__(self, token=None, ref=None,):
    self.token = token
    self.ref = ref

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ref = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_history_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 1)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    if self.ref is not None:
      oprot.writeFieldBegin('ref', TType.STRING, 2)
      oprot.writeString(self.ref)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.token)
    value = (value * 31) ^ hash(self.ref)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_history_result:
  """
  Attributes:
   - success
   - generic_exception
   - authorization_exception
   - authentication_exception
   - reference_exception
   - attribute_exception
   - type_exception
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(ObjectInfo, ObjectInfo.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'generic_exception', (ServiceException, ServiceException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'authorization_exception', (AuthorizationException, AuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'authentication_exception', (AuthenticationException, AuthenticationException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'reference_exception', (ObjectReferenceException, ObjectReferenceException.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'attribute_exception', (AttributeException, AttributeException.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'type_exception', (TypeException, TypeException.thrift_spec), None, ), # 6
  )

  def __init__(self, success=None, generic_exception=None, authorization_exception=None, authentication_exception=None, reference_exception=None, attribute_exception=None, type_exception=None,):
    self.success = success
    self.generic_exception = generic_exception
    self.authorization_exception = authorization_exception
    self.authentication_exception = authentication_exception
    self.reference_exception = reference_exception
    self.attribute_exception = attribute_exception
    self.type_exception = type_exception

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype70, _size67) = iprot.readListBegin()
          for _i71 in xrange(_size67):
            _elem72 = ObjectInfo()
            _elem72.read(iprot)
            self.success.append(_elem72)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_exception = ServiceException()
          self.generic_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.authorization_exception = AuthorizationException()
          self.authorization_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.authentication_exception = AuthenticationException()
          self.authentication_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.reference_exception = ObjectReferenceException()
          self.reference_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.attribute_exception = AttributeException()
          self.attribute_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.type_exception = TypeException()
          self.type_exception.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_history_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter73 in self.success:
        iter73.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.generic_exception is not None:
      oprot.writeFieldBegin('generic_exception', TType.STRUCT, 1)
      self.generic_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authorization_exception is not None:
      oprot.writeFieldBegin('authorization_exception', TType.STRUCT, 2)
      self.authorization_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authentication_exception is not None:
      oprot.writeFieldBegin('authentication_exception', TType.STRUCT, 3)
      self.authentication_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.reference_exception is not None:
      oprot.writeFieldBegin('reference_exception', TType.STRUCT, 4)
      self.reference_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.attribute_exception is not None:
      oprot.writeFieldBegin('attribute_exception', TType.STRUCT, 5)
      self.attribute_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.type_exception is not None:
      oprot.writeFieldBegin('type_exception', TType.STRUCT, 6)
      self.type_exception.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.generic_exception)
    value = (value * 31) ^ hash(self.authorization_exception)
    value = (value * 31) ^ hash(self.authentication_exception)
    value = (value * 31) ^ hash(self.reference_exception)
    value = (value * 31) ^ hash(self.attribute_exception)
    value = (value * 31) ^ hash(self.type_exception)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_provenance_args:
  """
  Attributes:
   - token
   - ref
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token', None, None, ), # 1
    (2, TType.STRING, 'ref', None, None, ), # 2
  )

  def __init__(self, token=None, ref=None,):
    self.token = token
    self.ref = ref

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ref = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_provenance_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 1)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    if self.ref is not None:
      oprot.writeFieldBegin('ref', TType.STRING, 2)
      oprot.writeString(self.ref)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.token)
    value = (value * 31) ^ hash(self.ref)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_provenance_result:
  """
  Attributes:
   - success
   - generic_exception
   - authorization_exception
   - authentication_exception
   - reference_exception
   - attribute_exception
   - type_exception
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(ObjectProvenanceAction, ObjectProvenanceAction.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'generic_exception', (ServiceException, ServiceException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'authorization_exception', (AuthorizationException, AuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'authentication_exception', (AuthenticationException, AuthenticationException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'reference_exception', (ObjectReferenceException, ObjectReferenceException.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'attribute_exception', (AttributeException, AttributeException.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'type_exception', (TypeException, TypeException.thrift_spec), None, ), # 6
  )

  def __init__(self, success=None, generic_exception=None, authorization_exception=None, authentication_exception=None, reference_exception=None, attribute_exception=None, type_exception=None,):
    self.success = success
    self.generic_exception = generic_exception
    self.authorization_exception = authorization_exception
    self.authentication_exception = authentication_exception
    self.reference_exception = reference_exception
    self.attribute_exception = attribute_exception
    self.type_exception = type_exception

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype77, _size74) = iprot.readListBegin()
          for _i78 in xrange(_size74):
            _elem79 = ObjectProvenanceAction()
            _elem79.read(iprot)
            self.success.append(_elem79)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_exception = ServiceException()
          self.generic_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.authorization_exception = AuthorizationException()
          self.authorization_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.authentication_exception = AuthenticationException()
          self.authentication_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.reference_exception = ObjectReferenceException()
          self.reference_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.attribute_exception = AttributeException()
          self.attribute_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.type_exception = TypeException()
          self.type_exception.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_provenance_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter80 in self.success:
        iter80.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.generic_exception is not None:
      oprot.writeFieldBegin('generic_exception', TType.STRUCT, 1)
      self.generic_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authorization_exception is not None:
      oprot.writeFieldBegin('authorization_exception', TType.STRUCT, 2)
      self.authorization_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authentication_exception is not None:
      oprot.writeFieldBegin('authentication_exception', TType.STRUCT, 3)
      self.authentication_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.reference_exception is not None:
      oprot.writeFieldBegin('reference_exception', TType.STRUCT, 4)
      self.reference_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.attribute_exception is not None:
      oprot.writeFieldBegin('attribute_exception', TType.STRUCT, 5)
      self.attribute_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.type_exception is not None:
      oprot.writeFieldBegin('type_exception', TType.STRUCT, 6)
      self.type_exception.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.generic_exception)
    value = (value * 31) ^ hash(self.authorization_exception)
    value = (value * 31) ^ hash(self.authentication_exception)
    value = (value * 31) ^ hash(self.reference_exception)
    value = (value * 31) ^ hash(self.attribute_exception)
    value = (value * 31) ^ hash(self.type_exception)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_id_args:
  """
  Attributes:
   - token
   - ref
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token', None, None, ), # 1
    (2, TType.STRING, 'ref', None, None, ), # 2
  )

  def __init__(self, token=None, ref=None,):
    self.token = token
    self.ref = ref

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ref = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_id_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 1)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    if self.ref is not None:
      oprot.writeFieldBegin('ref', TType.STRING, 2)
      oprot.writeString(self.ref)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.token)
    value = (value * 31) ^ hash(self.ref)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_id_result:
  """
  Attributes:
   - success
   - generic_exception
   - authorization_exception
   - authentication_exception
   - reference_exception
   - attribute_exception
   - type_exception
  """

  thrift_spec = (
    (0, TType.I64, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'generic_exception', (ServiceException, ServiceException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'authorization_exception', (AuthorizationException, AuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'authentication_exception', (AuthenticationException, AuthenticationException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'reference_exception', (ObjectReferenceException, ObjectReferenceException.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'attribute_exception', (AttributeException, AttributeException.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'type_exception', (TypeException, TypeException.thrift_spec), None, ), # 6
  )

  def __init__(self, success=None, generic_exception=None, authorization_exception=None, authentication_exception=None, reference_exception=None, attribute_exception=None, type_exception=None,):
    self.success = success
    self.generic_exception = generic_exception
    self.authorization_exception = authorization_exception
    self.authentication_exception = authentication_exception
    self.reference_exception = reference_exception
    self.attribute_exception = attribute_exception
    self.type_exception = type_exception

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I64:
          self.success = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_exception = ServiceException()
          self.generic_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.authorization_exception = AuthorizationException()
          self.authorization_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.authentication_exception = AuthenticationException()
          self.authentication_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.reference_exception = ObjectReferenceException()
          self.reference_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.attribute_exception = AttributeException()
          self.attribute_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.type_exception = TypeException()
          self.type_exception.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_id_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I64, 0)
      oprot.writeI64(self.success)
      oprot.writeFieldEnd()
    if self.generic_exception is not None:
      oprot.writeFieldBegin('generic_exception', TType.STRUCT, 1)
      self.generic_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authorization_exception is not None:
      oprot.writeFieldBegin('authorization_exception', TType.STRUCT, 2)
      self.authorization_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authentication_exception is not None:
      oprot.writeFieldBegin('authentication_exception', TType.STRUCT, 3)
      self.authentication_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.reference_exception is not None:
      oprot.writeFieldBegin('reference_exception', TType.STRUCT, 4)
      self.reference_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.attribute_exception is not None:
      oprot.writeFieldBegin('attribute_exception', TType.STRUCT, 5)
      self.attribute_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.type_exception is not None:
      oprot.writeFieldBegin('type_exception', TType.STRUCT, 6)
      self.type_exception.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.generic_exception)
    value = (value * 31) ^ hash(self.authorization_exception)
    value = (value * 31) ^ hash(self.authentication_exception)
    value = (value * 31) ^ hash(self.reference_exception)
    value = (value * 31) ^ hash(self.attribute_exception)
    value = (value * 31) ^ hash(self.type_exception)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_name_args:
  """
  Attributes:
   - token
   - ref
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token', None, None, ), # 1
    (2, TType.STRING, 'ref', None, None, ), # 2
  )

  def __init__(self, token=None, ref=None,):
    self.token = token
    self.ref = ref

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ref = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_name_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 1)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    if self.ref is not None:
      oprot.writeFieldBegin('ref', TType.STRING, 2)
      oprot.writeString(self.ref)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.token)
    value = (value * 31) ^ hash(self.ref)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_name_result:
  """
  Attributes:
   - success
   - generic_exception
   - authorization_exception
   - authentication_exception
   - reference_exception
   - attribute_exception
   - type_exception
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'generic_exception', (ServiceException, ServiceException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'authorization_exception', (AuthorizationException, AuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'authentication_exception', (AuthenticationException, AuthenticationException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'reference_exception', (ObjectReferenceException, ObjectReferenceException.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'attribute_exception', (AttributeException, AttributeException.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'type_exception', (TypeException, TypeException.thrift_spec), None, ), # 6
  )

  def __init__(self, success=None, generic_exception=None, authorization_exception=None, authentication_exception=None, reference_exception=None, attribute_exception=None, type_exception=None,):
    self.success = success
    self.generic_exception = generic_exception
    self.authorization_exception = authorization_exception
    self.authentication_exception = authentication_exception
    self.reference_exception = reference_exception
    self.attribute_exception = attribute_exception
    self.type_exception = type_exception

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_exception = ServiceException()
          self.generic_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.authorization_exception = AuthorizationException()
          self.authorization_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.authentication_exception = AuthenticationException()
          self.authentication_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.reference_exception = ObjectReferenceException()
          self.reference_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.attribute_exception = AttributeException()
          self.attribute_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.type_exception = TypeException()
          self.type_exception.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_name_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.generic_exception is not None:
      oprot.writeFieldBegin('generic_exception', TType.STRUCT, 1)
      self.generic_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authorization_exception is not None:
      oprot.writeFieldBegin('authorization_exception', TType.STRUCT, 2)
      self.authorization_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authentication_exception is not None:
      oprot.writeFieldBegin('authentication_exception', TType.STRUCT, 3)
      self.authentication_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.reference_exception is not None:
      oprot.writeFieldBegin('reference_exception', TType.STRUCT, 4)
      self.reference_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.attribute_exception is not None:
      oprot.writeFieldBegin('attribute_exception', TType.STRUCT, 5)
      self.attribute_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.type_exception is not None:
      oprot.writeFieldBegin('type_exception', TType.STRUCT, 6)
      self.type_exception.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.generic_exception)
    value = (value * 31) ^ hash(self.authorization_exception)
    value = (value * 31) ^ hash(self.authentication_exception)
    value = (value * 31) ^ hash(self.reference_exception)
    value = (value * 31) ^ hash(self.attribute_exception)
    value = (value * 31) ^ hash(self.type_exception)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_version_args:
  """
  Attributes:
   - token
   - ref
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token', None, None, ), # 1
    (2, TType.STRING, 'ref', None, None, ), # 2
  )

  def __init__(self, token=None, ref=None,):
    self.token = token
    self.ref = ref

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ref = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_version_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 1)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    if self.ref is not None:
      oprot.writeFieldBegin('ref', TType.STRING, 2)
      oprot.writeString(self.ref)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.token)
    value = (value * 31) ^ hash(self.ref)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_version_result:
  """
  Attributes:
   - success
   - generic_exception
   - authorization_exception
   - authentication_exception
   - reference_exception
   - attribute_exception
   - type_exception
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'generic_exception', (ServiceException, ServiceException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'authorization_exception', (AuthorizationException, AuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'authentication_exception', (AuthenticationException, AuthenticationException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'reference_exception', (ObjectReferenceException, ObjectReferenceException.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'attribute_exception', (AttributeException, AttributeException.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'type_exception', (TypeException, TypeException.thrift_spec), None, ), # 6
  )

  def __init__(self, success=None, generic_exception=None, authorization_exception=None, authentication_exception=None, reference_exception=None, attribute_exception=None, type_exception=None,):
    self.success = success
    self.generic_exception = generic_exception
    self.authorization_exception = authorization_exception
    self.authentication_exception = authentication_exception
    self.reference_exception = reference_exception
    self.attribute_exception = attribute_exception
    self.type_exception = type_exception

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_exception = ServiceException()
          self.generic_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.authorization_exception = AuthorizationException()
          self.authorization_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.authentication_exception = AuthenticationException()
          self.authentication_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.reference_exception = ObjectReferenceException()
          self.reference_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.attribute_exception = AttributeException()
          self.attribute_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.type_exception = TypeException()
          self.type_exception.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_version_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.generic_exception is not None:
      oprot.writeFieldBegin('generic_exception', TType.STRUCT, 1)
      self.generic_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authorization_exception is not None:
      oprot.writeFieldBegin('authorization_exception', TType.STRUCT, 2)
      self.authorization_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authentication_exception is not None:
      oprot.writeFieldBegin('authentication_exception', TType.STRUCT, 3)
      self.authentication_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.reference_exception is not None:
      oprot.writeFieldBegin('reference_exception', TType.STRUCT, 4)
      self.reference_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.attribute_exception is not None:
      oprot.writeFieldBegin('attribute_exception', TType.STRUCT, 5)
      self.attribute_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.type_exception is not None:
      oprot.writeFieldBegin('type_exception', TType.STRUCT, 6)
      self.type_exception.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.generic_exception)
    value = (value * 31) ^ hash(self.authorization_exception)
    value = (value * 31) ^ hash(self.authentication_exception)
    value = (value * 31) ^ hash(self.reference_exception)
    value = (value * 31) ^ hash(self.attribute_exception)
    value = (value * 31) ^ hash(self.type_exception)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_parent_args:
  """
  Attributes:
   - token
   - ref
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token', None, None, ), # 1
    (2, TType.STRING, 'ref', None, None, ), # 2
  )

  def __init__(self, token=None, ref=None,):
    self.token = token
    self.ref = ref

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ref = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_parent_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 1)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    if self.ref is not None:
      oprot.writeFieldBegin('ref', TType.STRING, 2)
      oprot.writeString(self.ref)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.token)
    value = (value * 31) ^ hash(self.ref)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_parent_result:
  """
  Attributes:
   - success
   - generic_exception
   - authorization_exception
   - authentication_exception
   - reference_exception
   - attribute_exception
   - type_exception
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'generic_exception', (ServiceException, ServiceException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'authorization_exception', (AuthorizationException, AuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'authentication_exception', (AuthenticationException, AuthenticationException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'reference_exception', (ObjectReferenceException, ObjectReferenceException.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'attribute_exception', (AttributeException, AttributeException.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'type_exception', (TypeException, TypeException.thrift_spec), None, ), # 6
  )

  def __init__(self, success=None, generic_exception=None, authorization_exception=None, authentication_exception=None, reference_exception=None, attribute_exception=None, type_exception=None,):
    self.success = success
    self.generic_exception = generic_exception
    self.authorization_exception = authorization_exception
    self.authentication_exception = authentication_exception
    self.reference_exception = reference_exception
    self.attribute_exception = attribute_exception
    self.type_exception = type_exception

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_exception = ServiceException()
          self.generic_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.authorization_exception = AuthorizationException()
          self.authorization_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.authentication_exception = AuthenticationException()
          self.authentication_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.reference_exception = ObjectReferenceException()
          self.reference_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.attribute_exception = AttributeException()
          self.attribute_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.type_exception = TypeException()
          self.type_exception.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_parent_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.generic_exception is not None:
      oprot.writeFieldBegin('generic_exception', TType.STRUCT, 1)
      self.generic_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authorization_exception is not None:
      oprot.writeFieldBegin('authorization_exception', TType.STRUCT, 2)
      self.authorization_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authentication_exception is not None:
      oprot.writeFieldBegin('authentication_exception', TType.STRUCT, 3)
      self.authentication_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.reference_exception is not None:
      oprot.writeFieldBegin('reference_exception', TType.STRUCT, 4)
      self.reference_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.attribute_exception is not None:
      oprot.writeFieldBegin('attribute_exception', TType.STRUCT, 5)
      self.attribute_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.type_exception is not None:
      oprot.writeFieldBegin('type_exception', TType.STRUCT, 6)
      self.type_exception.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.generic_exception)
    value = (value * 31) ^ hash(self.authorization_exception)
    value = (value * 31) ^ hash(self.authentication_exception)
    value = (value * 31) ^ hash(self.reference_exception)
    value = (value * 31) ^ hash(self.attribute_exception)
    value = (value * 31) ^ hash(self.type_exception)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_children_args:
  """
  Attributes:
   - token
   - ref
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token', None, None, ), # 1
    (2, TType.STRING, 'ref', None, None, ), # 2
  )

  def __init__(self, token=None, ref=None,):
    self.token = token
    self.ref = ref

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ref = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_children_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 1)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    if self.ref is not None:
      oprot.writeFieldBegin('ref', TType.STRING, 2)
      oprot.writeString(self.ref)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.token)
    value = (value * 31) ^ hash(self.ref)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_children_result:
  """
  Attributes:
   - success
   - generic_exception
   - authorization_exception
   - authentication_exception
   - reference_exception
   - attribute_exception
   - type_exception
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'generic_exception', (ServiceException, ServiceException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'authorization_exception', (AuthorizationException, AuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'authentication_exception', (AuthenticationException, AuthenticationException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'reference_exception', (ObjectReferenceException, ObjectReferenceException.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'attribute_exception', (AttributeException, AttributeException.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'type_exception', (TypeException, TypeException.thrift_spec), None, ), # 6
  )

  def __init__(self, success=None, generic_exception=None, authorization_exception=None, authentication_exception=None, reference_exception=None, attribute_exception=None, type_exception=None,):
    self.success = success
    self.generic_exception = generic_exception
    self.authorization_exception = authorization_exception
    self.authentication_exception = authentication_exception
    self.reference_exception = reference_exception
    self.attribute_exception = attribute_exception
    self.type_exception = type_exception

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype84, _size81) = iprot.readListBegin()
          for _i85 in xrange(_size81):
            _elem86 = iprot.readString();
            self.success.append(_elem86)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_exception = ServiceException()
          self.generic_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.authorization_exception = AuthorizationException()
          self.authorization_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.authentication_exception = AuthenticationException()
          self.authentication_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.reference_exception = ObjectReferenceException()
          self.reference_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.attribute_exception = AttributeException()
          self.attribute_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.type_exception = TypeException()
          self.type_exception.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_children_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter87 in self.success:
        oprot.writeString(iter87)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.generic_exception is not None:
      oprot.writeFieldBegin('generic_exception', TType.STRUCT, 1)
      self.generic_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authorization_exception is not None:
      oprot.writeFieldBegin('authorization_exception', TType.STRUCT, 2)
      self.authorization_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authentication_exception is not None:
      oprot.writeFieldBegin('authentication_exception', TType.STRUCT, 3)
      self.authentication_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.reference_exception is not None:
      oprot.writeFieldBegin('reference_exception', TType.STRUCT, 4)
      self.reference_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.attribute_exception is not None:
      oprot.writeFieldBegin('attribute_exception', TType.STRUCT, 5)
      self.attribute_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.type_exception is not None:
      oprot.writeFieldBegin('type_exception', TType.STRUCT, 6)
      self.type_exception.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.generic_exception)
    value = (value * 31) ^ hash(self.authorization_exception)
    value = (value * 31) ^ hash(self.authentication_exception)
    value = (value * 31) ^ hash(self.reference_exception)
    value = (value * 31) ^ hash(self.attribute_exception)
    value = (value * 31) ^ hash(self.type_exception)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_genome_annotations_args:
  """
  Attributes:
   - token
   - ref
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token', None, None, ), # 1
    (2, TType.STRING, 'ref', None, None, ), # 2
  )

  def __init__(self, token=None, ref=None,):
    self.token = token
    self.ref = ref

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ref = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_genome_annotations_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 1)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    if self.ref is not None:
      oprot.writeFieldBegin('ref', TType.STRING, 2)
      oprot.writeString(self.ref)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.token)
    value = (value * 31) ^ hash(self.ref)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_genome_annotations_result:
  """
  Attributes:
   - success
   - generic_exception
   - authorization_exception
   - authentication_exception
   - reference_exception
   - attribute_exception
   - type_exception
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'generic_exception', (ServiceException, ServiceException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'authorization_exception', (AuthorizationException, AuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'authentication_exception', (AuthenticationException, AuthenticationException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'reference_exception', (ObjectReferenceException, ObjectReferenceException.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'attribute_exception', (AttributeException, AttributeException.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'type_exception', (TypeException, TypeException.thrift_spec), None, ), # 6
  )

  def __init__(self, success=None, generic_exception=None, authorization_exception=None, authentication_exception=None, reference_exception=None, attribute_exception=None, type_exception=None,):
    self.success = success
    self.generic_exception = generic_exception
    self.authorization_exception = authorization_exception
    self.authentication_exception = authentication_exception
    self.reference_exception = reference_exception
    self.attribute_exception = attribute_exception
    self.type_exception = type_exception

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype91, _size88) = iprot.readListBegin()
          for _i92 in xrange(_size88):
            _elem93 = iprot.readString();
            self.success.append(_elem93)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_exception = ServiceException()
          self.generic_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.authorization_exception = AuthorizationException()
          self.authorization_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.authentication_exception = AuthenticationException()
          self.authentication_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.reference_exception = ObjectReferenceException()
          self.reference_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.attribute_exception = AttributeException()
          self.attribute_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.type_exception = TypeException()
          self.type_exception.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_genome_annotations_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter94 in self.success:
        oprot.writeString(iter94)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.generic_exception is not None:
      oprot.writeFieldBegin('generic_exception', TType.STRUCT, 1)
      self.generic_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authorization_exception is not None:
      oprot.writeFieldBegin('authorization_exception', TType.STRUCT, 2)
      self.authorization_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authentication_exception is not None:
      oprot.writeFieldBegin('authentication_exception', TType.STRUCT, 3)
      self.authentication_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.reference_exception is not None:
      oprot.writeFieldBegin('reference_exception', TType.STRUCT, 4)
      self.reference_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.attribute_exception is not None:
      oprot.writeFieldBegin('attribute_exception', TType.STRUCT, 5)
      self.attribute_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.type_exception is not None:
      oprot.writeFieldBegin('type_exception', TType.STRUCT, 6)
      self.type_exception.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.generic_exception)
    value = (value * 31) ^ hash(self.authorization_exception)
    value = (value * 31) ^ hash(self.authentication_exception)
    value = (value * 31) ^ hash(self.reference_exception)
    value = (value * 31) ^ hash(self.attribute_exception)
    value = (value * 31) ^ hash(self.type_exception)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_scientific_lineage_args:
  """
  Attributes:
   - token
   - ref
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token', None, None, ), # 1
    (2, TType.STRING, 'ref', None, None, ), # 2
  )

  def __init__(self, token=None, ref=None,):
    self.token = token
    self.ref = ref

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ref = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_scientific_lineage_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 1)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    if self.ref is not None:
      oprot.writeFieldBegin('ref', TType.STRING, 2)
      oprot.writeString(self.ref)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.token)
    value = (value * 31) ^ hash(self.ref)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_scientific_lineage_result:
  """
  Attributes:
   - success
   - generic_exception
   - authorization_exception
   - authentication_exception
   - reference_exception
   - attribute_exception
   - type_exception
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'generic_exception', (ServiceException, ServiceException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'authorization_exception', (AuthorizationException, AuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'authentication_exception', (AuthenticationException, AuthenticationException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'reference_exception', (ObjectReferenceException, ObjectReferenceException.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'attribute_exception', (AttributeException, AttributeException.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'type_exception', (TypeException, TypeException.thrift_spec), None, ), # 6
  )

  def __init__(self, success=None, generic_exception=None, authorization_exception=None, authentication_exception=None, reference_exception=None, attribute_exception=None, type_exception=None,):
    self.success = success
    self.generic_exception = generic_exception
    self.authorization_exception = authorization_exception
    self.authentication_exception = authentication_exception
    self.reference_exception = reference_exception
    self.attribute_exception = attribute_exception
    self.type_exception = type_exception

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype98, _size95) = iprot.readListBegin()
          for _i99 in xrange(_size95):
            _elem100 = iprot.readString();
            self.success.append(_elem100)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_exception = ServiceException()
          self.generic_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.authorization_exception = AuthorizationException()
          self.authorization_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.authentication_exception = AuthenticationException()
          self.authentication_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.reference_exception = ObjectReferenceException()
          self.reference_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.attribute_exception = AttributeException()
          self.attribute_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.type_exception = TypeException()
          self.type_exception.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_scientific_lineage_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter101 in self.success:
        oprot.writeString(iter101)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.generic_exception is not None:
      oprot.writeFieldBegin('generic_exception', TType.STRUCT, 1)
      self.generic_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authorization_exception is not None:
      oprot.writeFieldBegin('authorization_exception', TType.STRUCT, 2)
      self.authorization_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authentication_exception is not None:
      oprot.writeFieldBegin('authentication_exception', TType.STRUCT, 3)
      self.authentication_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.reference_exception is not None:
      oprot.writeFieldBegin('reference_exception', TType.STRUCT, 4)
      self.reference_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.attribute_exception is not None:
      oprot.writeFieldBegin('attribute_exception', TType.STRUCT, 5)
      self.attribute_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.type_exception is not None:
      oprot.writeFieldBegin('type_exception', TType.STRUCT, 6)
      self.type_exception.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.generic_exception)
    value = (value * 31) ^ hash(self.authorization_exception)
    value = (value * 31) ^ hash(self.authentication_exception)
    value = (value * 31) ^ hash(self.reference_exception)
    value = (value * 31) ^ hash(self.attribute_exception)
    value = (value * 31) ^ hash(self.type_exception)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_scientific_name_args:
  """
  Attributes:
   - token
   - ref
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token', None, None, ), # 1
    (2, TType.STRING, 'ref', None, None, ), # 2
  )

  def __init__(self, token=None, ref=None,):
    self.token = token
    self.ref = ref

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ref = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_scientific_name_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 1)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    if self.ref is not None:
      oprot.writeFieldBegin('ref', TType.STRING, 2)
      oprot.writeString(self.ref)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.token)
    value = (value * 31) ^ hash(self.ref)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_scientific_name_result:
  """
  Attributes:
   - success
   - generic_exception
   - authorization_exception
   - authentication_exception
   - reference_exception
   - attribute_exception
   - type_exception
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'generic_exception', (ServiceException, ServiceException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'authorization_exception', (AuthorizationException, AuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'authentication_exception', (AuthenticationException, AuthenticationException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'reference_exception', (ObjectReferenceException, ObjectReferenceException.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'attribute_exception', (AttributeException, AttributeException.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'type_exception', (TypeException, TypeException.thrift_spec), None, ), # 6
  )

  def __init__(self, success=None, generic_exception=None, authorization_exception=None, authentication_exception=None, reference_exception=None, attribute_exception=None, type_exception=None,):
    self.success = success
    self.generic_exception = generic_exception
    self.authorization_exception = authorization_exception
    self.authentication_exception = authentication_exception
    self.reference_exception = reference_exception
    self.attribute_exception = attribute_exception
    self.type_exception = type_exception

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_exception = ServiceException()
          self.generic_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.authorization_exception = AuthorizationException()
          self.authorization_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.authentication_exception = AuthenticationException()
          self.authentication_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.reference_exception = ObjectReferenceException()
          self.reference_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.attribute_exception = AttributeException()
          self.attribute_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.type_exception = TypeException()
          self.type_exception.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_scientific_name_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.generic_exception is not None:
      oprot.writeFieldBegin('generic_exception', TType.STRUCT, 1)
      self.generic_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authorization_exception is not None:
      oprot.writeFieldBegin('authorization_exception', TType.STRUCT, 2)
      self.authorization_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authentication_exception is not None:
      oprot.writeFieldBegin('authentication_exception', TType.STRUCT, 3)
      self.authentication_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.reference_exception is not None:
      oprot.writeFieldBegin('reference_exception', TType.STRUCT, 4)
      self.reference_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.attribute_exception is not None:
      oprot.writeFieldBegin('attribute_exception', TType.STRUCT, 5)
      self.attribute_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.type_exception is not None:
      oprot.writeFieldBegin('type_exception', TType.STRUCT, 6)
      self.type_exception.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.generic_exception)
    value = (value * 31) ^ hash(self.authorization_exception)
    value = (value * 31) ^ hash(self.authentication_exception)
    value = (value * 31) ^ hash(self.reference_exception)
    value = (value * 31) ^ hash(self.attribute_exception)
    value = (value * 31) ^ hash(self.type_exception)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_taxonomic_id_args:
  """
  Attributes:
   - token
   - ref
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token', None, None, ), # 1
    (2, TType.STRING, 'ref', None, None, ), # 2
  )

  def __init__(self, token=None, ref=None,):
    self.token = token
    self.ref = ref

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ref = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_taxonomic_id_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 1)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    if self.ref is not None:
      oprot.writeFieldBegin('ref', TType.STRING, 2)
      oprot.writeString(self.ref)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.token)
    value = (value * 31) ^ hash(self.ref)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_taxonomic_id_result:
  """
  Attributes:
   - success
   - generic_exception
   - authorization_exception
   - authentication_exception
   - reference_exception
   - attribute_exception
   - type_exception
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'generic_exception', (ServiceException, ServiceException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'authorization_exception', (AuthorizationException, AuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'authentication_exception', (AuthenticationException, AuthenticationException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'reference_exception', (ObjectReferenceException, ObjectReferenceException.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'attribute_exception', (AttributeException, AttributeException.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'type_exception', (TypeException, TypeException.thrift_spec), None, ), # 6
  )

  def __init__(self, success=None, generic_exception=None, authorization_exception=None, authentication_exception=None, reference_exception=None, attribute_exception=None, type_exception=None,):
    self.success = success
    self.generic_exception = generic_exception
    self.authorization_exception = authorization_exception
    self.authentication_exception = authentication_exception
    self.reference_exception = reference_exception
    self.attribute_exception = attribute_exception
    self.type_exception = type_exception

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_exception = ServiceException()
          self.generic_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.authorization_exception = AuthorizationException()
          self.authorization_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.authentication_exception = AuthenticationException()
          self.authentication_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.reference_exception = ObjectReferenceException()
          self.reference_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.attribute_exception = AttributeException()
          self.attribute_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.type_exception = TypeException()
          self.type_exception.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_taxonomic_id_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.generic_exception is not None:
      oprot.writeFieldBegin('generic_exception', TType.STRUCT, 1)
      self.generic_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authorization_exception is not None:
      oprot.writeFieldBegin('authorization_exception', TType.STRUCT, 2)
      self.authorization_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authentication_exception is not None:
      oprot.writeFieldBegin('authentication_exception', TType.STRUCT, 3)
      self.authentication_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.reference_exception is not None:
      oprot.writeFieldBegin('reference_exception', TType.STRUCT, 4)
      self.reference_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.attribute_exception is not None:
      oprot.writeFieldBegin('attribute_exception', TType.STRUCT, 5)
      self.attribute_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.type_exception is not None:
      oprot.writeFieldBegin('type_exception', TType.STRUCT, 6)
      self.type_exception.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.generic_exception)
    value = (value * 31) ^ hash(self.authorization_exception)
    value = (value * 31) ^ hash(self.authentication_exception)
    value = (value * 31) ^ hash(self.reference_exception)
    value = (value * 31) ^ hash(self.attribute_exception)
    value = (value * 31) ^ hash(self.type_exception)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_kingdom_args:
  """
  Attributes:
   - token
   - ref
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token', None, None, ), # 1
    (2, TType.STRING, 'ref', None, None, ), # 2
  )

  def __init__(self, token=None, ref=None,):
    self.token = token
    self.ref = ref

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ref = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_kingdom_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 1)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    if self.ref is not None:
      oprot.writeFieldBegin('ref', TType.STRING, 2)
      oprot.writeString(self.ref)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.token)
    value = (value * 31) ^ hash(self.ref)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_kingdom_result:
  """
  Attributes:
   - success
   - generic_exception
   - authorization_exception
   - authentication_exception
   - reference_exception
   - attribute_exception
   - type_exception
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'generic_exception', (ServiceException, ServiceException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'authorization_exception', (AuthorizationException, AuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'authentication_exception', (AuthenticationException, AuthenticationException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'reference_exception', (ObjectReferenceException, ObjectReferenceException.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'attribute_exception', (AttributeException, AttributeException.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'type_exception', (TypeException, TypeException.thrift_spec), None, ), # 6
  )

  def __init__(self, success=None, generic_exception=None, authorization_exception=None, authentication_exception=None, reference_exception=None, attribute_exception=None, type_exception=None,):
    self.success = success
    self.generic_exception = generic_exception
    self.authorization_exception = authorization_exception
    self.authentication_exception = authentication_exception
    self.reference_exception = reference_exception
    self.attribute_exception = attribute_exception
    self.type_exception = type_exception

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_exception = ServiceException()
          self.generic_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.authorization_exception = AuthorizationException()
          self.authorization_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.authentication_exception = AuthenticationException()
          self.authentication_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.reference_exception = ObjectReferenceException()
          self.reference_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.attribute_exception = AttributeException()
          self.attribute_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.type_exception = TypeException()
          self.type_exception.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_kingdom_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.generic_exception is not None:
      oprot.writeFieldBegin('generic_exception', TType.STRUCT, 1)
      self.generic_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authorization_exception is not None:
      oprot.writeFieldBegin('authorization_exception', TType.STRUCT, 2)
      self.authorization_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authentication_exception is not None:
      oprot.writeFieldBegin('authentication_exception', TType.STRUCT, 3)
      self.authentication_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.reference_exception is not None:
      oprot.writeFieldBegin('reference_exception', TType.STRUCT, 4)
      self.reference_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.attribute_exception is not None:
      oprot.writeFieldBegin('attribute_exception', TType.STRUCT, 5)
      self.attribute_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.type_exception is not None:
      oprot.writeFieldBegin('type_exception', TType.STRUCT, 6)
      self.type_exception.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.generic_exception)
    value = (value * 31) ^ hash(self.authorization_exception)
    value = (value * 31) ^ hash(self.authentication_exception)
    value = (value * 31) ^ hash(self.reference_exception)
    value = (value * 31) ^ hash(self.attribute_exception)
    value = (value * 31) ^ hash(self.type_exception)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_domain_args:
  """
  Attributes:
   - token
   - ref
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token', None, None, ), # 1
    (2, TType.STRING, 'ref', None, None, ), # 2
  )

  def __init__(self, token=None, ref=None,):
    self.token = token
    self.ref = ref

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ref = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_domain_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 1)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    if self.ref is not None:
      oprot.writeFieldBegin('ref', TType.STRING, 2)
      oprot.writeString(self.ref)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.token)
    value = (value * 31) ^ hash(self.ref)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_domain_result:
  """
  Attributes:
   - success
   - generic_exception
   - authorization_exception
   - authentication_exception
   - reference_exception
   - attribute_exception
   - type_exception
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'generic_exception', (ServiceException, ServiceException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'authorization_exception', (AuthorizationException, AuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'authentication_exception', (AuthenticationException, AuthenticationException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'reference_exception', (ObjectReferenceException, ObjectReferenceException.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'attribute_exception', (AttributeException, AttributeException.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'type_exception', (TypeException, TypeException.thrift_spec), None, ), # 6
  )

  def __init__(self, success=None, generic_exception=None, authorization_exception=None, authentication_exception=None, reference_exception=None, attribute_exception=None, type_exception=None,):
    self.success = success
    self.generic_exception = generic_exception
    self.authorization_exception = authorization_exception
    self.authentication_exception = authentication_exception
    self.reference_exception = reference_exception
    self.attribute_exception = attribute_exception
    self.type_exception = type_exception

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_exception = ServiceException()
          self.generic_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.authorization_exception = AuthorizationException()
          self.authorization_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.authentication_exception = AuthenticationException()
          self.authentication_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.reference_exception = ObjectReferenceException()
          self.reference_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.attribute_exception = AttributeException()
          self.attribute_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.type_exception = TypeException()
          self.type_exception.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_domain_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.generic_exception is not None:
      oprot.writeFieldBegin('generic_exception', TType.STRUCT, 1)
      self.generic_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authorization_exception is not None:
      oprot.writeFieldBegin('authorization_exception', TType.STRUCT, 2)
      self.authorization_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authentication_exception is not None:
      oprot.writeFieldBegin('authentication_exception', TType.STRUCT, 3)
      self.authentication_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.reference_exception is not None:
      oprot.writeFieldBegin('reference_exception', TType.STRUCT, 4)
      self.reference_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.attribute_exception is not None:
      oprot.writeFieldBegin('attribute_exception', TType.STRUCT, 5)
      self.attribute_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.type_exception is not None:
      oprot.writeFieldBegin('type_exception', TType.STRUCT, 6)
      self.type_exception.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.generic_exception)
    value = (value * 31) ^ hash(self.authorization_exception)
    value = (value * 31) ^ hash(self.authentication_exception)
    value = (value * 31) ^ hash(self.reference_exception)
    value = (value * 31) ^ hash(self.attribute_exception)
    value = (value * 31) ^ hash(self.type_exception)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_genetic_code_args:
  """
  Attributes:
   - token
   - ref
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token', None, None, ), # 1
    (2, TType.STRING, 'ref', None, None, ), # 2
  )

  def __init__(self, token=None, ref=None,):
    self.token = token
    self.ref = ref

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ref = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_genetic_code_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 1)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    if self.ref is not None:
      oprot.writeFieldBegin('ref', TType.STRING, 2)
      oprot.writeString(self.ref)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.token)
    value = (value * 31) ^ hash(self.ref)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_genetic_code_result:
  """
  Attributes:
   - success
   - generic_exception
   - authorization_exception
   - authentication_exception
   - reference_exception
   - attribute_exception
   - type_exception
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'generic_exception', (ServiceException, ServiceException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'authorization_exception', (AuthorizationException, AuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'authentication_exception', (AuthenticationException, AuthenticationException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'reference_exception', (ObjectReferenceException, ObjectReferenceException.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'attribute_exception', (AttributeException, AttributeException.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'type_exception', (TypeException, TypeException.thrift_spec), None, ), # 6
  )

  def __init__(self, success=None, generic_exception=None, authorization_exception=None, authentication_exception=None, reference_exception=None, attribute_exception=None, type_exception=None,):
    self.success = success
    self.generic_exception = generic_exception
    self.authorization_exception = authorization_exception
    self.authentication_exception = authentication_exception
    self.reference_exception = reference_exception
    self.attribute_exception = attribute_exception
    self.type_exception = type_exception

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_exception = ServiceException()
          self.generic_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.authorization_exception = AuthorizationException()
          self.authorization_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.authentication_exception = AuthenticationException()
          self.authentication_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.reference_exception = ObjectReferenceException()
          self.reference_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.attribute_exception = AttributeException()
          self.attribute_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.type_exception = TypeException()
          self.type_exception.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_genetic_code_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.generic_exception is not None:
      oprot.writeFieldBegin('generic_exception', TType.STRUCT, 1)
      self.generic_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authorization_exception is not None:
      oprot.writeFieldBegin('authorization_exception', TType.STRUCT, 2)
      self.authorization_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authentication_exception is not None:
      oprot.writeFieldBegin('authentication_exception', TType.STRUCT, 3)
      self.authentication_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.reference_exception is not None:
      oprot.writeFieldBegin('reference_exception', TType.STRUCT, 4)
      self.reference_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.attribute_exception is not None:
      oprot.writeFieldBegin('attribute_exception', TType.STRUCT, 5)
      self.attribute_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.type_exception is not None:
      oprot.writeFieldBegin('type_exception', TType.STRUCT, 6)
      self.type_exception.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.generic_exception)
    value = (value * 31) ^ hash(self.authorization_exception)
    value = (value * 31) ^ hash(self.authentication_exception)
    value = (value * 31) ^ hash(self.reference_exception)
    value = (value * 31) ^ hash(self.attribute_exception)
    value = (value * 31) ^ hash(self.type_exception)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_aliases_args:
  """
  Attributes:
   - token
   - ref
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token', None, None, ), # 1
    (2, TType.STRING, 'ref', None, None, ), # 2
  )

  def __init__(self, token=None, ref=None,):
    self.token = token
    self.ref = ref

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ref = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_aliases_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 1)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    if self.ref is not None:
      oprot.writeFieldBegin('ref', TType.STRING, 2)
      oprot.writeString(self.ref)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.token)
    value = (value * 31) ^ hash(self.ref)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_aliases_result:
  """
  Attributes:
   - success
   - generic_exception
   - authorization_exception
   - authentication_exception
   - reference_exception
   - attribute_exception
   - type_exception
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'generic_exception', (ServiceException, ServiceException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'authorization_exception', (AuthorizationException, AuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'authentication_exception', (AuthenticationException, AuthenticationException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'reference_exception', (ObjectReferenceException, ObjectReferenceException.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'attribute_exception', (AttributeException, AttributeException.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'type_exception', (TypeException, TypeException.thrift_spec), None, ), # 6
  )

  def __init__(self, success=None, generic_exception=None, authorization_exception=None, authentication_exception=None, reference_exception=None, attribute_exception=None, type_exception=None,):
    self.success = success
    self.generic_exception = generic_exception
    self.authorization_exception = authorization_exception
    self.authentication_exception = authentication_exception
    self.reference_exception = reference_exception
    self.attribute_exception = attribute_exception
    self.type_exception = type_exception

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype105, _size102) = iprot.readListBegin()
          for _i106 in xrange(_size102):
            _elem107 = iprot.readString();
            self.success.append(_elem107)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_exception = ServiceException()
          self.generic_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.authorization_exception = AuthorizationException()
          self.authorization_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.authentication_exception = AuthenticationException()
          self.authentication_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.reference_exception = ObjectReferenceException()
          self.reference_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.attribute_exception = AttributeException()
          self.attribute_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.type_exception = TypeException()
          self.type_exception.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_aliases_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter108 in self.success:
        oprot.writeString(iter108)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.generic_exception is not None:
      oprot.writeFieldBegin('generic_exception', TType.STRUCT, 1)
      self.generic_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authorization_exception is not None:
      oprot.writeFieldBegin('authorization_exception', TType.STRUCT, 2)
      self.authorization_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authentication_exception is not None:
      oprot.writeFieldBegin('authentication_exception', TType.STRUCT, 3)
      self.authentication_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.reference_exception is not None:
      oprot.writeFieldBegin('reference_exception', TType.STRUCT, 4)
      self.reference_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.attribute_exception is not None:
      oprot.writeFieldBegin('attribute_exception', TType.STRUCT, 5)
      self.attribute_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.type_exception is not None:
      oprot.writeFieldBegin('type_exception', TType.STRUCT, 6)
      self.type_exception.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.generic_exception)
    value = (value * 31) ^ hash(self.authorization_exception)
    value = (value * 31) ^ hash(self.authentication_exception)
    value = (value * 31) ^ hash(self.reference_exception)
    value = (value * 31) ^ hash(self.attribute_exception)
    value = (value * 31) ^ hash(self.type_exception)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
