#
# Autogenerated by Thrift Compiler (0.9.2)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
require 5.6.0;
use strict;
use warnings;
use Thrift;

package genome_annotation::ServiceException;
use base qw(Thrift::TException);
use base qw(Class::Accessor);
genome_annotation::ServiceException->mk_accessors( qw( message stacktrace inputs ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{message} = undef;
  $self->{stacktrace} = undef;
  $self->{inputs} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{message}) {
      $self->{message} = $vals->{message};
    }
    if (defined $vals->{stacktrace}) {
      $self->{stacktrace} = $vals->{stacktrace};
    }
    if (defined $vals->{inputs}) {
      $self->{inputs} = $vals->{inputs};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ServiceException';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{message});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{stacktrace});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size0 = 0;
          $self->{inputs} = {};
          my $_ktype1 = 0;
          my $_vtype2 = 0;
          $xfer += $input->readMapBegin(\$_ktype1, \$_vtype2, \$_size0);
          for (my $_i4 = 0; $_i4 < $_size0; ++$_i4)
          {
            my $key5 = '';
            my $val6 = '';
            $xfer += $input->readString(\$key5);
            $xfer += $input->readString(\$val6);
            $self->{inputs}->{$key5} = $val6;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ServiceException');
  if (defined $self->{message}) {
    $xfer += $output->writeFieldBegin('message', TType::STRING, 1);
    $xfer += $output->writeString($self->{message});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{stacktrace}) {
    $xfer += $output->writeFieldBegin('stacktrace', TType::STRING, 2);
    $xfer += $output->writeString($self->{stacktrace});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{inputs}) {
    $xfer += $output->writeFieldBegin('inputs', TType::MAP, 3);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{inputs}}));
      {
        while( my ($kiter7,$viter8) = each %{$self->{inputs}}) 
        {
          $xfer += $output->writeString($kiter7);
          $xfer += $output->writeString($viter8);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package genome_annotation::AuthorizationException;
use base qw(Thrift::TException);
use base qw(Class::Accessor);
genome_annotation::AuthorizationException->mk_accessors( qw( message stacktrace ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{message} = undef;
  $self->{stacktrace} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{message}) {
      $self->{message} = $vals->{message};
    }
    if (defined $vals->{stacktrace}) {
      $self->{stacktrace} = $vals->{stacktrace};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'AuthorizationException';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{message});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{stacktrace});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('AuthorizationException');
  if (defined $self->{message}) {
    $xfer += $output->writeFieldBegin('message', TType::STRING, 1);
    $xfer += $output->writeString($self->{message});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{stacktrace}) {
    $xfer += $output->writeFieldBegin('stacktrace', TType::STRING, 2);
    $xfer += $output->writeString($self->{stacktrace});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package genome_annotation::AuthenticationException;
use base qw(Thrift::TException);
use base qw(Class::Accessor);
genome_annotation::AuthenticationException->mk_accessors( qw( message stacktrace ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{message} = undef;
  $self->{stacktrace} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{message}) {
      $self->{message} = $vals->{message};
    }
    if (defined $vals->{stacktrace}) {
      $self->{stacktrace} = $vals->{stacktrace};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'AuthenticationException';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{message});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{stacktrace});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('AuthenticationException');
  if (defined $self->{message}) {
    $xfer += $output->writeFieldBegin('message', TType::STRING, 1);
    $xfer += $output->writeString($self->{message});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{stacktrace}) {
    $xfer += $output->writeFieldBegin('stacktrace', TType::STRING, 2);
    $xfer += $output->writeString($self->{stacktrace});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package genome_annotation::ObjectReferenceException;
use base qw(Thrift::TException);
use base qw(Class::Accessor);
genome_annotation::ObjectReferenceException->mk_accessors( qw( message stacktrace ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{message} = undef;
  $self->{stacktrace} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{message}) {
      $self->{message} = $vals->{message};
    }
    if (defined $vals->{stacktrace}) {
      $self->{stacktrace} = $vals->{stacktrace};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ObjectReferenceException';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{message});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{stacktrace});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ObjectReferenceException');
  if (defined $self->{message}) {
    $xfer += $output->writeFieldBegin('message', TType::STRING, 1);
    $xfer += $output->writeString($self->{message});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{stacktrace}) {
    $xfer += $output->writeFieldBegin('stacktrace', TType::STRING, 2);
    $xfer += $output->writeString($self->{stacktrace});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package genome_annotation::AttributeException;
use base qw(Thrift::TException);
use base qw(Class::Accessor);
genome_annotation::AttributeException->mk_accessors( qw( message stacktrace ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{message} = undef;
  $self->{stacktrace} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{message}) {
      $self->{message} = $vals->{message};
    }
    if (defined $vals->{stacktrace}) {
      $self->{stacktrace} = $vals->{stacktrace};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'AttributeException';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{message});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{stacktrace});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('AttributeException');
  if (defined $self->{message}) {
    $xfer += $output->writeFieldBegin('message', TType::STRING, 1);
    $xfer += $output->writeString($self->{message});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{stacktrace}) {
    $xfer += $output->writeFieldBegin('stacktrace', TType::STRING, 2);
    $xfer += $output->writeString($self->{stacktrace});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package genome_annotation::TypeException;
use base qw(Thrift::TException);
use base qw(Class::Accessor);
genome_annotation::TypeException->mk_accessors( qw( message stacktrace valid_types ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{message} = undef;
  $self->{stacktrace} = undef;
  $self->{valid_types} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{message}) {
      $self->{message} = $vals->{message};
    }
    if (defined $vals->{stacktrace}) {
      $self->{stacktrace} = $vals->{stacktrace};
    }
    if (defined $vals->{valid_types}) {
      $self->{valid_types} = $vals->{valid_types};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'TypeException';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{message});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{stacktrace});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size9 = 0;
          $self->{valid_types} = [];
          my $_etype12 = 0;
          $xfer += $input->readListBegin(\$_etype12, \$_size9);
          for (my $_i13 = 0; $_i13 < $_size9; ++$_i13)
          {
            my $elem14 = undef;
            $xfer += $input->readString(\$elem14);
            push(@{$self->{valid_types}},$elem14);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('TypeException');
  if (defined $self->{message}) {
    $xfer += $output->writeFieldBegin('message', TType::STRING, 1);
    $xfer += $output->writeString($self->{message});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{stacktrace}) {
    $xfer += $output->writeFieldBegin('stacktrace', TType::STRING, 2);
    $xfer += $output->writeString($self->{stacktrace});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{valid_types}) {
    $xfer += $output->writeFieldBegin('valid_types', TType::LIST, 3);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{valid_types}}));
      {
        foreach my $iter15 (@{$self->{valid_types}}) 
        {
          $xfer += $output->writeString($iter15);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package genome_annotation::Region;
use base qw(Class::Accessor);
genome_annotation::Region->mk_accessors( qw( contig_id strand start length ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{contig_id} = undef;
  $self->{strand} = undef;
  $self->{start} = undef;
  $self->{length} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{contig_id}) {
      $self->{contig_id} = $vals->{contig_id};
    }
    if (defined $vals->{strand}) {
      $self->{strand} = $vals->{strand};
    }
    if (defined $vals->{start}) {
      $self->{start} = $vals->{start};
    }
    if (defined $vals->{length}) {
      $self->{length} = $vals->{length};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Region';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{contig_id});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{strand});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{start});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{length});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Region');
  if (defined $self->{contig_id}) {
    $xfer += $output->writeFieldBegin('contig_id', TType::STRING, 1);
    $xfer += $output->writeString($self->{contig_id});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{strand}) {
    $xfer += $output->writeFieldBegin('strand', TType::STRING, 2);
    $xfer += $output->writeString($self->{strand});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{start}) {
    $xfer += $output->writeFieldBegin('start', TType::I64, 3);
    $xfer += $output->writeI64($self->{start});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{length}) {
    $xfer += $output->writeFieldBegin('length', TType::I64, 4);
    $xfer += $output->writeI64($self->{length});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package genome_annotation::Feature_id_filters;
use base qw(Class::Accessor);
genome_annotation::Feature_id_filters->mk_accessors( qw( type_list region_list function_list alias_list ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{type_list} = [
];
  $self->{region_list} = [
];
  $self->{function_list} = [
];
  $self->{alias_list} = [
];
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{type_list}) {
      $self->{type_list} = $vals->{type_list};
    }
    if (defined $vals->{region_list}) {
      $self->{region_list} = $vals->{region_list};
    }
    if (defined $vals->{function_list}) {
      $self->{function_list} = $vals->{function_list};
    }
    if (defined $vals->{alias_list}) {
      $self->{alias_list} = $vals->{alias_list};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Feature_id_filters';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size16 = 0;
          $self->{type_list} = [];
          my $_etype19 = 0;
          $xfer += $input->readListBegin(\$_etype19, \$_size16);
          for (my $_i20 = 0; $_i20 < $_size16; ++$_i20)
          {
            my $elem21 = undef;
            $xfer += $input->readString(\$elem21);
            push(@{$self->{type_list}},$elem21);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size22 = 0;
          $self->{region_list} = [];
          my $_etype25 = 0;
          $xfer += $input->readListBegin(\$_etype25, \$_size22);
          for (my $_i26 = 0; $_i26 < $_size22; ++$_i26)
          {
            my $elem27 = undef;
            $elem27 = new genome_annotation::Region();
            $xfer += $elem27->read($input);
            push(@{$self->{region_list}},$elem27);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size28 = 0;
          $self->{function_list} = [];
          my $_etype31 = 0;
          $xfer += $input->readListBegin(\$_etype31, \$_size28);
          for (my $_i32 = 0; $_i32 < $_size28; ++$_i32)
          {
            my $elem33 = undef;
            $xfer += $input->readString(\$elem33);
            push(@{$self->{function_list}},$elem33);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size34 = 0;
          $self->{alias_list} = [];
          my $_etype37 = 0;
          $xfer += $input->readListBegin(\$_etype37, \$_size34);
          for (my $_i38 = 0; $_i38 < $_size34; ++$_i38)
          {
            my $elem39 = undef;
            $xfer += $input->readString(\$elem39);
            push(@{$self->{alias_list}},$elem39);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Feature_id_filters');
  if (defined $self->{type_list}) {
    $xfer += $output->writeFieldBegin('type_list', TType::LIST, 1);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{type_list}}));
      {
        foreach my $iter40 (@{$self->{type_list}}) 
        {
          $xfer += $output->writeString($iter40);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{region_list}) {
    $xfer += $output->writeFieldBegin('region_list', TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{region_list}}));
      {
        foreach my $iter41 (@{$self->{region_list}}) 
        {
          $xfer += ${iter41}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{function_list}) {
    $xfer += $output->writeFieldBegin('function_list', TType::LIST, 3);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{function_list}}));
      {
        foreach my $iter42 (@{$self->{function_list}}) 
        {
          $xfer += $output->writeString($iter42);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{alias_list}) {
    $xfer += $output->writeFieldBegin('alias_list', TType::LIST, 4);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{alias_list}}));
      {
        foreach my $iter43 (@{$self->{alias_list}}) 
        {
          $xfer += $output->writeString($iter43);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package genome_annotation::Feature_id_mapping;
use base qw(Class::Accessor);
genome_annotation::Feature_id_mapping->mk_accessors( qw( by_type by_region by_function by_alias ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{by_type} = {
};
  $self->{by_region} = {
};
  $self->{by_function} = {
};
  $self->{by_alias} = {
};
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{by_type}) {
      $self->{by_type} = $vals->{by_type};
    }
    if (defined $vals->{by_region}) {
      $self->{by_region} = $vals->{by_region};
    }
    if (defined $vals->{by_function}) {
      $self->{by_function} = $vals->{by_function};
    }
    if (defined $vals->{by_alias}) {
      $self->{by_alias} = $vals->{by_alias};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Feature_id_mapping';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size44 = 0;
          $self->{by_type} = {};
          my $_ktype45 = 0;
          my $_vtype46 = 0;
          $xfer += $input->readMapBegin(\$_ktype45, \$_vtype46, \$_size44);
          for (my $_i48 = 0; $_i48 < $_size44; ++$_i48)
          {
            my $key49 = '';
            my $val50 = [];
            $xfer += $input->readString(\$key49);
            {
              my $_size51 = 0;
              $val50 = [];
              my $_etype54 = 0;
              $xfer += $input->readListBegin(\$_etype54, \$_size51);
              for (my $_i55 = 0; $_i55 < $_size51; ++$_i55)
              {
                my $elem56 = undef;
                $xfer += $input->readString(\$elem56);
                push(@{$val50},$elem56);
              }
              $xfer += $input->readListEnd();
            }
            $self->{by_type}->{$key49} = $val50;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size57 = 0;
          $self->{by_region} = {};
          my $_ktype58 = 0;
          my $_vtype59 = 0;
          $xfer += $input->readMapBegin(\$_ktype58, \$_vtype59, \$_size57);
          for (my $_i61 = 0; $_i61 < $_size57; ++$_i61)
          {
            my $key62 = '';
            my $val63 = [];
            $xfer += $input->readString(\$key62);
            {
              my $_size64 = 0;
              $val63 = {};
              my $_ktype65 = 0;
              my $_vtype66 = 0;
              $xfer += $input->readMapBegin(\$_ktype65, \$_vtype66, \$_size64);
              for (my $_i68 = 0; $_i68 < $_size64; ++$_i68)
              {
                my $key69 = '';
                my $val70 = [];
                $xfer += $input->readString(\$key69);
                {
                  my $_size71 = 0;
                  $val70 = {};
                  my $_ktype72 = 0;
                  my $_vtype73 = 0;
                  $xfer += $input->readMapBegin(\$_ktype72, \$_vtype73, \$_size71);
                  for (my $_i75 = 0; $_i75 < $_size71; ++$_i75)
                  {
                    my $key76 = '';
                    my $val77 = [];
                    $xfer += $input->readString(\$key76);
                    {
                      my $_size78 = 0;
                      $val77 = [];
                      my $_etype81 = 0;
                      $xfer += $input->readListBegin(\$_etype81, \$_size78);
                      for (my $_i82 = 0; $_i82 < $_size78; ++$_i82)
                      {
                        my $elem83 = undef;
                        $xfer += $input->readString(\$elem83);
                        push(@{$val77},$elem83);
                      }
                      $xfer += $input->readListEnd();
                    }
                    $val70->{$key76} = $val77;
                  }
                  $xfer += $input->readMapEnd();
                }
                $val63->{$key69} = $val70;
              }
              $xfer += $input->readMapEnd();
            }
            $self->{by_region}->{$key62} = $val63;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size84 = 0;
          $self->{by_function} = {};
          my $_ktype85 = 0;
          my $_vtype86 = 0;
          $xfer += $input->readMapBegin(\$_ktype85, \$_vtype86, \$_size84);
          for (my $_i88 = 0; $_i88 < $_size84; ++$_i88)
          {
            my $key89 = '';
            my $val90 = [];
            $xfer += $input->readString(\$key89);
            {
              my $_size91 = 0;
              $val90 = [];
              my $_etype94 = 0;
              $xfer += $input->readListBegin(\$_etype94, \$_size91);
              for (my $_i95 = 0; $_i95 < $_size91; ++$_i95)
              {
                my $elem96 = undef;
                $xfer += $input->readString(\$elem96);
                push(@{$val90},$elem96);
              }
              $xfer += $input->readListEnd();
            }
            $self->{by_function}->{$key89} = $val90;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size97 = 0;
          $self->{by_alias} = {};
          my $_ktype98 = 0;
          my $_vtype99 = 0;
          $xfer += $input->readMapBegin(\$_ktype98, \$_vtype99, \$_size97);
          for (my $_i101 = 0; $_i101 < $_size97; ++$_i101)
          {
            my $key102 = '';
            my $val103 = [];
            $xfer += $input->readString(\$key102);
            {
              my $_size104 = 0;
              $val103 = [];
              my $_etype107 = 0;
              $xfer += $input->readListBegin(\$_etype107, \$_size104);
              for (my $_i108 = 0; $_i108 < $_size104; ++$_i108)
              {
                my $elem109 = undef;
                $xfer += $input->readString(\$elem109);
                push(@{$val103},$elem109);
              }
              $xfer += $input->readListEnd();
            }
            $self->{by_alias}->{$key102} = $val103;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Feature_id_mapping');
  if (defined $self->{by_type}) {
    $xfer += $output->writeFieldBegin('by_type', TType::MAP, 1);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::LIST, scalar(keys %{$self->{by_type}}));
      {
        while( my ($kiter110,$viter111) = each %{$self->{by_type}}) 
        {
          $xfer += $output->writeString($kiter110);
          {
            $xfer += $output->writeListBegin(TType::STRING, scalar(@{${viter111}}));
            {
              foreach my $iter112 (@{${viter111}}) 
              {
                $xfer += $output->writeString($iter112);
              }
            }
            $xfer += $output->writeListEnd();
          }
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{by_region}) {
    $xfer += $output->writeFieldBegin('by_region', TType::MAP, 2);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::MAP, scalar(keys %{$self->{by_region}}));
      {
        while( my ($kiter113,$viter114) = each %{$self->{by_region}}) 
        {
          $xfer += $output->writeString($kiter113);
          {
            $xfer += $output->writeMapBegin(TType::STRING, TType::MAP, scalar(keys %{${viter114}}));
            {
              while( my ($kiter115,$viter116) = each %{${viter114}}) 
              {
                $xfer += $output->writeString($kiter115);
                {
                  $xfer += $output->writeMapBegin(TType::STRING, TType::LIST, scalar(keys %{${viter116}}));
                  {
                    while( my ($kiter117,$viter118) = each %{${viter116}}) 
                    {
                      $xfer += $output->writeString($kiter117);
                      {
                        $xfer += $output->writeListBegin(TType::STRING, scalar(@{${viter118}}));
                        {
                          foreach my $iter119 (@{${viter118}}) 
                          {
                            $xfer += $output->writeString($iter119);
                          }
                        }
                        $xfer += $output->writeListEnd();
                      }
                    }
                  }
                  $xfer += $output->writeMapEnd();
                }
              }
            }
            $xfer += $output->writeMapEnd();
          }
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{by_function}) {
    $xfer += $output->writeFieldBegin('by_function', TType::MAP, 3);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::LIST, scalar(keys %{$self->{by_function}}));
      {
        while( my ($kiter120,$viter121) = each %{$self->{by_function}}) 
        {
          $xfer += $output->writeString($kiter120);
          {
            $xfer += $output->writeListBegin(TType::STRING, scalar(@{${viter121}}));
            {
              foreach my $iter122 (@{${viter121}}) 
              {
                $xfer += $output->writeString($iter122);
              }
            }
            $xfer += $output->writeListEnd();
          }
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{by_alias}) {
    $xfer += $output->writeFieldBegin('by_alias', TType::MAP, 4);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::LIST, scalar(keys %{$self->{by_alias}}));
      {
        while( my ($kiter123,$viter124) = each %{$self->{by_alias}}) 
        {
          $xfer += $output->writeString($kiter123);
          {
            $xfer += $output->writeListBegin(TType::STRING, scalar(@{${viter124}}));
            {
              foreach my $iter125 (@{${viter124}}) 
              {
                $xfer += $output->writeString($iter125);
              }
            }
            $xfer += $output->writeListEnd();
          }
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package genome_annotation::Feature_data;
use base qw(Class::Accessor);
genome_annotation::Feature_data->mk_accessors( qw( feature_id feature_type feature_function feature_aliases feature_dna_sequence_length feature_dna_sequence feature_md5 feature_locations feature_publications feature_quality_warnings feature_quality_score feature_notes feature_inference ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{feature_id} = undef;
  $self->{feature_type} = undef;
  $self->{feature_function} = undef;
  $self->{feature_aliases} = undef;
  $self->{feature_dna_sequence_length} = undef;
  $self->{feature_dna_sequence} = undef;
  $self->{feature_md5} = undef;
  $self->{feature_locations} = undef;
  $self->{feature_publications} = undef;
  $self->{feature_quality_warnings} = undef;
  $self->{feature_quality_score} = undef;
  $self->{feature_notes} = undef;
  $self->{feature_inference} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{feature_id}) {
      $self->{feature_id} = $vals->{feature_id};
    }
    if (defined $vals->{feature_type}) {
      $self->{feature_type} = $vals->{feature_type};
    }
    if (defined $vals->{feature_function}) {
      $self->{feature_function} = $vals->{feature_function};
    }
    if (defined $vals->{feature_aliases}) {
      $self->{feature_aliases} = $vals->{feature_aliases};
    }
    if (defined $vals->{feature_dna_sequence_length}) {
      $self->{feature_dna_sequence_length} = $vals->{feature_dna_sequence_length};
    }
    if (defined $vals->{feature_dna_sequence}) {
      $self->{feature_dna_sequence} = $vals->{feature_dna_sequence};
    }
    if (defined $vals->{feature_md5}) {
      $self->{feature_md5} = $vals->{feature_md5};
    }
    if (defined $vals->{feature_locations}) {
      $self->{feature_locations} = $vals->{feature_locations};
    }
    if (defined $vals->{feature_publications}) {
      $self->{feature_publications} = $vals->{feature_publications};
    }
    if (defined $vals->{feature_quality_warnings}) {
      $self->{feature_quality_warnings} = $vals->{feature_quality_warnings};
    }
    if (defined $vals->{feature_quality_score}) {
      $self->{feature_quality_score} = $vals->{feature_quality_score};
    }
    if (defined $vals->{feature_notes}) {
      $self->{feature_notes} = $vals->{feature_notes};
    }
    if (defined $vals->{feature_inference}) {
      $self->{feature_inference} = $vals->{feature_inference};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Feature_data';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{feature_id});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{feature_type});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{feature_function});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size126 = 0;
          $self->{feature_aliases} = {};
          my $_ktype127 = 0;
          my $_vtype128 = 0;
          $xfer += $input->readMapBegin(\$_ktype127, \$_vtype128, \$_size126);
          for (my $_i130 = 0; $_i130 < $_size126; ++$_i130)
          {
            my $key131 = '';
            my $val132 = [];
            $xfer += $input->readString(\$key131);
            {
              my $_size133 = 0;
              $val132 = [];
              my $_etype136 = 0;
              $xfer += $input->readListBegin(\$_etype136, \$_size133);
              for (my $_i137 = 0; $_i137 < $_size133; ++$_i137)
              {
                my $elem138 = undef;
                $xfer += $input->readString(\$elem138);
                push(@{$val132},$elem138);
              }
              $xfer += $input->readListEnd();
            }
            $self->{feature_aliases}->{$key131} = $val132;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{feature_dna_sequence_length});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{feature_dna_sequence});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^7$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{feature_md5});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^8$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size139 = 0;
          $self->{feature_locations} = [];
          my $_etype142 = 0;
          $xfer += $input->readListBegin(\$_etype142, \$_size139);
          for (my $_i143 = 0; $_i143 < $_size139; ++$_i143)
          {
            my $elem144 = undef;
            $elem144 = new genome_annotation::Region();
            $xfer += $elem144->read($input);
            push(@{$self->{feature_locations}},$elem144);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^9$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size145 = 0;
          $self->{feature_publications} = [];
          my $_etype148 = 0;
          $xfer += $input->readListBegin(\$_etype148, \$_size145);
          for (my $_i149 = 0; $_i149 < $_size145; ++$_i149)
          {
            my $elem150 = undef;
            $xfer += $input->readString(\$elem150);
            push(@{$self->{feature_publications}},$elem150);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^10$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size151 = 0;
          $self->{feature_quality_warnings} = [];
          my $_etype154 = 0;
          $xfer += $input->readListBegin(\$_etype154, \$_size151);
          for (my $_i155 = 0; $_i155 < $_size151; ++$_i155)
          {
            my $elem156 = undef;
            $xfer += $input->readString(\$elem156);
            push(@{$self->{feature_quality_warnings}},$elem156);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^11$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size157 = 0;
          $self->{feature_quality_score} = [];
          my $_etype160 = 0;
          $xfer += $input->readListBegin(\$_etype160, \$_size157);
          for (my $_i161 = 0; $_i161 < $_size157; ++$_i161)
          {
            my $elem162 = undef;
            $xfer += $input->readString(\$elem162);
            push(@{$self->{feature_quality_score}},$elem162);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^12$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size163 = 0;
          $self->{feature_notes} = [];
          my $_etype166 = 0;
          $xfer += $input->readListBegin(\$_etype166, \$_size163);
          for (my $_i167 = 0; $_i167 < $_size163; ++$_i167)
          {
            my $elem168 = undef;
            $xfer += $input->readString(\$elem168);
            push(@{$self->{feature_notes}},$elem168);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^13$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{feature_inference});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Feature_data');
  if (defined $self->{feature_id}) {
    $xfer += $output->writeFieldBegin('feature_id', TType::STRING, 1);
    $xfer += $output->writeString($self->{feature_id});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{feature_type}) {
    $xfer += $output->writeFieldBegin('feature_type', TType::STRING, 2);
    $xfer += $output->writeString($self->{feature_type});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{feature_function}) {
    $xfer += $output->writeFieldBegin('feature_function', TType::STRING, 3);
    $xfer += $output->writeString($self->{feature_function});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{feature_aliases}) {
    $xfer += $output->writeFieldBegin('feature_aliases', TType::MAP, 4);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::LIST, scalar(keys %{$self->{feature_aliases}}));
      {
        while( my ($kiter169,$viter170) = each %{$self->{feature_aliases}}) 
        {
          $xfer += $output->writeString($kiter169);
          {
            $xfer += $output->writeListBegin(TType::STRING, scalar(@{${viter170}}));
            {
              foreach my $iter171 (@{${viter170}}) 
              {
                $xfer += $output->writeString($iter171);
              }
            }
            $xfer += $output->writeListEnd();
          }
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{feature_dna_sequence_length}) {
    $xfer += $output->writeFieldBegin('feature_dna_sequence_length', TType::I64, 5);
    $xfer += $output->writeI64($self->{feature_dna_sequence_length});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{feature_dna_sequence}) {
    $xfer += $output->writeFieldBegin('feature_dna_sequence', TType::STRING, 6);
    $xfer += $output->writeString($self->{feature_dna_sequence});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{feature_md5}) {
    $xfer += $output->writeFieldBegin('feature_md5', TType::STRING, 7);
    $xfer += $output->writeString($self->{feature_md5});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{feature_locations}) {
    $xfer += $output->writeFieldBegin('feature_locations', TType::LIST, 8);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{feature_locations}}));
      {
        foreach my $iter172 (@{$self->{feature_locations}}) 
        {
          $xfer += ${iter172}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{feature_publications}) {
    $xfer += $output->writeFieldBegin('feature_publications', TType::LIST, 9);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{feature_publications}}));
      {
        foreach my $iter173 (@{$self->{feature_publications}}) 
        {
          $xfer += $output->writeString($iter173);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{feature_quality_warnings}) {
    $xfer += $output->writeFieldBegin('feature_quality_warnings', TType::LIST, 10);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{feature_quality_warnings}}));
      {
        foreach my $iter174 (@{$self->{feature_quality_warnings}}) 
        {
          $xfer += $output->writeString($iter174);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{feature_quality_score}) {
    $xfer += $output->writeFieldBegin('feature_quality_score', TType::LIST, 11);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{feature_quality_score}}));
      {
        foreach my $iter175 (@{$self->{feature_quality_score}}) 
        {
          $xfer += $output->writeString($iter175);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{feature_notes}) {
    $xfer += $output->writeFieldBegin('feature_notes', TType::LIST, 12);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{feature_notes}}));
      {
        foreach my $iter176 (@{$self->{feature_notes}}) 
        {
          $xfer += $output->writeString($iter176);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{feature_inference}) {
    $xfer += $output->writeFieldBegin('feature_inference', TType::STRING, 13);
    $xfer += $output->writeString($self->{feature_inference});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package genome_annotation::Protein_data;
use base qw(Class::Accessor);
genome_annotation::Protein_data->mk_accessors( qw( protein_id protein_amino_acid_sequence protein_function protein_aliases protein_md5 protein_domain_locations ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{protein_id} = undef;
  $self->{protein_amino_acid_sequence} = undef;
  $self->{protein_function} = undef;
  $self->{protein_aliases} = undef;
  $self->{protein_md5} = undef;
  $self->{protein_domain_locations} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{protein_id}) {
      $self->{protein_id} = $vals->{protein_id};
    }
    if (defined $vals->{protein_amino_acid_sequence}) {
      $self->{protein_amino_acid_sequence} = $vals->{protein_amino_acid_sequence};
    }
    if (defined $vals->{protein_function}) {
      $self->{protein_function} = $vals->{protein_function};
    }
    if (defined $vals->{protein_aliases}) {
      $self->{protein_aliases} = $vals->{protein_aliases};
    }
    if (defined $vals->{protein_md5}) {
      $self->{protein_md5} = $vals->{protein_md5};
    }
    if (defined $vals->{protein_domain_locations}) {
      $self->{protein_domain_locations} = $vals->{protein_domain_locations};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Protein_data';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{protein_id});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{protein_amino_acid_sequence});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{protein_function});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size177 = 0;
          $self->{protein_aliases} = [];
          my $_etype180 = 0;
          $xfer += $input->readListBegin(\$_etype180, \$_size177);
          for (my $_i181 = 0; $_i181 < $_size177; ++$_i181)
          {
            my $elem182 = undef;
            $xfer += $input->readString(\$elem182);
            push(@{$self->{protein_aliases}},$elem182);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{protein_md5});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size183 = 0;
          $self->{protein_domain_locations} = [];
          my $_etype186 = 0;
          $xfer += $input->readListBegin(\$_etype186, \$_size183);
          for (my $_i187 = 0; $_i187 < $_size183; ++$_i187)
          {
            my $elem188 = undef;
            $xfer += $input->readString(\$elem188);
            push(@{$self->{protein_domain_locations}},$elem188);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Protein_data');
  if (defined $self->{protein_id}) {
    $xfer += $output->writeFieldBegin('protein_id', TType::STRING, 1);
    $xfer += $output->writeString($self->{protein_id});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{protein_amino_acid_sequence}) {
    $xfer += $output->writeFieldBegin('protein_amino_acid_sequence', TType::STRING, 2);
    $xfer += $output->writeString($self->{protein_amino_acid_sequence});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{protein_function}) {
    $xfer += $output->writeFieldBegin('protein_function', TType::STRING, 3);
    $xfer += $output->writeString($self->{protein_function});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{protein_aliases}) {
    $xfer += $output->writeFieldBegin('protein_aliases', TType::LIST, 4);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{protein_aliases}}));
      {
        foreach my $iter189 (@{$self->{protein_aliases}}) 
        {
          $xfer += $output->writeString($iter189);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{protein_md5}) {
    $xfer += $output->writeFieldBegin('protein_md5', TType::STRING, 5);
    $xfer += $output->writeString($self->{protein_md5});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{protein_domain_locations}) {
    $xfer += $output->writeFieldBegin('protein_domain_locations', TType::LIST, 6);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{protein_domain_locations}}));
      {
        foreach my $iter190 (@{$self->{protein_domain_locations}}) 
        {
          $xfer += $output->writeString($iter190);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

1;
